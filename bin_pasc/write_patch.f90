subroutine output_patch(filename)
  character(LEN=80)::filename
  character(LEN=80)::fileloc
  character(LEN=30)::format
  integer::ilun

  ilun=11

  fileloc=TRIM(filename)
  format="(A)"
  open(unit=ilun,file=fileloc,form='formatted')
  write(ilun,format)"../patch/irradiation/test_pascucci/amr_step.f90"
  write(ilun,format)"recursive subroutine amr_step(ilevel,icount)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)""
  write(ilun,format)"  use cloud_module, only: rt_feedback,rt_protostar_m1,rt_protostar_fld"
  write(ilun,format)"  use feedback_module"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use coolrates_module, only: update_coolrates_tables"
  write(ilun,format)"  use rt_cooling_module, only: update_UVrates"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_TURB==1"
  write(ilun,format)"  use turb_commons"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::mpi_err"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel,icount"
  write(ilun,format)"  !-------------------------------------------------------------------!"
  write(ilun,format)"  ! This routine is the adaptive-mesh/adaptive-time-step main driver. !"
  write(ilun,format)"  ! Each routine is called using a specific order, don't change it,   !"
  write(ilun,format)"  ! unless you check all consequences first                           !"
  write(ilun,format)"  !-------------------------------------------------------------------!"
  write(ilun,format)"  integer::i,idim,ivar"
  write(ilun,format)"  logical::ok_defrag,output_now_all"
  write(ilun,format)"  logical,save::first_step=.true."
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  !!! sts !!!"
  write(ilun,format)"  real(kind=dp) :: dtminlocsts"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,999)icount,ilevel"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  call boundary_frig(ilevel)"
  write(ilun,format)"    "
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Make new refinements and update boundaries"
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"                               call timer('refine','start')"
  write(ilun,format)"  if(levelmin.lt.nlevelmax .and.(.not.static.or.(nstep_coarse_old.eq.nstep_coarse.and.restart_remap)))then"
  write(ilun,format)"     if(ilevel==levelmin.or.icount>1)then"
  write(ilun,format)"        do i=ilevel,nlevelmax"
  write(ilun,format)"           if(i>levelmin)then"
  write(ilun,format)""
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              ! Build communicators"
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              call build_comm(i)"
  write(ilun,format)""
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              ! Update boundaries"
  write(ilun,format)"              !--------------------------"
  write(ilun,format)"              call make_virtual_fine_int(cpu_map(1),i)"
  write(ilun,format)"              if(hydro)then"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"                 do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"                 do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"                    call make_virtual_fine_dp(uold(1,ivar),i)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"                 end do"
  write(ilun,format)"#else"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                 if(momentum_feedback)call make_virtual_fine_dp(pstarold(1),i)"
  write(ilun,format)"                 if(simple_boundary)call make_boundary_hydro(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"              if(rt)then"
  write(ilun,format)"                 do ivar=1,nrtvar"
  write(ilun,format)"                    call make_virtual_fine_dp(rtuold(1,ivar),i)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 if(simple_boundary)call rt_make_boundary_hydro(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"#endif"
  write(ilun,format)"              if(poisson)then"
  write(ilun,format)"                 call make_virtual_fine_dp(phi(1),i)"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    call make_virtual_fine_dp(f(1,idim),i)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 if(simple_boundary)call make_boundary_force(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           !--------------------------"
  write(ilun,format)"           ! Refine grids"
  write(ilun,format)"           !--------------------------"
  write(ilun,format)"           call refine_fine(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------"
  write(ilun,format)"  ! Load balance"
  write(ilun,format)"  !--------------------------"
  write(ilun,format)"                               call timer('load balance','start')"
  write(ilun,format)"  ok_defrag=.false."
  write(ilun,format)"  if(levelmin.lt.nlevelmax)then"
  write(ilun,format)"     if(ilevel==levelmin)then"
  write(ilun,format)"        if(nremap>0)then"
  write(ilun,format)"           ! Skip first load balance because it has been performed before file dump"
  write(ilun,format)"           if(nrestart>0.and.first_step)then"
  write(ilun,format)"              if(nrestart.eq.nrestart_quad) restart_remap=.true."
  write(ilun,format)"              if(restart_remap) then"
  write(ilun,format)"                 call load_balance"
  write(ilun,format)"                 call defrag"
  write(ilun,format)"                 ok_defrag=.true."
  write(ilun,format)"              endif"
  write(ilun,format)"              first_step=.false."
  write(ilun,format)"           else"
  write(ilun,format)"              if(MOD(nstep_coarse,nremap)==0)then"
  write(ilun,format)"                 call load_balance"
  write(ilun,format)"                 call defrag"
  write(ilun,format)"                 ok_defrag=.true."
  write(ilun,format)"              endif"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Update sink cloud particle properties"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"  if(sink)call update_cloud(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"  ! Particle leakage"
  write(ilun,format)"  !-----------------"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"  if(pic)call make_tree_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !------------------------"
  write(ilun,format)"  ! Output results to files"
  write(ilun,format)"  !------------------------"
  write(ilun,format)"  if(ilevel==levelmin)then"
  write(ilun,format)""
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"     output_now_all = output_now"
  write(ilun,format)"#else"
  write(ilun,format)"     ! check if any of the processes received a signal for output"
  write(ilun,format)"     call MPI_BARRIER(MPI_COMM_WORLD,mpi_err)"
  write(ilun,format)"     call MPI_ALLREDUCE(output_now,output_now_all,1,MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,mpi_err)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(mod(nstep_coarse,foutput)==0.or.aexp>=aout(iout).or.t>=tout(iout).or.output_now_all.EQV..true.)then"
  write(ilun,format)"                               call timer('io','start')"
  write(ilun,format)"        if(.not.ok_defrag)then"
  write(ilun,format)"           call defrag"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        call dump_all"
  write(ilun,format)""
  write(ilun,format)"        ! Run the clumpfinder, (produce output, don't keep arrays alive on output)"
  write(ilun,format)"        ! CAREFUL: create_output is used to destinguish between the case where"
  write(ilun,format)"        ! the clumpfinder is called from create_sink or directly from amr_step."
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"        if(clumpfind .and. ndim==3) call clump_finder(.true.,.false.)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        ! Dump lightcone"
  write(ilun,format)"        if(lightcone .and. ndim==3) call output_cone()"
  write(ilun,format)""
  write(ilun,format)"        if (output_now_all.EQV..true.) then"
  write(ilun,format)"          output_now=.false."
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     ! Important can't be done in sink routines because it must be done after dump all"
  write(ilun,format)"     if(sink)acc_rate=0."
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  ! Output frame to movie dump (without synced levels)"
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  if(movie) then"
  write(ilun,format)"     if(imov.le.imovout)then"
  write(ilun,format)"        if(aexp>=amovout(imov).or.t>=tmovout(imov))then"
  write(ilun,format)"                               call timer('movie','start')"
  write(ilun,format)"           call output_frame()"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  ! Put here all stuffs that are done only at coarse time step"
  write(ilun,format)"  !-----------------------------------------------------------"
  write(ilun,format)"  if(ilevel==levelmin)then"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     ! Kinetic feedback from giant molecular clouds"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"     if(hydro.and.star.and.eta_sn>0.and.f_w>0)call kinetic_feedback"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     ! Feedback on sink particles"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     if(stellar) then"
  write(ilun,format)"        if(make_stellar_glob) then"
  write(ilun,format)"           call make_stellar_from_sinks_glob"
  write(ilun,format)"        else"
  write(ilun,format)"           call make_stellar_from_sinks"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     if (sn_feedback_sink) then"
  write(ilun,format)"        call make_sn_stellar"
  write(ilun,format)"     endif"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     ! Feedback on fixed sources (winds, supernovae)"
  write(ilun,format)"     !----------------------------------------------------"
  write(ilun,format)"     if (FB_on) then"
  write(ilun,format)"        call feedback_fixed(ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------"
  write(ilun,format)"  ! Poisson source term"
  write(ilun,format)"  !--------------------"
  write(ilun,format)"  if(poisson)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)"     !save old potential for time-extrapolation at level boundaries"
  write(ilun,format)"     call save_phi_old(ilevel)"
  write(ilun,format)"                               call timer('rho','start')"
  write(ilun,format)"     call rho_fine(ilevel,icount)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Sort particles between ilevel and ilevel+1"
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  if(pic)then"
  write(ilun,format)"     ! Remove particles to finer levels"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"     call kill_tree_fine(ilevel)"
  write(ilun,format)"     ! Update boundary conditions for remaining particles"
  write(ilun,format)"     call virtual_tree_fine(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Gravity update"
  write(ilun,format)"  !---------------"
  write(ilun,format)"  if(poisson)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)""
  write(ilun,format)"     ! Remove gravity source term with half time step and old force"
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"        call synchro_hydro_fine(ilevel,-0.5*dtnew(ilevel),1)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Compute gravitational potential"
  write(ilun,format)"     if(ilevel>levelmin)then"
  write(ilun,format)"        if(ilevel .ge. cg_levelmin) then"
  write(ilun,format)"           call phi_fine_cg(ilevel,icount)"
  write(ilun,format)"        else"
  write(ilun,format)"           call multigrid_fine(ilevel,icount)"
  write(ilun,format)"        end if"
  write(ilun,format)"     else"
  write(ilun,format)"        call multigrid_fine(levelmin,icount)"
  write(ilun,format)"     end if"
  write(ilun,format)"     !when there is no old potential..."
  write(ilun,format)"     if (nstep==0)call save_phi_old(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Compute gravitational acceleration"
  write(ilun,format)"     call force_fine(ilevel,icount)"
  write(ilun,format)""
  write(ilun,format)"     ! Synchronize remaining particles for gravity"
  write(ilun,format)"     if(pic)then"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"        if(static_dm.or.static_stars)then"
  write(ilun,format)"           call synchro_fine_static(ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           call synchro_fine(ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)""
  write(ilun,format)"        ! Add gravity source term with half time step and new force"
  write(ilun,format)"        call synchro_hydro_fine(ilevel,+0.5*dtnew(ilevel),1)"
  write(ilun,format)""
  write(ilun,format)"        ! Update boundaries"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"        do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"           call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"        end do"
  write(ilun,format)"#else"
  write(ilun,format)"        end do"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"        ! Compute Bondi-Hoyle accretion parameters"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"        if(sink)call collect_acczone_avg(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  ! Turn on RT in case of rt_stars and first stars just created:"
  write(ilun,format)"  ! Update photon packages according to star particles"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"  if(rt .and. rt_star) call update_star_RT_feedback(ilevel)"
  write(ilun,format)"                               "
  write(ilun,format)"  ! Now update photon packages on sink particles"
  write(ilun,format)"  if(rt .and. rt_sink) call update_sink_RT_feedback(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  ! Compute radiative acceleration"
  write(ilun,format)"  if(fld)call rad_force_fine(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_TURB==1"
  write(ilun,format)"  ! Compute turbulent forcing"
  write(ilun,format)"                               call timer('turb','start')"
  write(ilun,format)"  if (turb .and. turb_type/=3) then"
  write(ilun,format)"     ! Calculate turbulent acceleration on each cell in this level"
  write(ilun,format)"     call calc_turb_forcing(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------"
  write(ilun,format)"  ! Compute new time step"
  write(ilun,format)"  !----------------------"
  write(ilun,format)"                               call timer('courant','start')"
  write(ilun,format)"  call newdt_fine(ilevel)"
  write(ilun,format)"  if(ilevel>levelmin)then"
  write(ilun,format)"     dtnew(ilevel)=MIN(dtnew(ilevel-1)/real(nsubcycle(ilevel-1)),dtnew(ilevel))"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"     ! modif nimhd"
  write(ilun,format)"     if((nmagdiffu2==0.and.nmagdiffu==1).or.&"
  write(ilun,format)"          &(nambipolar2==0.and.nambipolar==1))then"
  write(ilun,format)"        dtambdiff(ilevel)=MIN(dtambdiff(ilevel-1)/real(nsubcycle(ilevel-1)),dtambdiff(ilevel))"
  write(ilun,format)"        dtmagdiff(ilevel)=MIN(dtmagdiff(ilevel-1)/real(nsubcycle(ilevel-1)),dtmagdiff(ilevel))"
  write(ilun,format)"        dtwad(ilevel)=MIN(dtwad(ilevel-1)/real(nsubcycle(ilevel-1)),dtwad(ilevel))"
  write(ilun,format)"        dthall(ilevel)=MIN(dthall(ilevel-1)/real(nsubcycle(ilevel-1)),dthall(ilevel))"
  write(ilun,format)"     end if"
  write(ilun,format)"     ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  if((nmagdiffu2==1.and.nmagdiffu==0).or.&"
  write(ilun,format)"       &(nambipolar2==1.and.nambipolar==0))then"
  write(ilun,format)"     !  dtminlocsts=min(dtambdiff(ilevel),dtmagdiff(ilevel))"
  write(ilun,format)"     dtminlocsts=1.0d0/dtambdiff(ilevel)+1.0d0/dtmagdiff(ilevel)"
  write(ilun,format)"     dtminlocsts=1.0d0/dtminlocsts"
  write(ilun,format)"     nsts(ilevel)=min(100,floor(sqrt(dtnew(ilevel)/dtminlocsts))+1)"
  write(ilun,format)"     "
  write(ilun,format)"     if (nsts(ilevel) > 0) then "
  write(ilun,format)"!!      dtsts(ilevel)=(dtminlocsts*nsts(ilevel)**2 * &"
  write(ilun,format)"!!         & ( ((1.d0+1.d0/(2.d0*nsts(ilevel)))**(2*nsts(ilevel)) - (1.d0-1.d0/(2.d0*nsts(ilevel)))**(2*nsts(ilevel))) &"
  write(ilun,format)"!!         &  / ((1.d0+1.d0/(2.d0*nsts(ilevel)))**(2*nsts(ilevel)) + (1.d0-1.d0/(2.d0*nsts(ilevel)))**(2*nsts(ilevel)))  ) )"
  write(ilun,format)""
  write(ilun,format)"        dtsts(ilevel) = dtminlocsts*nsts(ilevel)/(2.*sqrt(nu_sts))*((1.+sqrt(nu_sts))**(2.*nsts(ilevel))-(1.-sqrt(nu_sts))**(2.*nsts(ilevel))) &         ! somme des dtsts, theorique"
  write(ilun,format)"             & /((1.+sqrt(nu_sts))**(2.*nsts(ilevel))+(1.-sqrt(nu_sts))**(2.*nsts(ilevel)))"
  write(ilun,format)"        "
  write(ilun,format)"        dtnew(ilevel)=min(dtnew(ilevel),dtsts(ilevel))"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew equal to uold"
  write(ilun,format)"                               call timer('hydro - set unew','start')"
  write(ilun,format)"  if(hydro)call set_unew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  ! Set rtunew equal to rtuold"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"  if(rt)call rt_set_unew(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  ! Recursive call to amr_step"
  write(ilun,format)"  !---------------------------"
  write(ilun,format)"  if(ilevel<nlevelmax)then"
  write(ilun,format)"     if(numbtot(1,ilevel+1)>0)then"
  write(ilun,format)"        if(nsubcycle(ilevel)==2)then"
  write(ilun,format)"           call amr_step(ilevel+1,1)"
  write(ilun,format)"           call amr_step(ilevel+1,2)"
  write(ilun,format)"        else"
  write(ilun,format)"           call amr_step(ilevel+1,1)"
  write(ilun,format)"        endif"
  write(ilun,format)"     else"
  write(ilun,format)"        ! Otherwise, update time and finer level time-step"
  write(ilun,format)"        dtold(ilevel+1)=dtnew(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"        ! modif nimhd"
  write(ilun,format)"        if((nmagdiffu2==0.and.nmagdiffu==1).or.&"
  write(ilun,format)"             &(nambipolar2==0.and.nambipolar==1))then"
  write(ilun,format)"           dtambdiffold(ilevel+1)=dtambdiff(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dtmagdiffold(ilevel+1)=dtmagdiff(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dtwadold(ilevel+1)=dtwad(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dthallold(ilevel+1)=dthall(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"        end if"
  write(ilun,format)"        ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"        dtnew(ilevel+1)=dtnew(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"        ! modif nimhd"
  write(ilun,format)"        if((nmagdiffu2==0.and.nmagdiffu==1).or.&"
  write(ilun,format)"             &(nambipolar2==0.and.nambipolar==1))then"
  write(ilun,format)"           dtambdiff(ilevel+1)=dtambdiff(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dtmagdiff(ilevel+1)=dtmagdiff(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dtwad(ilevel+1)=dtwad(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"           dthall(ilevel+1)=dthall(ilevel)/dble(nsubcycle(ilevel))"
  write(ilun,format)"        end if"
  write(ilun,format)"        ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"        call update_time(ilevel)"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"        if(sink)call update_sink(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end if"
  write(ilun,format)"  else"
  write(ilun,format)"     call update_time(ilevel)"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"     if(sink)call update_sink(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Thermal feedback from stars"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"  if(hydro.and.star.and.eta_sn>0)call thermal_feedback(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Density threshold or Bondi accretion onto sink particle"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  if(sink)then"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"     call grow_sink(ilevel,.false.)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"  !-----------"
  write(ilun,format)"  ! Hydro step"
  write(ilun,format)"  !-----------"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)""
  write(ilun,format)"     ! Hyperbolic solver"
  write(ilun,format)"                               call timer('hydro - godunov','start')"
  write(ilun,format)"     call godunov_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Reverse update boundaries"
  write(ilun,format)"                               call timer('hydro - rev ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_reverse_dp(unew(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(momentum_feedback)then"
  write(ilun,format)"        call make_virtual_reverse_dp(pstarnew(1),ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(pressure_fix)then"
  write(ilun,format)"        call make_virtual_reverse_dp(enew(1),ilevel)"
  write(ilun,format)"        call make_virtual_reverse_dp(divu(1),ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Set uold equal to unew"
  write(ilun,format)"                               call timer('hydro - set uold','start')"
  write(ilun,format)"     call set_uold(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Add gravity source term with half time step and old force"
  write(ilun,format)"     ! in order to complete the time step"
  write(ilun,format)"                               call timer('poisson','start')"
  write(ilun,format)"     if(poisson)call synchro_hydro_fine(ilevel,+0.5*dtnew(ilevel),1)"
  write(ilun,format)"     "
  write(ilun,format)"#if USE_TURB==1"
  write(ilun,format)"     ! Compute turbulent forcing"
  write(ilun,format)"                               call timer('turb','start')"
  write(ilun,format)"     if (turb .AND. turb_type/=3) then"
  write(ilun,format)"        ! Euler step, adding turbulent acceleration"
  write(ilun,format)"        call synchro_hydro_fine(ilevel,dtnew(ilevel),2)"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ! Restriction operator"
  write(ilun,format)"                               call timer('hydro upload fine','start')"
  write(ilun,format)"     call upload_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------------"
  write(ilun,format)"  ! Do RT/Chemistry step"
  write(ilun,format)"  !---------------------"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  if(rt .and. rt_advect) then"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     call rt_step(ilevel)"
  write(ilun,format)"  else"
  write(ilun,format)"     ! Still need a chemistry call if RT is defined but not"
  write(ilun,format)"     ! actually doing radiative transfer (i.e. rt==false):"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! Regular updates and book-keeping:"
  write(ilun,format)"  if(ilevel==levelmin) then"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     if(cosmo) call update_rt_c"
  write(ilun,format)"     if(cosmo .and. haardt_madau) call update_UVrates(aexp)"
  write(ilun,format)"     if(cosmo .and. rt_isDiffuseUVsrc) call update_UVsrc"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(cosmo) call update_coolrates_tables(dble(aexp))"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     if(ilevel==levelmin) call output_rt_stats"
  write(ilun,format)"  endif"
  write(ilun,format)"#else"
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"  if((hydro).and.(.not.static_gas)) then"
  write(ilun,format)"        if((neq_chem.or.cooling .or. barotrop .or. extinction .or. isothermal) .and. T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"        ! Romain master version"
  write(ilun,format)"        ! if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Move particles"
  write(ilun,format)"  !---------------"
  write(ilun,format)"  if(pic)then"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"     if(static_dm.or.static_stars)then"
  write(ilun,format)"        call move_fine_static(ilevel) ! Only remaining particles"
  write(ilun,format)"     else"
  write(ilun,format)"        call move_fine(ilevel) ! Only remaining particles"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------"
  write(ilun,format)"  ! Star formation in leaf cells only"
  write(ilun,format)"  !----------------------------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"                               call timer('feedback','start')"
  write(ilun,format)"  if(hydro.and.star.and.(.not.static_gas))call star_formation(ilevel)"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  ! Compute radiative feedback if radiative transfer with FLD on"
  write(ilun,format)"  if(FLD)then"
  write(ilun,format)"     if(rt_feedback .and. sink .and. nsink .gt. 0 .and. .not.rt_protostar_m1)call radiative_feedback_sink(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if (rt_protostar_fld)call add_radiation_sources(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------------------"
  write(ilun,format)"  ! Update physical and virtual boundaries"
  write(ilun,format)"  !---------------------------------------"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)"                               call timer('hydro - ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(momentum_feedback)call make_virtual_fine_dp(pstarold(1),ilevel)"
  write(ilun,format)"     if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  ! Magnetic diffusion step"
  write(ilun,format)"  if((hydro).and.(.not.static_gas))then"
  write(ilun,format)"     if(eta_mag>0d0.and.ilevel==levelmin)then"
  write(ilun,format)"                               call timer('mhd - diffusion','start')"
  write(ilun,format)"        call diffusion"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  ! STS for magnetic diffusion effects"
  write(ilun,format)"  if(((nmagdiffu2==1.and.nmagdiffu==0).or.&"
  write(ilun,format)"    &(nambipolar2==1.and.nambipolar==0)) .and. (.not.DTU))then"
  write(ilun,format)"                               call timer('nimhd - diffusion_sts','start')"
  write(ilun,format)"     call diffusion_sts(ilevel,icount)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if((static_gas).and.(cr_diffusion .or. FLD))then"
  write(ilun,format)"     call upload_fine(ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"           call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"  end if"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  ! Cosmic ray diffusion step"
  write(ilun,format)"  if(cr_diffusion)then"
  write(ilun,format)"                               call timer('Cosmic rays diffusion','start')"
  write(ilun,format)"     call crdiffusion_cg(ilevel,icount)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1  "
  write(ilun,format)"  ! Radiation diffusion step"
  write(ilun,format)"  if(FLD)then"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)"     call diffusion_cg(ilevel,icount)"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  call boundary_frig(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  ! Update boundaries "
  write(ilun,format)"                               call timer('hydro - ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  ! Magnetic diffusion step"
  write(ilun,format)" if(hydro)then"
  write(ilun,format)"  if(((nmagdiffu2==1.and.nmagdiffu==0).or.&"
  write(ilun,format)"    &(nambipolar2==1.and.nambipolar==0)) .and.&"
  write(ilun,format)"    &ilevel==levelmin .and. DTU)then"
  write(ilun,format)"                               call timer('nimhd - diffusion_sts_dtu','start')"
  write(ilun,format)"        call diffusion_sts_dtu"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Update boundaries "
  write(ilun,format)"                               call timer('hydro - ghostzones','start')"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     end do"
  write(ilun,format)"#else"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------"
  write(ilun,format)"  ! Compute refinement map"
  write(ilun,format)"  !-----------------------"
  write(ilun,format)"                               call timer('flag','start')"
  write(ilun,format)"  if(.not.static.or.(nstep_coarse_old.eq.nstep_coarse.and.restart_remap)) call flag_fine(ilevel,icount)"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"  ! Merge finer level particles"
  write(ilun,format)"  !----------------------------"
  write(ilun,format)"                               call timer('particles','start')"
  write(ilun,format)"  if(pic)call merge_tree_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !---------------"
  write(ilun,format)"  ! Radiation step"
  write(ilun,format)"  !---------------"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"  if(aton.and.ilevel==levelmin)then"
  write(ilun,format)"                               call timer('aton','start')"
  write(ilun,format)"     call rad_step(dtnew(ilevel))"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(sink)then"
  write(ilun,format)"                               call timer('sinks','start')"
  write(ilun,format)"     !-------------------------------"
  write(ilun,format)"     ! Update coarser level sink velocity"
  write(ilun,format)"     !-------------------------------"
  write(ilun,format)"     if(ilevel>levelmin)then"
  write(ilun,format)"        vsold(1:nsink,1:ndim,ilevel-1)=vsnew(1:nsink,1:ndim,ilevel-1)"
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)vsnew(1:nsink,1:ndim,ilevel-1)=vsnew(1:nsink,1:ndim,ilevel)"
  write(ilun,format)"        if(icount==2)vsnew(1:nsink,1:ndim,ilevel-1)= &"
  write(ilun,format)"             (vsold(1:nsink,1:ndim,ilevel)*dtold(ilevel)+vsnew(1:nsink,1:ndim,ilevel)*dtnew(ilevel))/ &"
  write(ilun,format)"             (dtold(ilevel)+dtnew(ilevel))"
  write(ilun,format)"     end if"
  write(ilun,format)"     !---------------"
  write(ilun,format)"     ! Sink production"
  write(ilun,format)"     !---------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"     if(ilevel==levelmin)call create_sink"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------"
  write(ilun,format)"  ! Update coarser level time-step"
  write(ilun,format)"  !-------------------------------"
  write(ilun,format)"  if(ilevel>levelmin)then"
  write(ilun,format)"     if(nsubcycle(ilevel-1)==1)dtnew(ilevel-1)=dtnew(ilevel)"
  write(ilun,format)"     if(icount==2)dtnew(ilevel-1)=dtold(ilevel)+dtnew(ilevel)"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"    ! modif nimhd"
  write(ilun,format)"     if((nmagdiffu2==0.and.nmagdiffu==1).or.&"
  write(ilun,format)"          &(nambipolar2==0.and.nambipolar==1))then"
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)dtambdiff(ilevel-1)=dtambdiff(ilevel)"
  write(ilun,format)"        !if((icount==2) .and. (nambipolar2 == 0) ) dtambdiff(ilevel-1)=dtambdiffold(ilevel)+dtambdiff(ilevel)"
  write(ilun,format)"        !if ((icount==2) .and. (nambipolar2 == 1)) dtambdiff(ilevel-1)=dtambdiff(ilevel)"
  write(ilun,format)"        if (icount==2) dtambdiff(ilevel-1)=dtambdiffold(ilevel)+dtambdiff(ilevel)"
  write(ilun,format)"        "
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)dtmagdiff(ilevel-1)=dtmagdiff(ilevel)"
  write(ilun,format)"        !     if  ((icount==2) .and. (nmagdiffu2 == 0)) dtmagdiff(ilevel-1)=dtmagdiffold(ilevel)+dtmagdiff(ilevel)"
  write(ilun,format)"        !     if ((icount==2) .and. (nmagdiffu2 == 1)) dtmagdiff(ilevel-1)=dtmagdiff(ilevel)"
  write(ilun,format)"        if  (icount==2) dtmagdiff(ilevel-1)=dtmagdiffold(ilevel)+dtmagdiff(ilevel)"
  write(ilun,format)"        "
  write(ilun,format)"        "
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)dtwad(ilevel-1)=dtwad(ilevel)"
  write(ilun,format)"        if(icount==2)dtwad(ilevel-1)=dtwadold(ilevel)+dtwad(ilevel)"
  write(ilun,format)"        "
  write(ilun,format)"        if(nsubcycle(ilevel-1)==1)dthall(ilevel-1)=dthall(ilevel)"
  write(ilun,format)"        if(icount==2)dthall(ilevel-1)=dthallold(ilevel)+dthall(ilevel)"
  write(ilun,format)"     end if"
  write(ilun,format)"     ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"999 format(' Entering amr_step',i1,' for level',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine amr_step"
  write(ilun,format)""
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)"!##########################################################################"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"subroutine rt_step(ilevel)"
  write(ilun,format)"  use amr_parameters, only: dp"
  write(ilun,format)"  use amr_commons,    only: levelmin, t, dtnew, myid"
  write(ilun,format)"  use cloud_module,   only: rt_protostar_m1"
  write(ilun,format)"  use rt_cooling_module, only: update_UVrates"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use SED_module,     only: star_RT_feedback"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer, intent(in) :: ilevel"
  write(ilun,format)""
  write(ilun,format)"!--------------------------------------------------------------------------"
  write(ilun,format)"!  Radiative transfer and chemistry step. Either do one step on ilevel,"
  write(ilun,format)"!  with radiation field updates in coarser level neighbours, or, if"
  write(ilun,format)"!  rt_nsubsteps>1, do many substeps in ilevel only, using Dirichlet"
  write(ilun,format)"!  boundary conditions for the level boundaries."
  write(ilun,format)"!--------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp) :: dt_hydro, t_left, dt_rt, t_save"
  write(ilun,format)"  integer  :: i_substep, ivar"
  write(ilun,format)""
  write(ilun,format)"  dt_hydro = dtnew(ilevel)                   ! Store hydro timestep length"
  write(ilun,format)"  t_left = dt_hydro  "
  write(ilun,format)"  ! We shift the time backwards one hydro-dt, to get evolution of stellar"
  write(ilun,format)"  ! ages within the hydro timestep, in the case of rt subcycling:"
  write(ilun,format)"  t_save=t ; t=t-t_left"
  write(ilun,format)""
  write(ilun,format)"  i_substep = 0"
  write(ilun,format)"  do while (t_left > 0)                      !                RT sub-cycle"
  write(ilun,format)"     i_substep = i_substep + 1"
  write(ilun,format)"     call get_rt_courant_coarse(dt_rt)"
  write(ilun,format)"     ! Temporarily change timestep length to rt step:"
  write(ilun,format)"     dtnew(ilevel) = MIN(t_left, dt_rt/2.0**(ilevel-levelmin))"
  write(ilun,format)"     t = t + dtnew(ilevel) ! Shift the time forwards one dt_rt"
  write(ilun,format)""
  write(ilun,format)"     ! If (myid==1) write(*,900) dt_hydro, dtnew(ilevel), i_substep, ilevel"
  write(ilun,format)"     if (i_substep > 1) call rt_set_unew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     if(rt_star) call star_RT_feedback(ilevel,dtnew(ilevel))"
  write(ilun,format)"     if(rt_sink) call sink_RT_feedback(ilevel,dtnew(ilevel))"
  write(ilun,format)"     if(rt_protostar_m1 .and. sink) call radiative_feedback_sink(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     ! Hyperbolic solver"
  write(ilun,format)"     if(rt_advect) call rt_godunov_fine(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     call add_rt_sources(ilevel,dtnew(ilevel))"
  write(ilun,format)""
  write(ilun,format)"     ! Reverse update boundaries"
  write(ilun,format)"     do ivar=1,nrtvar"
  write(ilun,format)"        call make_virtual_reverse_dp(rtunew(1,ivar),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Set rtuold equal to rtunew"
  write(ilun,format)"     call rt_set_uold(ilevel)"
  write(ilun,format)""
  write(ilun,format)"                               call timer('cooling','start')"
  write(ilun,format)"     if(neq_chem.or.cooling.or.T2_star>0.0)call cooling_fine(ilevel)"
  write(ilun,format)"                               call timer('radiative transfer','start')"
  write(ilun,format)""
  write(ilun,format)"     do ivar=1,nrtvar"
  write(ilun,format)"        call make_virtual_fine_dp(rtuold(1,ivar),ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if(simple_boundary)call rt_make_boundary_hydro(ilevel)"
  write(ilun,format)""
  write(ilun,format)"     t_left = t_left - dtnew(ilevel)"
  write(ilun,format)"  end do                                   !          End RT subcycle loop"
  write(ilun,format)"  dtnew(ilevel) = dt_hydro                 ! Restore hydro timestep length"
  write(ilun,format)"  t = t_save       ! Restore original time (otherwise tiny roundoff error)"
  write(ilun,format)""
  write(ilun,format)"  ! Restriction operator to update coarser level split cells"
  write(ilun,format)"  call rt_upload_fine(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. rt_nsubcycle .gt. 1) write(*,901) ilevel, i_substep"
  write(ilun,format)""
  write(ilun,format)"  !900 format (' dt_hydro=', 1pe12.3, ' dt_rt=', 1pe12.3, ' i_sub=', I5, ' level=', I5)"
  write(ilun,format)"901 format (' Performed level', I3, ' RT-step with ', I5, ' subcycles')"
  write(ilun,format)""
  write(ilun,format)"end subroutine rt_step"
  write(ilun,format)"#endif"
  write(ilun,format)"../patch/irradiation/test_pascucci/condinit.f90"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine condinit(x,u,dx,nn)"
  write(ilun,format)"  use amr_commons,only:myid"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::nn                              ! Number of cells"
  write(ilun,format)"  real(dp)::dx                              ! Cell size"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3)::u ! Conservative variables"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x   ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine generates initial conditions for RAMSES."
  write(ilun,format)"  ! Positions are in user units:"
  write(ilun,format)"  ! x(i,1:3) are in [0,boxlen]**ndim."
  write(ilun,format)"  ! U is the conservative variable vector. Conventions are here:"
  write(ilun,format)"  ! U(i,1): d, U(i,2:3): d.u,d.v, U(i,4): E, U(i,5:7): Bleft, "
  write(ilun,format)"  ! U(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! Q is the primitive variable vector. Conventions are here:"
  write(ilun,format)"  ! Q(i,1): d, Q(i,2:3):u,v, Q(i,4): P, Q(i,5:7): Bleft, "
  write(ilun,format)"  ! Q(i,nvar+1:nvar+3): Bright"
  write(ilun,format)"  ! If nvar > 7, remaining variables (8:nvar) are treated as passive"
  write(ilun,format)"  ! scalars in the hydro solver."
  write(ilun,format)"  ! U(:,:) and Q(:,:) are in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::ivar"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::q   ! Primitive variables"
  write(ilun,format)"  real(dp):: x0,y0,rc,rs,xx,yy,rd,radiation_source"
  write(ilun,format)"  integer :: i"
  write(ilun,format)"  real(dp)::Temp,rho0,h,rho,ee,pi"
  write(ilun,format)"  real(dp)::rosseland_ana,planck_ana"
  write(ilun,format)"  real(dp)::au ! innner disc radius"
  write(ilun,format)"  real(dp)::zd"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  real(dp)::z0,zz"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Call built-in initial condition generator"
  write(ilun,format)"  call region_condinit(x,q,dx,nn)"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"  ! ........"
  write(ilun,format)"  if (test=='pascucci') then"
  write(ilun,format)"     boxlen = 2000.0d0"
  write(ilun,format)"  else if (test=='pinte') then"
  write(ilun,format)"     boxlen = 800.0d0"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  x0=0.5*boxlen"
  write(ilun,format)"  y0=0.5*boxlen"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  z0=0.5*boxlen"
  write(ilun,format)"#endif"
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  ! AU in code units"
  write(ilun,format)"  au = 1.496e13/scale_l"
  write(ilun,format)""
  write(ilun,format)"  if (test=='pascucci') then"
  write(ilun,format)"     !boxlen = 2000 for pascucci/kuiper (namelist)                                                                    "
  write(ilun,format)"     rd  = 500.* au ! boxlen/4=500AU"
  write(ilun,format)"     zd  = 125.* au ! boxlen/16=125AU"
  write(ilun,format)"     rin = 1. * au"
  write(ilun,format)"  else if (test=='pinte') then"
  write(ilun,format)"     rd  = 100.* au ! boxlen/8=100AU"
  write(ilun,format)"     zd  = 10.* au ! boxlen/80=10AU"
  write(ilun,format)"     rin = 0.1 * au"
  write(ilun,format)"     if (Tstar >14999.0d0) then"
  write(ilun,format)"        rin = 1.0 * au ! for T(disk)<T(sublimation)"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  rho0=rho_disk0/scale_d !2.874d-18/scale_d!8.321d-18/scale_d"
  write(ilun,format)"  "
  write(ilun,format)"  Temp=Tr_floor"
  write(ilun,format)""
  write(ilun,format)"  q=0.0d0"
  write(ilun,format)"  "
  write(ilun,format)"  dO i=1,nn"
  write(ilun,format)"     xx=x(i,1)-x0"
  write(ilun,format)"     yy=x(i,2)-y0"
  write(ilun,format)"     zz=x(i,3)-z0"
  write(ilun,format)"     "
  write(ilun,format)"     q(i,2) = 0.0d0"
  write(ilun,format)"     q(i,3) = 0.0d0"
  write(ilun,format)"     q(i,4) = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"     ! In 2D or 3D, rs is a cylindrical radius"
  write(ilun,format)"     rs  = abs(xx)"
  write(ilun,format)"     h   = zd*(rs/rd)**1.125"
  write(ilun,format)"     if (test=='pascucci') then"
  write(ilun,format)"        rho = rho0*((rs/rd)**(-1.0d0))*exp(-pi/4.0d0*(yy/h)**2)"
  write(ilun,format)"     else if (test=='pinte') then"
  write(ilun,format)"        rho = rho0*((rs/rd)**(-2.625d0))*exp(-0.5d0*(yy/h)**2)"
  write(ilun,format)"     endif"
  write(ilun,format)"#if NDIM>2  "
  write(ilun,format)"     rs  = sqrt(xx**2+yy**2)"
  write(ilun,format)"     h   = zd*(rs/rd)**1.125"
  write(ilun,format)"#endif"
  write(ilun,format)"     if (test=='pascucci') then"
  write(ilun,format)"        rho = rho0*((rs/rd)**(-1.0d0))*exp(-pi/4.0d0*(zz/h)**2)"
  write(ilun,format)"     else if (test=='pinte') then"
  write(ilun,format)"        rho = rho0*((rs/rd)**(-2.625d0))*exp(-0.5d0*(zz/h)**2)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! truncated disc below rin"
  write(ilun,format)"     if (rs .lt. rin) then"
  write(ilun,format)"        rho = smallr"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !rho=max(rho,smallr)"
  write(ilun,format)"     rho=max(rho,1.0d-3)"
  write(ilun,format)""
  write(ilun,format)"     !smoothing for truncation ?"
  write(ilun,format)"     !   if (rs .lt. 1.0d0) then"
  write(ilun,format)"     !      rho = 6.25*10**10*rho0*((rs/rd)**(3.0d0))"
  write(ilun,format)"     !   endif"
  write(ilun,format)""
  write(ilun,format)"     temp=tr_floor"
  write(ilun,format)""
  write(ilun,format)"     q(i,1)    = rho"
  write(ilun,format)"     call enerint_eos(q(i,1),Temp,ee)"
  write(ilun,format)"     q(i,5   ) = ee"
  write(ilun,format)"     q(i,nvar) = ee"
  write(ilun,format)""
  write(ilun,format)"     do ivar=1,ngrp"
  write(ilun,format)"        if (ivar==1 .and. stellar_photon) then"
  write(ilun,format)"           q(i,firstindex_er+ivar) = eray_min/(scale_d*scale_v**2)"
  write(ilun,format)"        else"
  write(ilun,format)"           q(i,firstindex_er+ivar) = max(radiation_source(Temp,ivar)/(scale_d*scale_v**2),eray_min/(scale_d*scale_v**2))"
  write(ilun,format)"        endif"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  ! Convert primitive to conservative variables"
  write(ilun,format)"  ! density -> density"
  write(ilun,format)"  u(1:nn,1)=q(1:nn,1)"
  write(ilun,format)"  ! velocity -> momentum"
  write(ilun,format)"  u(1:nn,2)=q(1:nn,1)*q(1:nn,2)"
  write(ilun,format)"  u(1:nn,3)=q(1:nn,1)*q(1:nn,3)"
  write(ilun,format)"  u(1:nn,4)=q(1:nn,1)*q(1:nn,4)"
  write(ilun,format)"  ! kinetic energy"
  write(ilun,format)"  u(1:nn,5)=0.0d0"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,2)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,3)**2"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+0.5*q(1:nn,1)*q(1:nn,4)**2"
  write(ilun,format)"  ! pressure -> total fluid energy"
  write(ilun,format)"  u(1:nn,5)=u(1:nn,5)+q(1:nn,5)"
  write(ilun,format)"  ! magnetic energy -> total fluid energy"
  write(ilun,format)"!  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,6)+q(1:nn,nvar+1))**2"
  write(ilun,format)"!  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,7)+q(1:nn,nvar+2))**2"
  write(ilun,format)"!  u(1:nn,5)=u(1:nn,5)+0.125d0*(q(1:nn,8)+q(1:nn,nvar+3))**2"
  write(ilun,format)"!  u(1:nn,6:8)=q(1:nn,6:8)"
  write(ilun,format)"!  u(1:nn,nvar+1:nvar+3)=q(1:nn,nvar+1:nvar+3)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  ! non-thermal pressure -> non-thermal energy"
  write(ilun,format)"  ! non-thermal energy   -> total fluid energy"
  write(ilun,format)"  do ivar=1,nener-ngrp"
  write(ilun,format)"     u(1:nn,8+ivar)=q(1:nn,8+ivar)/(gamma_rad(ivar)-1.0d0)"
  write(ilun,format)"     u(1:nn,5)=u(1:nn,5)+u(1:nn,8+ivar)"
  write(ilun,format)"  enddo"
  write(ilun,format)" ! Radiative transfer"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"  ! radiative energy   -> total fluid energy"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     u(1:nn,firstindex_er+ivar)= q(1:nn,firstindex_er+ivar)"
  write(ilun,format)"     u(1:nn,5)=u(1:nn,5)+ u(1:nn,firstindex_er+ivar)"
  write(ilun,format)"  enddo"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  ! radiative flux"
  write(ilun,format)"  do ivar=1,ndim*ngrp"
  write(ilun,format)"     do i=1,ncache"
  write(ilun,format)"        u(1:nn,fisrtindex_fr+ivar)=q(1:nn,firstindex+ivar)"
  write(ilun,format)"     end do"
  write(ilun,format)"     write(ilun)xdp"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NEXTINCT>0"
  write(ilun,format)"  ! Extinction"
  write(ilun,format)"  if(extinction)u(1:nn,firstindex_extinct+nextinct)=1.0D0"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NPSCAL>0"
  write(ilun,format)"  ! passive scalars"
  write(ilun,format)"  do ivar=1,npscal"
  write(ilun,format)"     u(1:nn,firstindex_pscal+ivar)=q(1:nn,1)*q(1:nn,firstindex_pscal+ivar)"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! Internal energy"
  write(ilun,format)"  u(1:nn,nvar)=q(1:nn,5)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine condinit"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine velana(x,v,dx,t,ncell)"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters  "
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ncell                         ! Size of input arrays"
  write(ilun,format)"  real(dp)::dx                            ! Cell size"
  write(ilun,format)"  real(dp)::t                             ! Current time"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:3)::v    ! Velocity field"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x ! Cell center position."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! This routine computes the user defined velocity fields."
  write(ilun,format)"  ! x(i,1:ndim) are cell center position in [0,boxlen] (user units)."
  write(ilun,format)"  ! v(i,1:3) is the imposed 3-velocity in user units."
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  integer::i"
  write(ilun,format)"  real(dp)::xx,yy,zz,vx,vy,vz,rr,tt,omega,aa,twopi"
  write(ilun,format)""
  write(ilun,format)"  ! Add here, if you wish, some user-defined initial conditions"
  write(ilun,format)"  aa=1.0"
  write(ilun,format)"  twopi=2d0*ACOS(-1d0)"
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)""
  write(ilun,format)"!!      xx=x(i,1)"
  write(ilun,format)"!! #if NDIM > 1"
  write(ilun,format)"!!      yy=x(i,2)"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!! #if NDIM > 2"
  write(ilun,format)"!!      zz=x(i,3)"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!      ! ABC"
  write(ilun,format)"!!      vx=aa*(cos(twopi*yy)+sin(twopi*zz))"
  write(ilun,format)"!!      vy=aa*(sin(twopi*xx)+cos(twopi*zz))"
  write(ilun,format)"!!      vz=aa*(cos(twopi*xx)+sin(twopi*yy))"
  write(ilun,format)""
  write(ilun,format)"!!      ! 1D advection test"
  write(ilun,format)"!!      vx=1.0_dp"
  write(ilun,format)"!!      vy=0.0_dp"
  write(ilun,format)"!!      vz=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"!!      ! Ponomarenko"
  write(ilun,format)"!!      xx=xx-boxlen/2.0"
  write(ilun,format)"!!      yy=yy-boxlen/2.0"
  write(ilun,format)"!!      rr=sqrt(xx**2+yy**2)"
  write(ilun,format)"!!      if(yy>0)then"
  write(ilun,format)"!!         tt=acos(xx/rr)"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         tt=-acos(xx/rr)+twopi"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      if(rr<1.0)then"
  write(ilun,format)"!!         omega=0.609711"
  write(ilun,format)"!!         vz=0.792624"
  write(ilun,format)"!!      else"
  write(ilun,format)"!!         omega=0.0"
  write(ilun,format)"!!         vz=0.0"
  write(ilun,format)"!!      endif"
  write(ilun,format)"!!      vx=-sin(tt)*rr*omega"
  write(ilun,format)"!!      vy=+cos(tt)*rr*omega"
  write(ilun,format)"     "
  write(ilun,format)"!!      v(i,1)=vx"
  write(ilun,format)"!! #if NDIM > 1"
  write(ilun,format)"!!      v(i,2)=vy"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!! #if NDIM > 2"
  write(ilun,format)"!!      v(i,3)=vz"
  write(ilun,format)"!! #endif"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine velana"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"!================================================================"
  write(ilun,format)"subroutine calc_boxlen"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine calc_boxlen"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE add_radiation_sources(ilevel,dt)"
  write(ilun,format)""
  write(ilun,format)"! Inject radiation from RT source regions (from the RT namelist). Since"
  write(ilun,format)"! the light sources are continuously emitting radiation, this is called"
  write(ilun,format)"! continuously during code execution, rather than just during"
  write(ilun,format)"! initialization."
  write(ilun,format)"!"
  write(ilun,format)"! ilevel => amr level at which to inject the radiation"
  write(ilun,format)"! dt     => timestep for injection (since injected values are per time)"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters, ONLY :rt_nsource,rt_source_type,rt_src_x_center,rt_src_y_center &"
  write(ilun,format)"       &,rt_src_length_x,rt_src_length_y,rt_src_start,rt_src_end,rt_exp_source,rt_src_group,rt_n_source "
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use hydro_parameters, ONLY : firstindex_er"
  write(ilun,format)"!  use rt_hydro_commons"
  write(ilun,format)"  use hydro_commons, ONLY: nvar,uold"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  real(dp)::dt"
  write(ilun,format)"  integer::i,igrid,ncache,iskip,ngrid"
  write(ilun,format)"  integer::ind,idim,ivar,ix,iy,iz,nx_loc"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ngrp),save::uu"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  call add_UV_background(ilevel)"
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return    ! no grids at this level"
  write(ilun,format)"  if(rt_nsource .le. 0) return      ! no rt sources"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  ! dx (and dx_loc=dx) are just equal to 1/nx (where 1 is the boxlength)"
  write(ilun,format)"  ! Loop over grids by vector sweeps"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        ! Gather cell indices"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Gather cell centre positions"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Rescale position from code units to user units"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=(xx(i,idim)-skip_loc(idim))!*scale"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Read the RT variables"
  write(ilun,format)"        do ivar=1,ngrp"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              uu(i,ivar)=uold(ind_cell(i),firstindex_er+ivar)"
  write(ilun,format)"              uold(ind_cell(i),5) = uold(ind_cell(i),5) - uold(ind_cell(i),firstindex_er+ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! find injected values per cell"
  write(ilun,format)"        call radiation_sources_vsweep(xx,uu,dx,dt,ngrid)"
  write(ilun,format)"        ! Write the RT variables"
  write(ilun,format)"        do ivar=1,ngrp"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              uold(ind_cell(i),firstindex_er+ivar)=uu(i,ivar)"
  write(ilun,format)"              uold(ind_cell(i),5) = uold(ind_cell(i),5) + uold(ind_cell(i),firstindex_er+ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering add_rt_sources for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE add_radiation_sources"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE radiation_sources_vsweep(x,uu,dx,dt,nn)"
  write(ilun,format)""
  write(ilun,format)"! Do a vector sweep, injecting RT source regions into cells, that is if"
  write(ilun,format)"! they are in any of these regions."
  write(ilun,format)"!"
  write(ilun,format)"! x      =>  ncells*ndim: positions of grid cells"
  write(ilun,format)"! uu    <=  ncells*nrtvars: injected rt variables in each cell"
  write(ilun,format)"! dx     =>  real cell width in code units"
  write(ilun,format)"! dt     =>  real timestep length in code units"
  write(ilun,format)"! nn     =>  int number of cells"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters, ONLY :rt_nsource,rt_source_type,rt_src_x_center,rt_src_y_center,rt_src_z_center &"
  write(ilun,format)"       &,rt_src_length_x,rt_src_length_y,rt_src_length_z,rt_src_start,rt_src_end,rt_exp_source,rt_src_group,rt_n_source"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use hydro_commons, ONLY: nvar,uold"
  write(ilun,format)"  use cooling_module,only: clight"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  integer ::nn"
  write(ilun,format)"  real(dp)::dx,dt!,dx_cgs,dt_cgs"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ngrp)::uu"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x"
  write(ilun,format)"  integer::i,k,group_ind"
  write(ilun,format)"  real(dp)::vol,r,xn,yn,zn,en,pi"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::scale_np,scale_fp"
  write(ilun,format)"  real(dp)::radiation_source,lum_group,lum_star,rstar_adim"
  write(ilun,format)"  integer:: igrp"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_cell"
  write(ilun,format)""
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)" ! Initialize everything to zero"
  write(ilun,format)"  !  uu=0.0d0"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  call rt_units(scale_np, scale_fp)"
  write(ilun,format)"  !dx_cgs=dx*scale_l"
  write(ilun,format)"  !dt_cgs=dt*scale_t"
  write(ilun,format)"  rstar_adim = rstar*6.96d10 / scale_l"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  lum_star=(5.67d-5*(Tstar**4))*4.0d0*3.1415d0*(rstar_adim)**2/(scale_d*(scale_v)**3)/(2.d0*Rin)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  lum_star=(5.67d-5*(Tstar**4))*4.0d0*3.1415d0*(rstar_adim)**2/(scale_d*(scale_v)**3)"
  write(ilun,format)"#endif"
  write(ilun,format)"!  write(*,*) 'lumstar=',lum_star, Tstar,rstar,rstar_adim"
  write(ilun,format)"  ! Loop over RT regions"
  write(ilun,format)"  do k=1,rt_nsource"
  write(ilun,format)""
  write(ilun,format)"     !if ((t-rt_src_start(k)) .lt. 0.) cycle"
  write(ilun,format)"     !if(((t-rt_src_end(k)) .gt. 0.) .and. (rt_src_end(k) .gt. 0.)) cycle"
  write(ilun,format)"     ! For 'square' regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'square')then"
  write(ilun,format)"       ! Exponent of choosen norm"
  write(ilun,format)"        en=rt_exp_source(k)"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           ! Compute position in normalized coordinates"
  write(ilun,format)"           xn=0.0d0; yn=0.0d0; zn=0.0d0"
  write(ilun,format)"           xn=2.0d0*abs(x(i,1)-rt_src_x_center(k))/rt_src_length_x(k)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=2.0d0*abs(x(i,2)-rt_src_y_center(k))/rt_src_length_y(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=2.0d0*abs(x(i,3)-rt_src_z_center(k))/rt_src_length_z(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"           ! Compute cell 'radius' relative to region center"
  write(ilun,format)"           if(rt_exp_source(k)<10)then"
  write(ilun,format)"              r=(xn**en+yn**en+zn**en)**(1.0/en)"
  write(ilun,format)"           else"
  write(ilun,format)"              r=max(xn,yn,zn)"
  write(ilun,format)"           end if"
  write(ilun,format)"           ! If cell lies within region, inject value"
  write(ilun,format)"           if(r<1.0)then"
  write(ilun,format)"!              uu(i,group_ind) = rt_n_source(k)/rt_c_cgs/scale_Np"
  write(ilun,format)"              ! The input flux is the fraction Fp/(c*Np) (Max 1 magnitude)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! For 'point' regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'point')then"
  write(ilun,format)"        ! Volume elements"
  write(ilun,format)"        vol=dx**ndim!dx_cgs**ndim !to convert into code units"
  write(ilun,format)"        ! Compute CIC weights relative to region center"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           xn=1.0; yn=1.0; zn=1.0"
  write(ilun,format)"           xn=max(1.0-abs(x(i,1)-rt_src_x_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=max(1.0-abs(x(i,2)-rt_src_y_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=max(1.0-abs(x(i,3)-rt_src_z_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"           r=xn*yn*zn"
  write(ilun,format)"           if(r .gt. 0.) then"
  write(ilun,format)"              ! If cell lies within CIC cloud, inject value."
  write(ilun,format)"              !weight = 1.0d0 !careful with energy injection normalization"
  write(ilun,format)"              if(stellar_photon)then"
  write(ilun,format)"                 igrp=1    ! Put all stellar radiative flux in the first group                      "
  write(ilun,format)"                 uu(i,igrp) = uu(i,igrp) + lum_star*r/vol*dt"
  write(ilun,format)"                 !uold(ind_cell(i),5     )=uold(ind_cell(i),5     ) + lum_star*r/vol*dtnew(ilevel)!/((4.0d0*pi*rmax**3)/3.0d0) !if weight=1.   "
  write(ilun,format)"                 !uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + lum_star*r/vol*dtnew(ilevel)!/((4.0d0*pi*rmax**3)/3.0d0) !if weight=1."
  write(ilun,format)"              else"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"                    lum_group = radiation_source(Tstar,igrp)/(scale_d*scale_v**2)*(pi*rstar_adim**2*clight/scale_v)/(2.d0*Rin)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"                    lum_group = radiation_source(Tstar,igrp)/(scale_d*scale_v**2)*(pi*rstar_adim**2*clight/scale_v)"
  write(ilun,format)"#endif"
  write(ilun,format)"                    !/((4.0d0*pi*rmax**3)/3.0d0) !if weight=1, in 3D"
  write(ilun,format)"                    uu(i,igrp) = uu(i,igrp) + lum_group*dt*r/vol ! for normalization"
  write(ilun,format)"                    !uold(ind_cell(i),5)=uold(ind_cell(i),5) + lum_group*r/vol*dtnew(ilevel) !way of adding Erad with radiation patch"
  write(ilun,format)"                    !uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + lum_group*r/vol*dtnew(ilevel)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! For shell regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'shell')then"
  write(ilun,format)"        ! An emitting spherical shell with center coordinates given,"
  write(ilun,format)"        ! along with inner and outer radius (rt_src_length_x,z)."
  write(ilun,format)"        ! Compute CIC weights relative to region center"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           xn=0.0; yn=0.0; zn=0.0"
  write(ilun,format)"           xn=max(abs(x(i,1)-rt_src_x_center(k)), 0.0_dp)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=max(abs(x(i,2)-rt_src_y_center(k)), 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=max(abs(x(i,3)-rt_src_z_center(k)), 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"           r=sqrt(xn**2+yn**2+zn**2)"
  write(ilun,format)"           if(r .gt. rt_src_length_x(k) .and. &"
  write(ilun,format)"                r .lt. rt_src_length_y(k)) then"
  write(ilun,format)"              ! If cell lies within CIC cloud, inject value"
  write(ilun,format)"              ! photon input is in # per sec...need to convert to uu"
  write(ilun,format)"!              uu(i,group_ind)=rt_n_source(k) / scale_np"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)"END SUBROUTINE radiation_sources_vsweep"
  write(ilun,format)""
  write(ilun,format)"../patch/irradiation/test_pascucci/init_hydro.f90"
  write(ilun,format)"subroutine init_hydro"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::dummy_io,info,info2"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ncell,ncache,iskip,igrid,i,ilevel,ind,ivar"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::nvar2,ilevel2,numbl2,ilun,ibound,istart,idim"
  write(ilun,format)"  integer::ncpu2,ndim2,nlevelmax2,nboundary2"
  write(ilun,format)"  integer ,dimension(:),allocatable::ind_grid"
  write(ilun,format)"  real(dp),dimension(:),allocatable::xx"
  write(ilun,format)"  real(dp)::gamma2"
  write(ilun,format)"  real(dp)::d,u,v,w,A,B,C,e"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar,ncharcpu"
  write(ilun,format)"  integer,parameter::tag=1108"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering init_hydro'"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  ! Allocate conservative, cell-centered variables arrays"
  write(ilun,format)"  !------------------------------------------------------"
  write(ilun,format)"  ncell=ncoarse+twotondim*ngridmax"
  write(ilun,format)"  allocate(uold(1:ncell,1:nvar+3))"
  write(ilun,format)"  allocate(unew(1:ncell,1:nvar+3))"
  write(ilun,format)"  uold=0.0d0; unew=0.0d0"
  write(ilun,format)"  if(fld)then"
  write(ilun,format)"     allocate(rad_flux(1:ncell,1:nvar_bicg))"
  write(ilun,format)"     allocate(urad(1:ncell,1:nvar_bicg))"
  write(ilun,format)"     allocate(frad(1:ncell,1:ndim))"
  write(ilun,format)"     rad_flux=0.0d0; urad=0.0d0; frad=0.0d0"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(momentum_feedback)then"
  write(ilun,format)"     allocate(pstarold(1:ncell))"
  write(ilun,format)"     allocate(pstarnew(1:ncell))"
  write(ilun,format)"     pstarold=0.0d0; pstarnew=0.0d0"
  write(ilun,format)"  endif"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  if(pressure_fix .or. nambipolar2.eq.1 .or.nmagdiffu2.eq.1)then"
  write(ilun,format)"#else"
  write(ilun,format)"  if(pressure_fix)then"
  write(ilun,format)"#endif     "
  write(ilun,format)"     allocate(divu(1:ncell))"
  write(ilun,format)"     allocate(enew(1:ncell))"
  write(ilun,format)"     divu=0.0d0; enew=0.0d0"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Variables for BICG scheme"
  write(ilun,format)"  ! 1 : r"
  write(ilun,format)"  ! 2 : p"
  write(ilun,format)"  ! 3 : r*"
  write(ilun,format)"  ! 4 : M-1"
  write(ilun,format)"  ! 5 : "
  write(ilun,format)"  ! 6 : z and Ap"
  write(ilun,format)"  ! 7 : p*"
  write(ilun,format)"  ! 8 : p*A"
  write(ilun,format)"  ! 9 : z*"
  write(ilun,format)"  allocate(kappaR_bicg(1:ncell,1:ngrp))"
  write(ilun,format)"  ! if FLD: matrix of size ngrpxngrp (because matrix only on Eg)"
  write(ilun,format)"  ! if  M1: matrix of size (1+nrad)x(1+nrad) (on T,Eg,Fg)"
  write(ilun,format)"  allocate(var_bicg(1:ncell,1:nvar_bicg,1:10+2*ndim))"
  write(ilun,format)"  allocate(precond_bicg(1:ncell,1:nvar_bicg,1:nvar_bicg))"
  write(ilun,format)"  if(store_matrix) then"
  write(ilun,format)"     allocate(mat_residual_glob(1:ncell,1:nvar_bicg,1:nvar_bicg),residual_glob(1:ncell,1:nvar_bicg))"
  write(ilun,format)"     allocate(coeff_glob_left(1:ncell,1:nvar_bicg,1:nvar_bicg,1:ndim),coeff_glob_right(1:ncell,1:nvar_bicg,1:nvar_bicg,1:ndim))"
  write(ilun,format)"  else"
  write(ilun,format)"     allocate(mat_residual_glob(1,1:nvar_bicg,1:nvar_bicg),residual_glob(1,1:nvar_bicg))"
  write(ilun,format)"     allocate(coeff_glob_left(1,1:nvar_bicg,1:nvar_bicg,1:ndim),coeff_glob_right(1,1:nvar_bicg,1:nvar_bicg,1:ndim))"
  write(ilun,format)"  endif"
  write(ilun,format)"  kappar_bicg=0.0d0;var_bicg=0.0d0;precond_bicg=0.0d0"
  write(ilun,format)"  mat_residual_glob=0.0d0;residual_glob=0.0d0"
  write(ilun,format)"  coeff_glob_left=0.0d0;coeff_glob_right=0.0d0"
  write(ilun,format)"  "
  write(ilun,format)"  !--------------------------------"
  write(ilun,format)"  ! For a restart, read hydro file"
  write(ilun,format)"  !--------------------------------"
  write(ilun,format)"  if(nrestart>0)then"
  write(ilun,format)"     ilun=ncpu+myid+10"
  write(ilun,format)"     call title(nrestart,nchar)"
  write(ilun,format)"     if(IOGROUPSIZEREP>0)then"
  write(ilun,format)"        call title(((myid-1)/IOGROUPSIZEREP)+1,ncharcpu)"
  write(ilun,format)"        fileloc='output_'//TRIM(nchar)//'/group_'//TRIM(ncharcpu)//'/hydro_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     else"
  write(ilun,format)"        fileloc='output_'//TRIM(nchar)//'/hydro_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call title(myid,nchar)"
  write(ilun,format)"     fileloc=TRIM(fileloc)//TRIM(nchar)"
  write(ilun,format)"     ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)"     open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"     read(ilun)ncpu2"
  write(ilun,format)"     read(ilun)nvar2"
  write(ilun,format)"     read(ilun)ndim2"
  write(ilun,format)"     read(ilun)nlevelmax2"
  write(ilun,format)"     read(ilun)nboundary2"
  write(ilun,format)"     read(ilun)gamma2"
  write(ilun,format)""
  write(ilun,format)"!      if( (eos .and. nvar2.ne.nvar+3+1) .or. (.not.eos .and. nvar2.ne.nvar+3) )then"
  write(ilun,format)"!      if(nvar2.ne.nvar+4)then"
  write(ilun,format)"     if(.not.(neq_chem.or.rt) .and. nvar2.ne.nvar+4)then"
  write(ilun,format)"        write(*,*)'File hydro.tmp is not compatible'"
  write(ilun,format)"        write(*,*)'Found   =',nvar2"
  write(ilun,format)"        write(*,*)'Expected=',nvar+4"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     end if"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if((neq_chem.or.rt).and.nvar2.lt.nvar+4+NGroups*(ndim+1))then ! OK to add ionization fraction vars"
  write(ilun,format)"        ! Convert birth times for RT postprocessing:"
  write(ilun,format)"        if(rt.and.static) convert_birth_times=.true."
  write(ilun,format)"        if(myid==1) write(*,*)'File hydro.tmp is not compatible'"
  write(ilun,format)"        if(myid==1) write(*,*)'Found nvar2  =',nvar2"
  write(ilun,format)"        if(myid==1) write(*,*)'Expected=',nvar+4+NGroups*(ndim+1)"
  write(ilun,format)"        if(myid==1) write(*,*)'..so only reading first ',nvar2, &"
  write(ilun,format)"                  'variables and setting the rest to zero'"
  write(ilun,format)"     end if"
  write(ilun,format)"     if((neq_chem.or.rt).and.nvar2.gt.nvar+4+NGroups*(ndim+1))then ! Not OK to drop variables"
  write(ilun,format)"        if(myid==1) write(*,*)'File hydro.tmp is not compatible'"
  write(ilun,format)"        if(myid==1) write(*,*)'Found   =',nvar2"
  write(ilun,format)"        if(myid==1) write(*,*)'Expected=',nvar+4+NGroups*(ndim+1)"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)"     do ilevel=1,nlevelmax2"
  write(ilun,format)"        do ibound=1,nboundary+ncpu"
  write(ilun,format)"           if(ibound<=ncpu)then"
  write(ilun,format)"              ncache=numbl(ibound,ilevel)"
  write(ilun,format)"              istart=headl(ibound,ilevel)"
  write(ilun,format)"           else"
  write(ilun,format)"              ncache=numbb(ibound-ncpu,ilevel)"
  write(ilun,format)"              istart=headb(ibound-ncpu,ilevel)"
  write(ilun,format)"           end if"
  write(ilun,format)"           read(ilun)ilevel2"
  write(ilun,format)"           read(ilun)numbl2"
  write(ilun,format)"           if(numbl2.ne.ncache)then"
  write(ilun,format)"              write(*,*)'File hydro.tmp is not compatible'"
  write(ilun,format)"              write(*,*)'Found   =',numbl2,' for level ',ilevel2"
  write(ilun,format)"              write(*,*)'Expected=',ncache,' for level ',ilevel"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ncache>0)then"
  write(ilun,format)"              allocate(ind_grid(1:ncache))"
  write(ilun,format)"              allocate(xx(1:ncache))"
  write(ilun,format)"              ! Loop over level grids"
  write(ilun,format)"              igrid=istart"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 ind_grid(i)=igrid"
  write(ilun,format)"                 igrid=next(igrid)"
  write(ilun,format)"              end do"
  write(ilun,format)"              ! Loop over cells"
  write(ilun,format)"              do ind=1,twotondim"
  write(ilun,format)"                 iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"                 ! Loop over conservative variables"
  write(ilun,format)"                 do ivar=1,4"
  write(ilun,format)"                    read(ilun)xx"
  write(ilun,format)"                    if(ivar==1)then ! Read density"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,1)=xx(i)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    else"
  write(ilun,format)"                       if(write_conservative) then ! Read momentum field"
  write(ilun,format)"                          do i=1,ncache"
  write(ilun,format)"                             uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                          end do"
  write(ilun,format)"                       else ! Read velocity field"
  write(ilun,format)"                          do i=1,ncache"
  write(ilun,format)"                             uold(ind_grid(i)+iskip,ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                          end do"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 do ivar=6,8 ! Read left B field"
  write(ilun,format)"                    read(ilun)xx"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 do ivar=nvar+1,nvar+3 ! Read right B field"
  write(ilun,format)"                    read(ilun)xx"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"                 if(write_conservative) then"
  write(ilun,format)"                    ! Read non-thermal energies"
  write(ilun,format)"                    do ivar=9,8+nent"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ! Read non-thermal pressures --> non-thermal energies"
  write(ilun,format)"                    do ivar=9,8+nent"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)/(gamma_rad(ivar-8)-1.0d0)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"                 if(write_conservative) then"
  write(ilun,format)"                    read(ilun)xx ! Read total energy"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,5)=xx(i)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 else"
  write(ilun,format)"                    read(ilun)xx ! Read pressure"
  write(ilun,format)"                    if(.not.eos) then"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          e=xx(i)/(gamma-1d0)"
  write(ilun,format)"                          d=max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                          u=uold(ind_grid(i)+iskip,2)/d"
  write(ilun,format)"                          v=uold(ind_grid(i)+iskip,3)/d"
  write(ilun,format)"                          w=uold(ind_grid(i)+iskip,4)/d"
  write(ilun,format)"                          A=0.5*(uold(ind_grid(i)+iskip,6)+uold(ind_grid(i)+iskip,nvar+1))"
  write(ilun,format)"                          B=0.5*(uold(ind_grid(i)+iskip,7)+uold(ind_grid(i)+iskip,nvar+2))"
  write(ilun,format)"                          C=0.5*(uold(ind_grid(i)+iskip,8)+uold(ind_grid(i)+iskip,nvar+3))"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,5)=e+0.5*d*(u**2+v**2+w**2)+0.5*(A**2+B**2+C**2)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                 do ivar=1,ngrp"
  write(ilun,format)"                    read(ilun)xx ! Read radiative energy if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,firstindex_er+ivar) = xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"                 do ivar=1,nfr"
  write(ilun,format)"                    read(ilun)xx ! Read radiative flux if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,firstindex_fr+ivar) = xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NEXTINCT>0"
  write(ilun,format)"                 !Read extinction parameter"
  write(ilun,format)"                 do ivar=1,nextinct"
  write(ilun,format)"                    read(ilun)xx ! Read extinction if activated"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,firstindex_extinct+ivar) = xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NPSCAL>0"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"                 if(write_conservative) then"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4-NGroups*(ndim+1))-4 ! Read conservative passive scalars if any"
  write(ilun,format)"#else"
  write(ilun,format)"                    !do ivar=1,npscal-4 ! Read conservative passive scalars if any"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4)-4 ! Read conservative passive scalars if any"
  write(ilun,format)"#endif"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          !uold(ind_grid(i)+iskip,firstindex_pscal+ivar)=xx(i)"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4-NGroups*(ndim+1))-4 ! Read passive scalars if any"
  write(ilun,format)"#else"
  write(ilun,format)"                    !do ivar=1,npscal-4 ! Read passive scalars if any"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4)-4 ! Read passive scalars if any"
  write(ilun,format)"#endif"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          !uold(ind_grid(i)+iskip,firstindex_pscal+ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                 do ivar=min(nvar,nvar2)-3,min(nvar,nvar2-4-NGroups*(ndim+1))-1 ! Read current"
  write(ilun,format)"#else"
  write(ilun,format)"                 !do ivar=npscal-3,npscal-1 ! Read current"
  write(ilun,format)"                 do ivar=min(nvar,nvar2)-3,min(nvar,nvar2-4)-1 ! Read current"
  write(ilun,format)"#endif"
  write(ilun,format)"                    read(ilun)xx"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       !uold(ind_grid(i)+iskip,firstindex_pscal+ivar)=xx(i)"
  write(ilun,format)"                       uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end do                 "
  write(ilun,format)"#else"
  write(ilun,format)"                 if(write_conservative) then"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4-NGroups*(ndim+1))-1 ! Read conservative passive scalars if any"
  write(ilun,format)"#else"
  write(ilun,format)"                    !do ivar=1,npscal-1 ! Read conservative passive scalars if any"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4)-1 ! Read conservative passive scalars if any"
  write(ilun,format)"#endif"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          !uold(ind_grid(i)+iskip,firstindex_pscal+ivar)=xx(i)"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4-NGroups*(ndim+1))-1 ! Read passive scalars if any"
  write(ilun,format)"#else"
  write(ilun,format)"                    !do ivar=1,npscal-1 ! Read passive scalars if any"
  write(ilun,format)"                    do ivar=firstindex_pscal+1,min(nvar,nvar2-4)-1 ! Read passive scalars if any"
  write(ilun,format)"#endif"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          !uold(ind_grid(i)+iskip,firstindex_pscal+ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,ivar)=xx(i)*max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Read internal energy"
  write(ilun,format)"                 read(ilun)xx"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    uold(ind_grid(i)+iskip,firstindex_pscal+npscal)=xx(i)"
  write(ilun,format)"                 end do"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Read in the temperature"
  write(ilun,format)"                 read(ilun)xx"
  write(ilun,format)"                 if(.not.write_conservative) then"
  write(ilun,format)"                    if(eos) then"
  write(ilun,format)"                       !if eos, update the total energy"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          d=max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                          if(energy_fix) then"
  write(ilun,format)"                             e=uold(ind_grid(i)+iskip,nvar)"
  write(ilun,format)"                          else"
  write(ilun,format)"                             call enerint_eos(d,xx(i),e)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                          u=uold(ind_grid(i)+iskip,2)/d"
  write(ilun,format)"                          v=uold(ind_grid(i)+iskip,3)/d"
  write(ilun,format)"                          w=uold(ind_grid(i)+iskip,4)/d"
  write(ilun,format)"                          A=0.5*(uold(ind_grid(i)+iskip,6)+uold(ind_grid(i)+iskip,nvar+1))"
  write(ilun,format)"                          B=0.5*(uold(ind_grid(i)+iskip,7)+uold(ind_grid(i)+iskip,nvar+2))"
  write(ilun,format)"                          C=0.5*(uold(ind_grid(i)+iskip,8)+uold(ind_grid(i)+iskip,nvar+3))"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,5)=e+0.5*d*(u**2+v**2+w**2)+0.5*(A**2+B**2+C**2)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    endif"
  write(ilun,format)""
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       do irad=1,nener"
  write(ilun,format)"                          uold(ind_grid(i)+iskip,5)=uold(ind_grid(i)+iskip,5)+uold(ind_grid(i)+iskip,8+irad)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                 ! Read-only"
  write(ilun,format)"                 do ivar=1,nGroups"
  write(ilun,format)"                    read(ilun)xx"
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)"                       read(ilun)xx"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                 !raph force rad fld"
  write(ilun,format)"                 !do ivar=1,ndim"
  write(ilun,format)"                 !  do i=1,ncache"
  write(ilun,format)"                 !      xdp(i) = frad(ind_grid(i)+iskip, idim)"
  write(ilun,format)"                 !   enddo"
  write(ilun,format)"                 !   read(ilun)xdp"
  write(ilun,format)"                 !enddo"
  write(ilun,format)"                 !raph"
  write(ilun,format)"        "
  write(ilun,format)"              end do"
  write(ilun,format)"              deallocate(ind_grid,xx)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(ilun)"
  write(ilun,format)"     ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"           dummy_io=1"
  write(ilun,format)"           call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"                & MPI_COMM_WORLD,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(debug)write(*,*)'hydro.tmp read for processor ',myid"
  write(ilun,format)"     call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(verbose)write(*,*)'HYDRO backup files read completed'"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine init_hydro"
  write(ilun,format)"../patch/irradiation/test_pascucci/init_sink.f90"
  write(ilun,format)"subroutine init_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"!!   use cooling_module,only: clight"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer,parameter::tag=1112,tag2=1113"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::i, idim, isink, nsinkold"
  write(ilun,format)"  integer::ilun"
  write(ilun,format)"  real(dp)::xx1,xx2,xx3,vv1,vv2,vv3,mm1,ll1,ll2,ll3!!,radiation_source,pi"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::xdp"
  write(ilun,format)"  integer,allocatable,dimension(:)::isp"
  write(ilun,format)"  logical,allocatable,dimension(:)::nb"
  write(ilun,format)"  logical::eof,ic_sink=.false."
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar,ncharcpu"
  write(ilun,format)""
  write(ilun,format)"  !allocate all sink related quantities..."
  write(ilun,format)"  allocate(weightp(1:npartmax,1:twotondim))"
  write(ilun,format)"  weightp=0.0"
  write(ilun,format)"  allocate(msink(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute feedback around sink"
  write(ilun,format)"  allocate(dmfsink(1:nsinkmax))"
  write(ilun,format)"  dmfsink=0.0"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 07/2016 to record feedback around sink"
  write(ilun,format)"  allocate(Eioni(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  allocate(tsink(1:nsinkmax))"
  write(ilun,format)"  allocate(idsink(1:nsinkmax))"
  write(ilun,format)"  idsink=0 ! Important: need to set idsink to zero"
  write(ilun,format)"  allocate(xsink(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(vsink(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(vsold(1:nsinkmax,1:ndim,levelmin:nlevelmax))"
  write(ilun,format)"  allocate(vsnew(1:nsinkmax,1:ndim,levelmin:nlevelmax))"
  write(ilun,format)"  allocate(fsink_partial(1:nsinkmax,1:ndim,levelmin:nlevelmax))"
  write(ilun,format)"  allocate(fsink(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(acc_rate(1:nsinkmax))"
  write(ilun,format)"  acc_rate=0."
  write(ilun,format)"  allocate(acc_lum(1:nsinkmax))"
  write(ilun,format)"  acc_lum=0."
  write(ilun,format)"  allocate(int_lum(1:nsinkmax))"
  write(ilun,format)"  int_lum=0."
  write(ilun,format)"  allocate(dt_acc(1:nsinkmax))"
  write(ilun,format)"  allocate(rho_sink_tff(levelmin:nlevelmax))"
  write(ilun,format)"  allocate(lsink(1:nsinkmax,1:3))"
  write(ilun,format)"  lsink=0.d0"
  write(ilun,format)"  allocate(level_sink(1:nsinkmax,levelmin:nlevelmax))"
  write(ilun,format)"  allocate(delta_mass(1:nsinkmax))"
  write(ilun,format)"  ! Temporary sink variables"
  write(ilun,format)"  allocate(wden(1:nsinkmax))"
  write(ilun,format)"  allocate(wmom(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(weth(1:nsinkmax))"
  write(ilun,format)"  allocate(wvol(1:nsinkmax))"
  write(ilun,format)"  allocate(wdiv(1:nsinkmax))"
  write(ilun,format)"  allocate(wden_new(1:nsinkmax))"
  write(ilun,format)"  allocate(wmom_new(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(weth_new(1:nsinkmax))"
  write(ilun,format)"  allocate(wvol_new(1:nsinkmax))"
  write(ilun,format)"  allocate(wdiv_new(1:nsinkmax))"
  write(ilun,format)"  allocate(msink_new(1:nsinkmax))"
  write(ilun,format)"  allocate(mseed(1:nsinkmax))"
  write(ilun,format)"  allocate(mseed_new(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute feedback around sink"
  write(ilun,format)"  allocate(dmfsink_new(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)"  allocate(mseed_all(1:nsinkmax))"
  write(ilun,format)"  allocate(msink_all(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute feedback around sink"
  write(ilun,format)"  allocate(dmfsink_all(1:nsinkmax))"
  write(ilun,format)""
  write(ilun,format)"  allocate(tsink_new(1:nsinkmax))"
  write(ilun,format)"  allocate(tsink_all(1:nsinkmax))"
  write(ilun,format)"  allocate(idsink_new(1:nsinkmax))"
  write(ilun,format)"  allocate(idsink_all(1:nsinkmax))"
  write(ilun,format)"  allocate(idsink_old(1:nsinkmax))"
  write(ilun,format)"  allocate(vsink_new(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(vsink_all(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(fsink_new(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(fsink_all(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(lsink_new(1:nsinkmax,1:3))"
  write(ilun,format)"  allocate(lsink_all(1:nsinkmax,1:3))"
  write(ilun,format)"  allocate(xsink_new(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(xsink_all(1:nsinkmax,1:ndim))"
  write(ilun,format)"  allocate(sink_jump(1:nsinkmax,1:ndim,levelmin:nlevelmax))"
  write(ilun,format)"  sink_jump=0.d0"
  write(ilun,format)"  allocate(level_sink_new(1:nsinkmax,levelmin:nlevelmax))"
  write(ilun,format)"  allocate(dMsink_overdt(1:nsinkmax))"
  write(ilun,format)"  allocate(dMBHoverdt(1:nsinkmax))"
  write(ilun,format)"  allocate(eps_sink(1:nsinkmax))"
  write(ilun,format)"  eps_sink=0.d0"
  write(ilun,format)"  allocate(volume_gas(1:nsinkmax))"
  write(ilun,format)"  volume_gas=0.d0"
  write(ilun,format)"  allocate(vel_gas(1:nsinkmax,1:ndim))"
  write(ilun,format)"  vel_gas=0.d0"
  write(ilun,format)"  allocate(rho_gas(1:nsinkmax))"
  write(ilun,format)"  rho_gas=0.d0"
  write(ilun,format)"  allocate(c2sink(1:nsinkmax))"
  write(ilun,format)"  allocate(weighted_density(1:nsinkmax,1:nlevelmax))"
  write(ilun,format)"  weighted_density = 0.d0"
  write(ilun,format)"  allocate(weighted_volume(1:nsinkmax,1:nlevelmax))"
  write(ilun,format)"  weighted_volume = 0.d0"
  write(ilun,format)"  allocate(weighted_ethermal(1:nsinkmax,1:nlevelmax))"
  write(ilun,format)"  weighted_ethermal = 0.d0"
  write(ilun,format)"  allocate(weighted_momentum(1:nsinkmax,1:nlevelmax,1:ndim))"
  write(ilun,format)"  weighted_momentum = 0.d0"
  write(ilun,format)"  allocate(weighted_divergence(1:nsinkmax,1:nlevelmax))"
  write(ilun,format)"  weighted_divergence = 0.d0"
  write(ilun,format)"  allocate(oksink_new(1:nsinkmax))"
  write(ilun,format)"  allocate(oksink_all(1:nsinkmax))"
  write(ilun,format)"  allocate(idsink_sort(1:nsinkmax))"
  write(ilun,format)"  allocate(xmsink(1:nsinkmax))"
  write(ilun,format)"  allocate(delta_mass_new(1:nsinkmax),delta_mass_all(1:nsinkmax))"
  write(ilun,format)"  allocate(ok_blast_agn(1:nsinkmax),ok_blast_agn_all(1:nsinkmax))"
  write(ilun,format)"  allocate(direct_force_sink(1:nsinkmax))"
  write(ilun,format)"  allocate(new_born(1:nsinkmax),new_born_all(1:nsinkmax),new_born_new(1:nsinkmax))"
  write(ilun,format)"  allocate(lum_sink(1:nsinkmax),lum_sink_all(1:nsinkmax))"
  write(ilun,format)"  allocate(rsink_star(1:nsinkmax),Teff_sink(1:nsinkmax))"
  write(ilun,format)"  rsink_star(1:nsinkmax) = rstar*Rsun/scale_l"
  write(ilun,format)"  lum_sink_all(1:nsinkmax)=0.0d0"
  write(ilun,format)"  lum_sink(1:nsinkmax)=0.0d0"
  write(ilun,format)"  Teff_sink(1:nsinkmax)=0.0d0"
  write(ilun,format)"  if(rt_feedback .and. PMS_evol)then"
  write(ilun,format)"     allocate(nburst(1:nsinkmax))"
  write(ilun,format)"     allocate(tsink_star(1:nsinkmax))"
  write(ilun,format)"     allocate(sink_star_accrate(1:nsinkmax),msink_star(1:nsinkmax))"
  write(ilun,format)"     nburst(1:nsinkmax)=0     "
  write(ilun,format)"     tsink_star(1:nsinkmax) = 0.0"
  write(ilun,format)"     sink_star_accrate(1:nsinkmax) = 0.0"
  write(ilun,format)"     msink_star(1:nsinkmax) = mprotostar / scale_m"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Compute softening length from minimum cell spacing"
  write(ilun,format)"  call compute_ncloud_sink"
  write(ilun,format)""
  write(ilun,format)"  if(nrestart>0)then"
  write(ilun,format)"     ilun=4*ncpu+myid+10"
  write(ilun,format)"     call title(nrestart,nchar)"
  write(ilun,format)""
  write(ilun,format)"     if(IOGROUPSIZEREP>0)then"
  write(ilun,format)"        call title(((myid-1)/IOGROUPSIZEREP)+1,ncharcpu)"
  write(ilun,format)"        fileloc='output_'//TRIM(nchar)//'/group_'//TRIM(ncharcpu)//'/sink_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     else"
  write(ilun,format)"        fileloc='output_'//TRIM(nchar)//'/sink_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     call title(myid,nchar)"
  write(ilun,format)"     fileloc=TRIM(fileloc)//TRIM(nchar)"
  write(ilun,format)""
  write(ilun,format)"     ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"     rewind(ilun)"
  write(ilun,format)"     read(ilun)nsink"
  write(ilun,format)"     read(ilun)nindsink"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     if(nsink>0)then"
  write(ilun,format)"        allocate(xdp(1:nsink))"
  write(ilun,format)"        read(ilun)xdp ! Read sink mass"
  write(ilun,format)"        msink(1:nsink)=xdp"
  write(ilun,format)""
  write(ilun,format)"        !to be re-introduced"
  write(ilun,format)"        !!ADDED by PH 09/2013"
  write(ilun,format)"        read(ilun)xdp ! Read sink mass"
  write(ilun,format)"        dmfsink(1:nsink)=xdp"
  write(ilun,format)""
  write(ilun,format)"        read(ilun)xdp ! Read sink birth epoch"
  write(ilun,format)"        tsink(1:nsink)=xdp"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           read(ilun)xdp ! Read sink position"
  write(ilun,format)"           xsink(1:nsink,idim)=xdp"
  write(ilun,format)"        end do"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           read(ilun)xdp ! Read sink velocity"
  write(ilun,format)"           vsink(1:nsink,idim)=xdp"
  write(ilun,format)"        end do"
  write(ilun,format)"        do idim=1,3"
  write(ilun,format)"           read(ilun)xdp ! Read sink angular momentum"
  write(ilun,format)"           lsink(1:nsink,idim)=xdp"
  write(ilun,format)"        end do"
  write(ilun,format)"        read(ilun)xdp ! Read sink accumulated rest mass energy"
  write(ilun,format)"        delta_mass(1:nsink)=xdp"
  write(ilun,format)"        read(ilun)xdp ! Read sink accretion rate"
  write(ilun,format)"        acc_rate(1:nsink)=xdp"
  write(ilun,format)"        read(ilun)xdp ! Read sink stellar effective temperature"
  write(ilun,format)"        Teff_sink(1:nsink)=xdp"
  write(ilun,format)"        read(ilun)xdp ! Read sink stellar radius"
  write(ilun,format)"        rsink_star(1:nsink)=xdp"
  write(ilun,format)""
  write(ilun,format)"!        to be re-introduced"
  write(ilun,format)"!        read(ilun)xdp ! Read sink emitted ionising photons"
  write(ilun,format)"!        Eioni(1:nsink)=xdp"
  write(ilun,format)""
  write(ilun,format)"        deallocate(xdp)"
  write(ilun,format)"        allocate(isp(1:nsink))"
  write(ilun,format)"        read(ilun)isp ! Read sink index"
  write(ilun,format)"        idsink(1:nsink)=isp"
  write(ilun,format)"        deallocate(isp)"
  write(ilun,format)"!        read(ilun)ncloud_sink"
  write(ilun,format)"        allocate(nb(1:nsink))"
  write(ilun,format)"        read(ilun)nb ! Read newborn boolean"
  write(ilun,format)"        new_born(1:nsink)=nb"
  write(ilun,format)"        deallocate(nb)"
  write(ilun,format)"        read(ilun)sinkint_level"
  write(ilun,format)"     end if"
  write(ilun,format)"     close(ilun)"
  write(ilun,format)"     ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"           dummy_io=1"
  write(ilun,format)"           call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"                & MPI_COMM_WORLD,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     call compute_ncloud_sink"
  write(ilun,format)""
  write(ilun,format)"     if(ir_feedback)then"
  write(ilun,format)"        do i=1,nsink"
  write(ilun,format)"           acc_lum(i)=ir_eff*acc_rate(i)*msink(i)/(5*6.955d10/scale_l)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (nrestart>0)then"
  write(ilun,format)"     nsinkold=nsink"
  write(ilun,format)"     if(TRIM(initfile(levelmin)).NE.' ')then"
  write(ilun,format)"        filename=TRIM(initfile(levelmin))//'/ic_sink_restart'"
  write(ilun,format)"     else"
  write(ilun,format)"        filename='ic_sink_restart'"
  write(ilun,format)"     end if"
  write(ilun,format)"     INQUIRE(FILE=filename, EXIST=ic_sink)"
  write(ilun,format)"     if (.not. ic_sink)then"
  write(ilun,format)"        filename='ic_sink_restart'"
  write(ilun,format)"        INQUIRE(FILE=filename, EXIST=ic_sink)"
  write(ilun,format)"     end if"
  write(ilun,format)"     !raph: to recompute the values of lum sink if restart"
  write(ilun,format)"     rsink_star(1) = rstar*Rsun/scale_l"
  write(ilun,format)"     lum_sink(1)=(5.67d-5*(Teff_sink(1)**4))*4.0d0*3.1415d0*(rstar*6.96d10)**2/(scale_d*(scale_l)**2*(scale_v)**3)"
  write(ilun,format)"     int_lum(1)=lum_sink(1) ! lum_sink = sigma R2 T4 = E/t donc adim = d * l**3 * v**2 / t = d * l**2 * v**3"
  write(ilun,format)"     !raph"
  write(ilun,format)"  else"
  write(ilun,format)"     nsink=0"
  write(ilun,format)"     nindsink=0"
  write(ilun,format)"     nsinkold=0"
  write(ilun,format)"     !!!!!!------------!!!!!!!!!"
  write(ilun,format)"     nsink=1"
  write(ilun,format)"     xsink(1,1:3)=boxlen/2."
  write(ilun,format)"     msink(1)=1.d-10"
  write(ilun,format)"     rsink_star(1) = rstar*Rsun/scale_l"
  write(ilun,format)"     Teff_sink(1)=Tstar"
  write(ilun,format)"!!   lum_sink(1)=(5.67d-5*(5800.**4))*3.1415/2.0d0*(6.96d10**2)/(scale_d*(scale_l)**2*(scale_v)**3)"
  write(ilun,format)"     lum_sink(1)=(5.67d-5*(Teff_sink(1)**4))*4.0d0*3.1415d0*(rstar*6.96d10)**2/(scale_d*(scale_l)**2*(scale_v)**3)"
  write(ilun,format)""
  write(ilun,format)"!!      pi=acos(-1.0d0)"
  write(ilun,format)"!!      write(*,*) '1',lum_sink(1)"
  write(ilun,format)"!!      write(*,*) '2',radiation_source(Teff_sink(1),1)/(scale_d*scale_v**2)*(pi*rsink_star(1)**2*clight/scale_v)"
  write(ilun,format)"!!      write(*,*) '3',radiation_source(Teff_sink(1),2)/(scale_d*scale_v**2)*(pi*rsink_star(1)**2*clight/scale_v)"
  write(ilun,format)"!!      stop"
  write(ilun,format)"     !write(*,*) 'lum sink, rstartinit, rsinkstar, teff_sink=', lum_sink(1), rstar_init, rsink_star(1),Teff_sink(1)"
  write(ilun,format)"     !write(*,*)'nsink, xsink(1,1:3), msink(1)', nsink, xsink(1,1:3), msink(1)"
  write(ilun,format)"     int_lum(1)=lum_sink(1)"
  write(ilun,format)"     print*,'================================================================'"
  write(ilun,format)"     print*,nsink,xsink(1,:),lum_sink(1)                                           "
  write(ilun,format)"     idsink(1)=1"
  write(ilun,format)"     new_born(1)=.true."
  write(ilun,format)"     !!!!!!!-----------!!!!!!!!!"
  write(ilun,format)"     if(TRIM(initfile(levelmin)).NE.' ')then"
  write(ilun,format)"        filename=TRIM(initfile(levelmin))//'/ic_sink'"
  write(ilun,format)"     else"
  write(ilun,format)"        filename='ic_sink'"
  write(ilun,format)"     end if"
  write(ilun,format)"     INQUIRE(FILE=filename, EXIST=ic_sink)"
  write(ilun,format)"     if (.not. ic_sink)then"
  write(ilun,format)"        filename='ic_sink'"
  write(ilun,format)"        INQUIRE(FILE=filename, EXIST=ic_sink)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (ic_sink)then"
  write(ilun,format)""
  write(ilun,format)"     ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag2,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     open(10,file=filename,form='formatted')"
  write(ilun,format)"     eof=.false."
  write(ilun,format)"     do"
  write(ilun,format)"        read(10,*,end=102)mm1,xx1,xx2,xx3,vv1,vv2,vv3,ll1,ll2,ll3"
  write(ilun,format)"        nsink=nsink+1"
  write(ilun,format)"        nindsink=nindsink+1"
  write(ilun,format)"        idsink(nsink)=nindsink"
  write(ilun,format)"        msink(nsink)=mm1"
  write(ilun,format)"        xsink(nsink,1)=xx1+boxlen/2.0"
  write(ilun,format)"        xsink(nsink,2)=xx2+boxlen/2.0"
  write(ilun,format)"        xsink(nsink,3)=xx3+boxlen/2.0"
  write(ilun,format)"        vsink(nsink,1)=vv1"
  write(ilun,format)"        vsink(nsink,2)=vv2"
  write(ilun,format)"        vsink(nsink,3)=vv3"
  write(ilun,format)"        lsink(nsink,1)=ll1"
  write(ilun,format)"        lsink(nsink,2)=ll2"
  write(ilun,format)"        lsink(nsink,3)=ll3"
  write(ilun,format)"        tsink(nsink)=t"
  write(ilun,format)"        new_born(nsink)=.true."
  write(ilun,format)"     end do"
  write(ilun,format)"102  continue"
  write(ilun,format)"     close(10)"
  write(ilun,format)"     ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"           dummy_io=1"
  write(ilun,format)"           call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag2, &"
  write(ilun,format)"                & MPI_COMM_WORLD,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)"  if (myid==1.and.nsink-nsinkold>0)then"
  write(ilun,format)"     write(*,*)'sinks read from file '//filename"
  write(ilun,format)"     write(*,'('   Id           M             x             y             z            vx            vy            vz            lx            ly            lz       ')')"
  write(ilun,format)"     write(*,'('======================================================================================================================================================')')"
  write(ilun,format)"     do isink=nsinkold+1,nsink"
  write(ilun,format)"        write(*,'(I8,2X,10(2X,E12.5))')idsink(isink),msink(isink),xsink(isink,1:ndim),&"
  write(ilun,format)"             vsink(isink,1:ndim),lsink(isink,1:ndim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     direct_force_sink(isink)=(msink(isink) .ge. mass_sink_direct_force)"
  write(ilun,format)"  end do"
  write(ilun,format)"end subroutine init_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine compute_ncloud_sink"
  write(ilun,format)"  use amr_commons, only:dp"
  write(ilun,format)"  use pm_commons, only:ir_cloud,ir_cloud_massive,ncloud_sink,ncloud_sink_massive"
  write(ilun,format)"  real(dp)::xx,yy,zz,rr"
  write(ilun,format)"  integer::ii,jj,kk"
  write(ilun,format)"  ! Compute number of cloud particles"
  write(ilun,format)"  ncloud_sink=0"
  write(ilun,format)"  ncloud_sink_massive=0"
  write(ilun,format)"  do kk=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"     zz=dble(kk)/2.0"
  write(ilun,format)"     do jj=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"        yy=dble(jj)/2.0"
  write(ilun,format)"        do ii=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"           xx=dble(ii)/2.0"
  write(ilun,format)"           rr=sqrt(xx*xx+yy*yy+zz*zz)"
  write(ilun,format)"           if(rr<=dble(ir_cloud))ncloud_sink=ncloud_sink+1"
  write(ilun,format)"           if(rr<=dble(ir_cloud_massive))ncloud_sink_massive=ncloud_sink_massive+1"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"end subroutine compute_ncloud_sink"
  write(ilun,format)""
  write(ilun,format)"../patch/irradiation/test_pascucci/output_amr.f90"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine dump_all"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module"
  write(ilun,format)"#if USE_TURB==1"
  write(ilun,format)"  use turb_commons"
  write(ilun,format)"#endif"
  write(ilun,format)"  use feedback_module"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"#if ! defined (WITHOUTMPI) || defined (NOSYSTEM)"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  character::nml_char"
  write(ilun,format)"  character(LEN=5)::nchar,ncharcpu"
  write(ilun,format)"  character(LEN=80)::filename,filedir,filedirini,filecmd"
  write(ilun,format)"  integer::irec,ierr"
  write(ilun,format)""
  write(ilun,format)"  if(nstep_coarse==nstep_coarse_old.and.nstep_coarse>0)return"
  write(ilun,format)"  if(nstep_coarse==0.and.nrestart>0)return"
  write(ilun,format)"  if(verbose)write(*,*)'Entering dump_all'"
  write(ilun,format)""
  write(ilun,format)"  call write_screen"
  write(ilun,format)"  call title(ifout,nchar)"
  write(ilun,format)"  ifout=ifout+1"
  write(ilun,format)"  if(t>=tout(iout).or.aexp>=aout(iout))iout=iout+1"
  write(ilun,format)"  output_done=.true."
  write(ilun,format)""
  write(ilun,format)"  if(IOGROUPSIZEREP>0)call title(((myid-1)/IOGROUPSIZEREP)+1,ncharcpu)"
  write(ilun,format)""
  write(ilun,format)"!   if(ndim>1)then"
  write(ilun,format)"     if(IOGROUPSIZEREP>0) then"
  write(ilun,format)"        filedirini='output_'//TRIM(nchar)//'/'"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/group_'//TRIM(ncharcpu)//'/'"
  write(ilun,format)"     else"
  write(ilun,format)"        filedir='output_'//TRIM(nchar)//'/'"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     filecmd='mkdir -p '//TRIM(filedir)"
  write(ilun,format)""
  write(ilun,format)"     if (.not.withoutmkdir) then"
  write(ilun,format)"#ifdef NOSYSTEM"
  write(ilun,format)"        call PXFMKDIR(TRIM(filedirini),LEN(TRIM(filedirini)),O'755',info)"
  write(ilun,format)"        call PXFMKDIR(TRIM(filedir),LEN(TRIM(filedir)),O'755',info)"
  write(ilun,format)"#else"
  write(ilun,format)"        call EXECUTE_COMMAND_LINE(filecmd,exitstat=ierr,wait=.true.)"
  write(ilun,format)"        if(ierr.ne.0 .and. ierr.ne.127)then"
  write(ilun,format)"           write(*,*) 'Error - Could not create ',trim(filedir),' error code=',ierr"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"           call MPI_ABORT(MPI_COMM_WORLD,1,info)"
  write(ilun,format)"#else"
  write(ilun,format)"           stop"
  write(ilun,format)"#endif"
  write(ilun,format)"        endif"
  write(ilun,format)"#endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup header'"
  write(ilun,format)"     ! Output header: must be called by each process !"
  write(ilun,format)"     filename=TRIM(filedir)//'header_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     call output_header(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup header'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup info etc.'"
  write(ilun,format)"     ! Only master process"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        filename=TRIM(filedir)//'info_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"        call output_info(filename)"
  write(ilun,format)"!!         filename=TRIM(filedir)//'makefile.txt'"
  write(ilun,format)"!!         call output_makefile(filename)"
  write(ilun,format)"!!         filename=TRIM(filedir)//'patches.txt'"
  write(ilun,format)"!!         call output_patch(filename)"
  write(ilun,format)"        if(hydro)then"
  write(ilun,format)"           filename=TRIM(filedir)//'hydro_file_descriptor.txt'"
  write(ilun,format)"           call file_descriptor_hydro(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(cooling .and. .not. neq_chem)then"
  write(ilun,format)"           filename=TRIM(filedir)//'cooling_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call output_cool(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.info'"
  write(ilun,format)"           call output_sink(filename)"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.csv'"
  write(ilun,format)"           call output_sink_csv(filename)"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Copy namelist file to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'namelist.txt'"
  write(ilun,format)"        OPEN(10, FILE=namelist_file, ACCESS='STREAM', ACTION='READ')"
  write(ilun,format)"        OPEN(11, FILE=filename,      ACCESS='STREAM', ACTION='WRITE')"
  write(ilun,format)"        DO"
  write(ilun,format)"           READ(10, IOSTAT=IERR)nml_char"
  write(ilun,format)"           IF (IERR.NE.0) EXIT"
  write(ilun,format)"           WRITE(11)nml_char"
  write(ilun,format)"        END DO"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"        CLOSE(10)"
  write(ilun,format)"        ! Copy compilation details to output directory"
  write(ilun,format)"        filename=TRIM(filedir)//'compilation.txt'"
  write(ilun,format)"        OPEN(UNIT=11, FILE=filename, FORM='formatted')"
  write(ilun,format)"        write(11,'(' compile date = ',A)')TRIM(builddate)"
  write(ilun,format)"        write(11,'(' patch dir    = ',A)')TRIM(patchdir)"
  write(ilun,format)"        write(11,'(' remote repo  = ',A)')TRIM(gitrepo)"
  write(ilun,format)"        write(11,'(' local branch = ',A)')TRIM(gitbranch)"
  write(ilun,format)"        write(11,'(' last commit  = ',A)')TRIM(githash)"
  write(ilun,format)"        CLOSE(11)"
  write(ilun,format)"     endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup info etc.'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start backup amr'"
  write(ilun,format)"     filename=TRIM(filedir)//'amr_'//TRIM(nchar)//'.out'"
  write(ilun,format)"     call backup_amr(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End backup amr'"
  write(ilun,format)""
  write(ilun,format)"     if(hydro)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup hydro'"
  write(ilun,format)"        filename=TRIM(filedir)//'hydro_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_hydro(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup hydro'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(rt.or.neq_chem)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rt'"
  write(ilun,format)"        filename=TRIM(filedir)//'rt_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call rt_backup_hydro(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rt'"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     if(pic)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup part'"
  write(ilun,format)"        filename=TRIM(filedir)//'part_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_part(filename)"
  write(ilun,format)"        if(sink)then"
  write(ilun,format)"           filename=TRIM(filedir)//'sink_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call backup_sink(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        if(stellar)then"
  write(ilun,format)"           filename=TRIM(filedir)//'stellar_'//TRIM(nchar)//'.out'"
  write(ilun,format)"           call backup_stellar(filename)"
  write(ilun,format)"           filename=TRIM(filedir)//'stellar_'//TRIM(nchar)//'.csv'"
  write(ilun,format)"           call output_stellar_csv(filename)"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup part'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(poisson)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup poisson'"
  write(ilun,format)"        filename=TRIM(filedir)//'grav_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_poisson(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup poisson'"
  write(ilun,format)"     end if"
  write(ilun,format)"#ifdef ATON"
  write(ilun,format)"     if(aton)then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup rad'"
  write(ilun,format)"        filename=TRIM(filedir)//'rad_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call backup_radiation(filename)"
  write(ilun,format)"        filename=TRIM(filedir)//'radgpu_'//TRIM(nchar)//'.out'"
  write(ilun,format)"        call store_radiation(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup rad'"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)"     if (gadget_output) then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup gadget format'"
  write(ilun,format)"        filename=TRIM(filedir)//'gsnapshot_'//TRIM(nchar)"
  write(ilun,format)"        call savegadget(filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup gadget format'"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"#if USE_TURB==1"
  write(ilun,format)"     if (turb) then"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'Start backup turb'"
  write(ilun,format)"        if (myid==1) call write_turb_fields(filedir)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"        if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"        if(myid==1.and.print_when_io) write(*,*)'End backup turb'"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'Start timer'"
  write(ilun,format)"     ! Output timer: must be called by each process !"
  write(ilun,format)"     filename=TRIM(filedir)//'timer_'//TRIM(nchar)//'.txt'"
  write(ilun,format)"     call output_timer(.true., filename)"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(synchro_when_io) call MPI_BARRIER(MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1.and.print_when_io) write(*,*)'End output timer'"
  write(ilun,format)""
  write(ilun,format)"!   end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine dump_all"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine backup_amr(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun"
  write(ilun,format)"  integer::ilevel,ibound,ncache,istart,i,igrid,idim,ind,iskip"
  write(ilun,format)"  integer,allocatable,dimension(:)::ind_grid,iig"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::xdp"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"  integer,parameter::tag=1120"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering backup_amr'"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Output amr grid in file"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ilun=myid+10"
  write(ilun,format)"  call title(myid,nchar)"
  write(ilun,format)"  fileloc=TRIM(filename)//TRIM(nchar)"
  write(ilun,format)""
  write(ilun,format)"   ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     if(IOGROUPSIZE>0) then"
  write(ilun,format)"        if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"           call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"                & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"  ! Write grid variables"
  write(ilun,format)"  write(ilun)ncpu"
  write(ilun,format)"  write(ilun)ndim"
  write(ilun,format)"  write(ilun)nx,ny,nz"
  write(ilun,format)"  write(ilun)nlevelmax"
  write(ilun,format)"  write(ilun)ngridmax"
  write(ilun,format)"  write(ilun)nboundary"
  write(ilun,format)"  write(ilun)ngrid_current"
  write(ilun,format)"  write(ilun)boxlen"
  write(ilun,format)"  ! Write time variables"
  write(ilun,format)"  write(ilun)noutput,iout,ifout"
  write(ilun,format)"  write(ilun)tout(1:noutput)"
  write(ilun,format)"  write(ilun)aout(1:noutput)"
  write(ilun,format)"  write(ilun)t"
  write(ilun,format)"  write(ilun)dtold(1:nlevelmax)"
  write(ilun,format)"  write(ilun)dtnew(1:nlevelmax)"
  write(ilun,format)"  write(ilun)nstep,nstep_coarse"
  write(ilun,format)"  write(ilun)einit,mass_tot_0,rho_tot"
  write(ilun,format)"  write(ilun)omega_m,omega_l,omega_k,omega_b,h0,aexp_ini,boxlen_ini"
  write(ilun,format)"  write(ilun)aexp,hexp,aexp_old,epot_tot_int,epot_tot_old"
  write(ilun,format)"  write(ilun)mass_sph"
  write(ilun,format)"  ! Write levels variables"
  write(ilun,format)"  write(ilun)headl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)taill(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbl(1:ncpu,1:nlevelmax)"
  write(ilun,format)"  write(ilun)numbtot(1:10,1:nlevelmax)"
  write(ilun,format)"  ! Read boundary linked list"
  write(ilun,format)"  if(simple_boundary)then"
  write(ilun,format)"     write(ilun)headb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)tailb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"     write(ilun)numbb(1:nboundary,1:nlevelmax)"
  write(ilun,format)"  end if"
  write(ilun,format)"  ! Write free memory"
  write(ilun,format)"  write(ilun)headf,tailf,numbf,used_mem,used_mem_tot"
  write(ilun,format)"  ! Write cpu boundaries"
  write(ilun,format)"  write(ilun)ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     write(ilun)bisec_wall(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_next(1:nbinodes,1:2)"
  write(ilun,format)"     write(ilun)bisec_indx(1:nbinodes)"
  write(ilun,format)"     write(ilun)bisec_cpubox_min(1:ncpu,1:ndim)"
  write(ilun,format)"     write(ilun)bisec_cpubox_max(1:ncpu,1:ndim)"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun)bound_key(0:ndomain)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Write coarse level"
  write(ilun,format)"  write(ilun)son(1:ncoarse)"
  write(ilun,format)"  write(ilun)flag1(1:ncoarse)"
  write(ilun,format)"  write(ilun)cpu_map(1:ncoarse)"
  write(ilun,format)"  ! Write fine levels"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     do ibound=1,nboundary+ncpu"
  write(ilun,format)"        if(ibound<=ncpu)then"
  write(ilun,format)"           ncache=numbl(ibound,ilevel)"
  write(ilun,format)"           istart=headl(ibound,ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           ncache=numbb(ibound-ncpu,ilevel)"
  write(ilun,format)"           istart=headb(ibound-ncpu,ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"        if(ncache>0)then"
  write(ilun,format)"           allocate(ind_grid(1:ncache),xdp(1:ncache),iig(1:ncache))"
  write(ilun,format)"           ! Write grid index"
  write(ilun,format)"           igrid=istart"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              ind_grid(i)=igrid"
  write(ilun,format)"              igrid=next(igrid)"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)ind_grid"
  write(ilun,format)"           ! Write next index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=next(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write prev index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=prev(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write grid center"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 xdp(i)=xg(ind_grid(i),idim)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write father index"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              iig(i)=father(ind_grid(i))"
  write(ilun,format)"           end do"
  write(ilun,format)"           write(ilun)iig"
  write(ilun,format)"           ! Write nbor index"
  write(ilun,format)"           do ind=1,twondim"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=nbor(ind_grid(i),ind)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write son index"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=son(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write cpu map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=cpu_map(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Write refinement map"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 iig(i)=flag1(ind_grid(i)+iskip)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)iig"
  write(ilun,format)"           end do"
  write(ilun,format)"           deallocate(xdp,iig,ind_grid)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine backup_amr"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_info(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use radiation_parameters,only: mu_gas"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"#ifdef RT "
  write(ilun,format)"  use rt_cooling_module,only: kappaAbs !raph pour frad"
  write(ilun,format)"  use rt_parameters, only: group_egy"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc,ny_loc,nz_loc,ilun,icpu,idom,ierr"
  write(ilun,format)"  real(dp)::scale"
  write(ilun,format)"!  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_info'"
  write(ilun,format)""
  write(ilun,format)"  ilun=11"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  !call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=nx; ny_loc=ny; nz_loc=nz"
  write(ilun,format)"  if(ndim>0)nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  if(ndim>1)ny_loc=(jcoarse_max-jcoarse_min+1)"
  write(ilun,format)"  if(ndim>2)nz_loc=(kcoarse_max-kcoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  ! Open file"
  write(ilun,format)"  fileloc=TRIM(filename)"
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='formatted',iostat=ierr)"
  write(ilun,format)"  if(ierr .ne. 0)then"
  write(ilun,format)"     write(*,*) 'Error - Could not write ',fileloc"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ABORT(MPI_COMM_WORLD,1,ierr)"
  write(ilun,format)"#else"
  write(ilun,format)"     stop"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Write run parameters"
  write(ilun,format)"  write(ilun,'('ncpu        =',I11)')ncpu"
  write(ilun,format)"  write(ilun,'('ndim        =',I11)')ndim"
  write(ilun,format)"  write(ilun,'('levelmin    =',I11)')levelmin"
  write(ilun,format)"  write(ilun,'('levelmax    =',I11)')nlevelmax"
  write(ilun,format)"  write(ilun,'('ngridmax    =',I11)')ngridmax"
  write(ilun,format)"  write(ilun,'('nstep_coarse=',I11)')nstep_coarse"
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)""
  write(ilun,format)"  ! Write physical parameters"
  write(ilun,format)"  write(ilun,'('boxlen      =',E23.15)')scale"
  write(ilun,format)"  write(ilun,'('time        =',E23.15)')t"
  write(ilun,format)"  write(ilun,'('aexp        =',E23.15)')aexp"
  write(ilun,format)"  write(ilun,'('H0          =',E23.15)')h0"
  write(ilun,format)"  write(ilun,'('omega_m     =',E23.15)')omega_m"
  write(ilun,format)"  write(ilun,'('omega_l     =',E23.15)')omega_l"
  write(ilun,format)"  write(ilun,'('omega_k     =',E23.15)')omega_k"
  write(ilun,format)"  write(ilun,'('omega_b     =',E23.15)')omega_b"
  write(ilun,format)"  write(ilun,'('unit_l      =',E23.15)')scale_l"
  write(ilun,format)"  write(ilun,'('unit_d      =',E23.15)')scale_d"
  write(ilun,format)"  write(ilun,'('unit_t      =',E23.15)')scale_t"
  write(ilun,format)"  write(ilun,'('mu_gas      =',E23.15)')mu_gas  "
  write(ilun,format)"  write(ilun,'('ngrp        =',I11)')ngrp"
  write(ilun,format)"  write(ilun,'('nent        =',I11)')nent"
  write(ilun,format)"  write(ilun,'('npscal      =',I11)')npscal"
  write(ilun,format)"  write(ilun,'('nextinct    =',I11)')nextinct"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  write(ilun,'('kappa_abs    =',E23.15)')kappaAbs"
  write(ilun,format)"  write(ilun,'('group_egy    =',E23.15)')group_egy"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)""
  write(ilun,format)"  ! Write ordering information"
  write(ilun,format)"  write(ilun,'('ordering type=',A80)')ordering"
  write(ilun,format)"  if(ordering=='bisection') then"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        ! write 2*ndim floats for cpu bound box"
  write(ilun,format)"        write(ilun,'(E23.15)')bisec_cpubox_min(icpu,:),bisec_cpubox_max(icpu,:)"
  write(ilun,format)"        ! write 1 float for cpu load"
  write(ilun,format)"        write(ilun,'(E23.15)')dble(bisec_cpu_load(icpu))"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('   DOMAIN   ind_min                 ind_max')')"
  write(ilun,format)"     do idom=1,ndomain"
  write(ilun,format)"        write(ilun,'(I8,1X,E23.15,1X,E23.15)')idom,bound_key(idom-1),bound_key(idom)"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  write(ilun,*)"
  write(ilun,format)"  write(ilun,'('ir_cloud    =',I11)')ir_cloud"
  write(ilun,format)"  if(eos) then"
  write(ilun,format)"     write(ilun,'('eos         =',I11)')1"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('eos         =',I11)')0"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     write(ilun,'('write_cons  =',I11)')1"
  write(ilun,format)"  else"
  write(ilun,format)"     write(ilun,'('write_cons  =',I11)')0"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_info"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine output_header(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)""
  write(ilun,format)"  integer::ilun"
  write(ilun,format)"  integer(i8b)::npart_tot"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"#ifdef LONGINT"
  write(ilun,format)"  integer(i8b)::tmp_long"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering output_header'"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total number of particles"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart,npart_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  tmp_long=npart"
  write(ilun,format)"  call MPI_ALLREDUCE(tmp_long,npart_tot,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  npart_tot=npart"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)""
  write(ilun,format)"     ilun=myid+10"
  write(ilun,format)""
  write(ilun,format)"     ! Open file"
  write(ilun,format)"     fileloc=TRIM(filename)"
  write(ilun,format)"     open(unit=ilun,file=fileloc,form='formatted')"
  write(ilun,format)""
  write(ilun,format)"     ! Write header information"
  write(ilun,format)"     write(ilun,*)'Total number of particles'"
  write(ilun,format)"     write(ilun,*)npart_tot"
  write(ilun,format)"     write(ilun,*)'Total number of dark matter particles'"
  write(ilun,format)"     write(ilun,*)npart_tot-nstar_tot"
  write(ilun,format)"     write(ilun,*)'Total number of star particles'"
  write(ilun,format)"     write(ilun,*)nstar_tot"
  write(ilun,format)"     write(ilun,*)'Total number of sink particles'"
  write(ilun,format)"     write(ilun,*)nsink"
  write(ilun,format)""
  write(ilun,format)"     ! Keep track of what particle fields are present"
  write(ilun,format)"     write(ilun,*)'Particle fields'"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'pos vel mass iord level '"
  write(ilun,format)"#ifdef OUTPUT_PARTICLE_POTENTIAL"
  write(ilun,format)"     write(ilun,'(a)',advance='no')'phi '"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(star.or.sink) then"
  write(ilun,format)"        write(ilun,'(a)',advance='no')'tform '"
  write(ilun,format)"        if(metal) then"
  write(ilun,format)"           write(ilun,'(a)',advance='no')'metal '"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(tracer)then"
  write(ilun,format)"        write(ilun,'(a)',advance='no')'tracer_rho tracer_tg tracer_tr tracer_ext tracer_b'"
  write(ilun,format)"     endif"
  write(ilun,format)"     close(ilun)"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine output_header"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine savegadget(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use gadgetreadfilemod"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"  integer(i8b)::npart_loc"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  TYPE(gadgetheadertype)::header"
  write(ilun,format)"  real,allocatable,dimension(:,:)::pos,vel"
  write(ilun,format)"  integer(i8b),allocatable,dimension(:)::ids"
  write(ilun,format)"  integer::i,idim,ipart"
  write(ilun,format)"  real(dp)::gadgetvfact"
  write(ilun,format)"  integer(i8b)::npart_tot"
  write(ilun,format)"  real(dp),parameter::RHOcrit=2.7755d11"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  npart_loc=npart"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  call MPI_ALLREDUCE(npart_loc,npart_tot,1,MPI_INTEGER8,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#else"
  write(ilun,format)"  npart_tot=npart"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  allocate(pos(ndim, npart), vel(ndim, npart), ids(npart))"
  write(ilun,format)"  gadgetvfact = 100.0 * boxlen_ini / aexp / SQRT(aexp)"
  write(ilun,format)""
  write(ilun,format)"  header%npart = 0"
  write(ilun,format)"  header%npart(2) = npart"
  write(ilun,format)"  header%mass = 0"
  write(ilun,format)"  header%mass(2) = omega_m*RHOcrit*(boxlen_ini)**3/npart_tot/1.d10"
  write(ilun,format)"  header%time = aexp"
  write(ilun,format)"  header%redshift = 1.d0/aexp-1.d0"
  write(ilun,format)"  header%flag_sfr = 0"
  write(ilun,format)"  header%nparttotal = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%nparttotal(2) = npart_tot"
  write(ilun,format)"#else"
  write(ilun,format)"  header%nparttotal(2) = MOD(npart_tot,4294967296_i8b)"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_cooling = 0"
  write(ilun,format)"  header%numfiles = ncpu"
  write(ilun,format)"  header%boxsize = boxlen_ini"
  write(ilun,format)"  header%omega0 = omega_m"
  write(ilun,format)"  header%omegalambda = omega_l"
  write(ilun,format)"  header%hubbleparam = h0/100.0"
  write(ilun,format)"  header%flag_stellarage = 0"
  write(ilun,format)"  header%flag_metals = 0"
  write(ilun,format)"  header%totalhighword = 0"
  write(ilun,format)"#ifndef LONGINT"
  write(ilun,format)"  header%totalhighword(2) = 0"
  write(ilun,format)"#else"
  write(ilun,format)"  header%totalhighword(2) = npart_tot/4294967296_i8b"
  write(ilun,format)"#endif"
  write(ilun,format)"  header%flag_entropy_instead_u = 0"
  write(ilun,format)"  header%flag_doubleprecision = 0"
  write(ilun,format)"  header%flag_ic_info = 0"
  write(ilun,format)"  header%lpt_scalingfactor = 0"
  write(ilun,format)"  header%unused = ' '"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     ipart=0"
  write(ilun,format)"     do i=1,npartmax"
  write(ilun,format)"        if(levelp(i)>0)then"
  write(ilun,format)"           ipart=ipart+1"
  write(ilun,format)"           if (ipart .gt. npart) then"
  write(ilun,format)"                write(*,*) myid, 'Ipart=',ipart, 'exceeds', npart"
  write(ilun,format)"                call clean_stop"
  write(ilun,format)"           endif"
  write(ilun,format)"           pos(idim, ipart)=real(xp(i,idim) * boxlen_ini , kind=4)"
  write(ilun,format)"           vel(idim, ipart)=real(vp(i,idim) * gadgetvfact , kind=4)"
  write(ilun,format)"           if (idim.eq.1) ids(ipart) = idp(i)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call gadgetwritefile(filename, myid-1, header, pos, vel, ids)"
  write(ilun,format)"  deallocate(pos, vel, ids)"
  write(ilun,format)""
  write(ilun,format)"end subroutine savegadget"
  write(ilun,format)"../patch/irradiation/test_pascucci/output_hydro.f90"
  write(ilun,format)""
  write(ilun,format)"subroutine file_descriptor_hydro(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use cloud_module, only: rt_protostar_m1,rt_protostar_fld"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  integer::ivar,ilun,firstindex_frad"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering file_descriptor_hydro'"
  write(ilun,format)""
  write(ilun,format)"  ilun=11"
  write(ilun,format)""
  write(ilun,format)"  ! Open file"
  write(ilun,format)"  fileloc=TRIM(filename)"
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='formatted')"
  write(ilun,format)""
  write(ilun,format)"  ! Write run parameters"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  write(ilun,'('nvar        =',I11)')nvar+4+NGroups*(ndim+1)!+ndim !+ndim pour frad raph"
  write(ilun,format)"#else"
  write(ilun,format)"  write(ilun,'('nvar        =',I11)')nvar+4"
  write(ilun,format)"#endif  "
  write(ilun,format)"  ivar=1"
  write(ilun,format)"  write(ilun,'('variable #',I2,': density')')ivar"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     ivar=2"
  write(ilun,format)"     write(ilun,'('variable #',I2,': momentum_x')')ivar"
  write(ilun,format)"     ivar=3"
  write(ilun,format)"     write(ilun,'('variable #',I2,': momentum_y')')ivar"
  write(ilun,format)"     ivar=4"
  write(ilun,format)"     write(ilun,'('variable #',I2,': momentum_z')')ivar"
  write(ilun,format)"  else"
  write(ilun,format)"     ivar=2"
  write(ilun,format)"     write(ilun,'('variable #',I2,': velocity_x')')ivar"
  write(ilun,format)"     ivar=3"
  write(ilun,format)"     write(ilun,'('variable #',I2,': velocity_y')')ivar"
  write(ilun,format)"     ivar=4"
  write(ilun,format)"     write(ilun,'('variable #',I2,': velocity_z')')ivar"
  write(ilun,format)"  endif"
  write(ilun,format)"  ivar=5"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_left_x')')ivar"
  write(ilun,format)"  ivar=6"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_left_y')')ivar"
  write(ilun,format)"  ivar=7"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_left_z')')ivar"
  write(ilun,format)"  ivar=8"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_right_x')')ivar"
  write(ilun,format)"  ivar=9"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_right_y')')ivar"
  write(ilun,format)"  ivar=10"
  write(ilun,format)"  write(ilun,'('variable #',I2,': B_right_z')')ivar"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"#if NCR>0  "
  write(ilun,format)"     ! CR energies"
  write(ilun,format)"     do ivar=1,ncr"
  write(ilun,format)"        write(ilun,'('variable #',I2,': cosmic_rays_energy_',I1)')10+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     ! Non-thermal energies"
  write(ilun,format)"     do ivar=1+ncr,nent"
  write(ilun,format)"        write(ilun,'('variable #',I2,': non_thermal_energy_',I1)')10+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"#if NCR>0"
  write(ilun,format)"     ! CR pressures"
  write(ilun,format)"     do ivar=1,ncr"
  write(ilun,format)"        write(ilun,'('variable #',I2,': cosmic_rays_pressure_',I1)')10+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"     ! Non-thermal pressures"
  write(ilun,format)"     do ivar=1+ncr,nent"
  write(ilun,format)"        write(ilun,'('variable #',I2,': non_thermal_pressure_',I1)')10+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     ivar=11+nent"
  write(ilun,format)"     write(ilun,'('variable #',I2,': total_energy')')ivar"
  write(ilun,format)"  else"
  write(ilun,format)"     ivar=11+nent"
  write(ilun,format)"     write(ilun,'('variable #',I2,': thermal_pressure')')ivar"
  write(ilun,format)"  endif"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"  ! Radiative energies"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     write(ilun,'('variable #',I2,': radiative_energy_',I1)')firstindex_er+3+ivar,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  ! Radiative fluxes"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     write(ilun,'('variable #',I2,': radiative_flux_x',I1)')firstindex_fr+3       +ivar,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)"if(ndim>1) then"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     write(ilun,'('variable #',I2,': radiative_flux_y',I1)')firstindex_fr+3+  ngrp+ivar,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)"endif"
  write(ilun,format)"if(ndim>2) then"
  write(ilun,format)"  do ivar=1,ngrp"
  write(ilun,format)"     write(ilun,'('variable #',I2,': radiative_flux_z',I1)')firstindex_fr+3+2*ngrp+ivar,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)"endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NEXTINCT>0"
  write(ilun,format)"  ! Extinction"
  write(ilun,format)"  do ivar=1,nextinct"
  write(ilun,format)"     write(ilun,'('variable #',I2,': extinction',I1)')firstindex_extinct+3+ivar,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NPSCAL>0"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  ! Passive scalars excluding current and internal energy"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     do ivar=1,npscal-4"
  write(ilun,format)"        write(ilun,'('variable #',I2,': passive_scalar_cons_',I1)')firstindex_pscal+3+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     do ivar=1,npscal-4"
  write(ilun,format)"        write(ilun,'('variable #',I2,': passive_scalar_',I1)')firstindex_pscal+3+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)"  ivar=npscal-3"
  write(ilun,format)"  write(ilun,'('variable #',I2,': current_x')')firstindex_pscal+3+ivar"
  write(ilun,format)"  ivar=npscal-2"
  write(ilun,format)"  write(ilun,'('variable #',I2,': current_y')')firstindex_pscal+3+ivar"
  write(ilun,format)"  ivar=npscal-1"
  write(ilun,format)"  write(ilun,'('variable #',I2,': current_z')')firstindex_pscal+3+ivar"
  write(ilun,format)"#else"
  write(ilun,format)"  ! Passive scalars excluding internal energy"
  write(ilun,format)"  if(write_conservative) then"
  write(ilun,format)"     do ivar=1,npscal-1"
  write(ilun,format)"        write(ilun,'('variable #',I2,': passive_scalar_cons_',I1)')firstindex_pscal+3+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     do ivar=1,npscal-1"
  write(ilun,format)"        write(ilun,'('variable #',I2,': passive_scalar_',I1)')firstindex_pscal+3+ivar,ivar"
  write(ilun,format)"     end do"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  ivar=npscal"
  write(ilun,format)"  write(ilun,'('variable #',I2,': internal_energy')')firstindex_pscal+3+ivar"
  write(ilun,format)"#endif"
  write(ilun,format)"  ! Temperature"
  write(ilun,format)"  ivar=firstindex_pscal+3+npscal+1"
  write(ilun,format)"  write(ilun,'('variable #',I2,': temperature')')ivar"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  do ivar=1,nGroups"
  write(ilun,format)"     write(ilun,'('variable #',I2,': photon_number_flux_',I1)')nvar+4+ivar,ivar"
  write(ilun,format)"     write(ilun,'('variable #',I2,': photon_number_xflux_',I1)')nvar+4+ivar+1,ivar"
  write(ilun,format)"     write(ilun,'('variable #',I2,': photon_number_yflux_',I1)')nvar+4+ivar+2,ivar"
  write(ilun,format)"     write(ilun,'('variable #',I2,': photon_number_zflux_',I1)')nvar+4+ivar+3,ivar"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !raph pour force radiative"
  write(ilun,format)"  !if (rt_protostar_m1==.true. .and. rt_protostar_fld==.false.) then"
  write(ilun,format)"  !   firstindex_frad = nvar + 8"
  write(ilun,format)"  !elseif (rt_protostar_m1==.false. .and. rt_protostar_fld==.true.) then"
  write(ilun,format)"  !   firstindex_frad = nvar"
  write(ilun,format)"  !endif"
  write(ilun,format)""
  write(ilun,format)"  !ivar = 1"
  write(ilun,format)"  !write(ilun,'('variable #',I2,': frad_x',I1)')firstindex_frad+ivar!,ivar should not be here, take example on velocity"
  write(ilun,format)"  !ivar = 2"
  write(ilun,format)"  !write(ilun,'('variable #',I2,': frad_y',I1)')firstindex_frad+ivar"
  write(ilun,format)"  !ivar = 3"
  write(ilun,format)"  !write(ilun,'('variable #',I2,': frad_z',I1)')firstindex_frad+ivar"
  write(ilun,format)"  !raph pour force radiative"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  close(ilun)"
  write(ilun,format)""
  write(ilun,format)"end subroutine file_descriptor_hydro"
  write(ilun,format)""
  write(ilun,format)"subroutine backup_hydro(filename)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"!  use radiation_parameters, only: frad !raph pour  force rad fld"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::dummy_io,info2"
  write(ilun,format)"#endif"
  write(ilun,format)"  character(LEN=80)::filename"
  write(ilun,format)"  integer::i,ivar,ncache,ind,ilevel,igrid,iskip,ilun,istart,ibound,ht,idim"
  write(ilun,format)"  real(dp)::d,u,v,w,A,B,C,e"
  write(ilun,format)"  integer,allocatable,dimension(:)::ind_grid"
  write(ilun,format)"  real(dp)::cmp_temp,p"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::xdp"
  write(ilun,format)"  character(LEN=5)::nchar"
  write(ilun,format)"  character(LEN=80)::fileloc"
  write(ilun,format)"  integer,parameter::tag=1121"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering backup_hydro'"
  write(ilun,format)""
  write(ilun,format)"  ilun=ncpu+myid+10"
  write(ilun,format)""
  write(ilun,format)"  call title(myid,nchar)"
  write(ilun,format)"  fileloc=TRIM(filename)//TRIM(nchar)"
  write(ilun,format)""
  write(ilun,format)"  ! Wait for the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if (mod(myid-1,IOGROUPSIZE)/=0) then"
  write(ilun,format)"        call MPI_RECV(dummy_io,1,MPI_INTEGER,myid-1-1,tag,&"
  write(ilun,format)"             & MPI_COMM_WORLD,MPI_STATUS_IGNORE,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  open(unit=ilun,file=fileloc,form='unformatted')"
  write(ilun,format)"  write(ilun)ncpu"
  write(ilun,format)"!   if(eos) then "
  write(ilun,format)"!      write(ilun)nvar+3+1"
  write(ilun,format)"!   else"
  write(ilun,format)"!      write(ilun)nvar+3"
  write(ilun,format)"!   endif"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  write(ilun)nvar+4+NGroups*(ndim+1)!+ndim !+ndim raph pour frad"
  write(ilun,format)"#else"
  write(ilun,format)"  write(ilun)nvar+4 !+ndim raph pour frad FLD only? No because RT=1 even with FLD"
  write(ilun,format)"#endif"
  write(ilun,format)"  write(ilun)ndim"
  write(ilun,format)"  write(ilun)nlevelmax"
  write(ilun,format)"  write(ilun)nboundary"
  write(ilun,format)"  write(ilun)gamma"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     do ibound=1,nboundary+ncpu"
  write(ilun,format)"        if(ibound<=ncpu)then"
  write(ilun,format)"           ncache=numbl(ibound,ilevel)"
  write(ilun,format)"           istart=headl(ibound,ilevel)"
  write(ilun,format)"        else"
  write(ilun,format)"           ncache=numbb(ibound-ncpu,ilevel)"
  write(ilun,format)"           istart=headb(ibound-ncpu,ilevel)"
  write(ilun,format)"        end if"
  write(ilun,format)"        write(ilun)ilevel"
  write(ilun,format)"        write(ilun)ncache"
  write(ilun,format)"        if(ncache>0)then"
  write(ilun,format)"           allocate(ind_grid(1:ncache),xdp(1:ncache))"
  write(ilun,format)"           ! Loop over level grids"
  write(ilun,format)"           igrid=istart"
  write(ilun,format)"           do i=1,ncache"
  write(ilun,format)"              ind_grid(i)=igrid"
  write(ilun,format)"              igrid=next(igrid)"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! Loop over cells"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do ivar=1,4"
  write(ilun,format)"                 if(ivar==1)then ! Write density"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else ! Write velocity field"
  write(ilun,format)"                    if(write_conservative) then"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          xdp(i)=uold(ind_grid(i)+iskip,ivar)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    else"
  write(ilun,format)"                       do i=1,ncache"
  write(ilun,format)"                          xdp(i)=uold(ind_grid(i)+iskip,ivar)/max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                       end do"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)"              do ivar=6,8 ! Write left B field"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)"              do ivar=nvar+1,nvar+3 ! Write right B field"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"              ! Write non-thermal pressures"
  write(ilun,format)"              if(write_conservative) then"
  write(ilun,format)"                 do ivar=1,nent"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,8+ivar)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              else"
  write(ilun,format)"                 do ivar=1,nent"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=(gamma_rad(ivar)-1d0)*uold(ind_grid(i)+iskip,8+ivar)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)"#endif"
  write(ilun,format)"              if(write_conservative) then"
  write(ilun,format)"                 do i=1,ncache ! Write total energy"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,5)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              else"
  write(ilun,format)"                 do i=1,ncache ! Write thermal pressure"
  write(ilun,format)"                    d=max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                    u=uold(ind_grid(i)+iskip,2)/d"
  write(ilun,format)"                    v=uold(ind_grid(i)+iskip,3)/d"
  write(ilun,format)"                    w=uold(ind_grid(i)+iskip,4)/d"
  write(ilun,format)"                    A=0.5*(uold(ind_grid(i)+iskip,6)+uold(ind_grid(i)+iskip,nvar+1))"
  write(ilun,format)"                    B=0.5*(uold(ind_grid(i)+iskip,7)+uold(ind_grid(i)+iskip,nvar+2))"
  write(ilun,format)"                    C=0.5*(uold(ind_grid(i)+iskip,8)+uold(ind_grid(i)+iskip,nvar+3))"
  write(ilun,format)"                    e=uold(ind_grid(i)+iskip,5)-0.5*d*(u**2+v**2+w**2)-0.5*(A**2+B**2+C**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"                    do irad=1,nener"
  write(ilun,format)"                       e=e-uold(ind_grid(i)+iskip,8+irad)"
  write(ilun,format)"                    end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                    call pressure_eos(d,e,p)"
  write(ilun,format)"                    xdp(i)=p"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"              do ivar=1,ngrp ! Write radiative energy if any"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,firstindex_er+ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"              do ivar=1,nfr ! Write radiative flux if any"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,firstindex_fr+ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NEXTINCT>0"
  write(ilun,format)"              ! Write extinction if activated"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 xdp(i)=uold(ind_grid(i)+iskip,firstindex_extinct+1)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NPSCAL>0"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"              if(write_conservative) then"
  write(ilun,format)"                 do ivar=1,npscal-4 ! Write conservative passive scalars if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+ivar)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              else"
  write(ilun,format)"                 do ivar=1,npscal-4 ! Write passive scalars if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+ivar)/max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              do ivar=npscal-3,npscal-1 ! Write current"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+ivar)"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"#else"
  write(ilun,format)"              if(write_conservative) then"
  write(ilun,format)"                 do ivar=1,npscal-1 ! Write conservative passive scalars if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+ivar)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              else"
  write(ilun,format)"                 do ivar=1,npscal-1 ! Write passive scalars if any"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+ivar)/max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 end do"
  write(ilun,format)"              endif"
  write(ilun,format)"#endif"
  write(ilun,format)"              "
  write(ilun,format)"              ! Write internal energy"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 xdp(i)=uold(ind_grid(i)+iskip,firstindex_pscal+npscal)"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"              "
  write(ilun,format)"#endif"
  write(ilun,format)"              "
  write(ilun,format)"              ! Write temperature"
  write(ilun,format)"              do i=1,ncache"
  write(ilun,format)"                 d=max(uold(ind_grid(i)+iskip,1),smallr)"
  write(ilun,format)"                 if(energy_fix) then"
  write(ilun,format)"                    e=uold(ind_grid(i)+iskip,nvar)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    u=uold(ind_grid(i)+iskip,2)/d"
  write(ilun,format)"                    v=uold(ind_grid(i)+iskip,3)/d"
  write(ilun,format)"                    w=uold(ind_grid(i)+iskip,4)/d"
  write(ilun,format)"                    A=0.5*(uold(ind_grid(i)+iskip,6)+uold(ind_grid(i)+iskip,nvar+1))"
  write(ilun,format)"                    B=0.5*(uold(ind_grid(i)+iskip,7)+uold(ind_grid(i)+iskip,nvar+2))"
  write(ilun,format)"                    C=0.5*(uold(ind_grid(i)+iskip,8)+uold(ind_grid(i)+iskip,nvar+3))"
  write(ilun,format)"                    e=uold(ind_grid(i)+iskip,5)-0.5*d*(u**2+v**2+w**2)-0.5*(A**2+B**2+C**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"                    do irad=1,nener"
  write(ilun,format)"                       e=e-uold(ind_grid(i)+iskip,8+irad)"
  write(ilun,format)"                    end do"
  write(ilun,format)"#endif"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 call temperature_eos(d,e,cmp_temp,ht)"
  write(ilun,format)"                 xdp(i)=cmp_temp"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(ilun)xdp"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"              do ivar=1,nGroups"
  write(ilun,format)"                 ! Store photon density in flux units"
  write(ilun,format)"                 do i=1,ncache"
  write(ilun,format)"                    xdp(i)=rt_c*rtuold(ind_grid(i)+iskip,iGroups(ivar))"
  write(ilun,format)"                 end do"
  write(ilun,format)"                 write(ilun)xdp"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    ! Store photon flux"
  write(ilun,format)"                    do i=1,ncache"
  write(ilun,format)"                       xdp(i)=rtuold(ind_grid(i)+iskip,iGroups(ivar)+idim)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    write(ilun)xdp"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              !raph force rad fld"
  write(ilun,format)"              !do idim=1,ndim"
  write(ilun,format)"              !   do i=1,ncache"
  write(ilun,format)"              !      xdp(i) = frad(ind_grid(i)+iskip, idim)"
  write(ilun,format)"              !   enddo"
  write(ilun,format)"              !   write(ilun)xdp"
  write(ilun,format)"              !enddo"
  write(ilun,format)"              !raph"
  write(ilun,format)""
  write(ilun,format)"           end do"
  write(ilun,format)"           deallocate(ind_grid, xdp)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  close(ilun)"
  write(ilun,format)"  ! Send the token"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  if(IOGROUPSIZE>0) then"
  write(ilun,format)"     if(mod(myid,IOGROUPSIZE)/=0 .and.(myid.lt.ncpu))then"
  write(ilun,format)"        dummy_io=1"
  write(ilun,format)"        call MPI_SEND(dummy_io,1,MPI_INTEGER,myid-1+1,tag, &"
  write(ilun,format)"             & MPI_COMM_WORLD,info2)"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine backup_hydro"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"../patch/irradiation/test_pascucci/pm_parameters.f90"
  write(ilun,format)"module pm_parameters"
  write(ilun,format)"  use amr_parameters, ONLY: dp"
  write(ilun,format)"  integer::nsinkmax=20000           ! Maximum number of sinks"
  write(ilun,format)"  integer::npartmax=0               ! Maximum number of particles"
  write(ilun,format)"  integer::npart=0                  ! Actual number of particles"
  write(ilun,format)"  integer::nsink=0                  ! Actual number of sinks"
  write(ilun,format)"  integer::iseed=0                  ! Seed for stochastic star formation"
  write(ilun,format)"  integer::nstar_tot=0              ! Total number of star particle"
  write(ilun,format)"  real(dp)::mstar_tot=0             ! Total star mass"
  write(ilun,format)"  real(dp)::mstar_lost=0            ! Missing star mass"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! More sink related parameters, can all be set in namelist file"
  write(ilun,format)""
  write(ilun,format)"  integer::ir_cloud=1!4                        ! Radius of cloud region in unit of grid spacing (i.e. the ACCRETION RADIUS)"
  write(ilun,format)"  integer::ir_cloud_massive=3                ! Radius of massive cloud region in unit of grid spacing for PM sinks"
  write(ilun,format)"  real(dp)::sink_soft=2.d0                   ! Sink grav softening length in dx at levelmax for 'direct force' sinks"
  write(ilun,format)"  real(dp)::mass_sink_direct_force=-1.d0     ! mass above which sinks are treated as 'direct force' objects"
  write(ilun,format)""
  write(ilun,format)"  logical::create_sinks=.false.              ! turn formation of new sinks on"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::merging_timescale=-1.d0          ! time during which sinks are considered for merging (only when 'timescale' is used),                                             ! used also as contraction timescale in creation"
  write(ilun,format)"  real(dp)::cont_speed=0."
  write(ilun,format)""
  write(ilun,format)"  character(LEN=15)::accretion_scheme='none' ! Sink accretion scheme; options: 'none', 'flux', 'bondi', 'threshold'"
  write(ilun,format)"  logical::flux_accretion=.false."
  write(ilun,format)"  logical::threshold_accretion=.false."
  write(ilun,format)"  logical::bondi_accretion=.false."
  write(ilun,format)"  logical::jeans_accretion=.false. ! Warning: needs accretion_scheme='threshold'"
  write(ilun,format)""
  write(ilun,format)"  logical::nol_accretion=.false.             ! Leave angular momentum in the gas at accretion"
  write(ilun,format)"  real(dp)::mass_sink_seed=0.0               ! Initial sink mass. If < 0, use the AGN feedback based recipe"
  write(ilun,format)"  real(dp)::c_acc=-1.0                       ! 'courant factor' for sink accretion time step control."
  write(ilun,format)"                                             ! gives fration of available gas that can be accreted in one timestep."
  write(ilun,format)""
  write(ilun,format)"  logical::eddington_limit=.false.           ! Switch for Eddington limit for the smbh case"
  write(ilun,format)"  logical::sink_drag=.false.                 ! Gas dragging sink"
  write(ilun,format)"  logical::clump_core=.false.                ! Trims the clump (for star formation)"
  write(ilun,format)"  logical::verbose_AGN=.false.               ! Controls print verbosity for the SMBH case"
  write(ilun,format)"  real(dp)::acc_sink_boost=1.0               ! Boost coefficient for accretion"
  write(ilun,format)"  real(dp)::mass_merger_vel_check_AGN=0.0    ! Threshold for velocity check in  merging; in Msun; default: always check"
  write(ilun,format)""
  write(ilun,format)"  character(LEN=15)::feedback_scheme='energy' ! AGN feedback scheme; options: 'energy' or 'momentum'"
  write(ilun,format)"  real(dp)::T2_min=1.d7                      ! Minimum temperature of the gas to trigger AGN blast; in K"
  write(ilun,format)"  real(dp)::T2_max=1.d9                      ! Maximum allowed temperature of the AGN blast; in K"
  write(ilun,format)"  real(dp)::T2_AGN=1.d12                     ! AGN blast temperature; in K"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::v_max=5.d4                       ! Maximum allowed velocity of the AGN blast; in km/s"
  write(ilun,format)"  real(dp)::v_AGN=1.d4                       ! AGN blast velocity; in km/s"
  write(ilun,format)"  real(dp)::cone_opening=180.                ! Outflow cone opening angle; in deg"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::mass_halo_AGN=1.d10              ! Minimum mass of the halo for sink creation"
  write(ilun,format)"  real(dp)::mass_clump_AGN=1.d10             ! Minimum mass of the clump for sink creation"
  write(ilun,format)""
  write(ilun,format)"end module pm_parameters"
  write(ilun,format)"../patch/irradiation/test_pascucci/radiation_boundary.f90"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  integer,intent(IN)::ilevel,igroup"
  write(ilun,format)"  integer::ibound,boundary_dir,idim,inbor"
  write(ilun,format)"  integer::i,ncache,ivar,igrid,ngrid,ind,ht"
  write(ilun,format)"  integer::iskip,iskip_ref,nx_loc,ix,iy,iz,igrp"
  write(ilun,format)"  integer,dimension(1:8)::ind_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp)::rosseland_ana"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::uu"
  write(ilun,format)"  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho"
  write(ilun,format)""
  write(ilun,format)"  if(.not. simple_boundary)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over boundaries"
  write(ilun,format)"  do ibound=1,nboundary"
  write(ilun,format)"     ! Compute direction of reference neighbors"
  write(ilun,format)"     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)"
  write(ilun,format)"     if(boundary_dir==1)inbor=2"
  write(ilun,format)""
  write(ilun,format)"     if(boundary_dir==2)inbor=1"
  write(ilun,format)"     if(boundary_dir==3)inbor=4"
  write(ilun,format)"     if(boundary_dir==4)inbor=3"
  write(ilun,format)"     if(boundary_dir==5)inbor=6"
  write(ilun,format)"     if(boundary_dir==6)inbor=5"
  write(ilun,format)""
  write(ilun,format)"     ! Compute index of reference cells"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)"     ! Imposed boundary"
  write(ilun,format)"     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     ncache=boundary(ibound,ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Gather neighboring reference grid"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather neighboring reference cell"
  write(ilun,format)"           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"!!            ! Zero flux boundary conditions"
  write(ilun,format)"!!            if((boundary_type(ibound)/10).ne.2)then"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Gather reference variables and  scatter to boundary region"
  write(ilun,format)"!!               do i=1,ngrid"
  write(ilun,format)"!!                  if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"!!                     uold(ind_cell(i),8+igroup)  = uold(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     unew(ind_cell(i),8+igroup)  = unew(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     unew(ind_cell(i),5)     = unew(ind_cell_ref(i),5)"
  write(ilun,format)"!!                     unew(ind_cell(i),nvar+3)= unew(ind_cell_ref(i),5)"
  write(ilun,format)"!!                     enew(ind_cell(i))       = unew(ind_cell_ref(i),8+igroup)"
  write(ilun,format)"!!                     divu(ind_cell(i))       = divu(ind_cell_ref(i))"
  write(ilun,format)"!!                     unew(ind_cell(i),2)     = unew(ind_cell_ref(i),2)"
  write(ilun,format)"!!                  end if"
  write(ilun,format)"!!               end do"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Imposed boundary conditions"
  write(ilun,format)"!!            else"
  write(ilun,format)""
  write(ilun,format)"              ! Compute cell center in code units and rescale position from code units to user units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"              "
  write(ilun,format)"              call boundana(xx,uu,dx_loc,ibound,ngrid)"
  write(ilun,format)"              "
  write(ilun,format)"              ! Scatter variables"
  write(ilun,format)"              do i=1,ngrid "
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                    dd=max(uu(i,1),smallr)"
  write(ilun,format)"                    "
  write(ilun,format)"                    usquare=0.0_dp"
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)"                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total magnetic energy"
  write(ilun,format)"                    emag = 0.0_dp"
  write(ilun,format)"                    do ivar=1,3"
  write(ilun,format)"                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total non-thermal+radiative energy"
  write(ilun,format)"                    erad_loc=0.0_dp"
  write(ilun,format)"                    do igrp=1,nener"
  write(ilun,format)"                       erad_loc=erad_loc+uu(i,8+igrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    rho   = uu(i,1)"
  write(ilun,format)"                    ekin  = rho*usquare*0.5_dp"
  write(ilun,format)"                    eps   = (uu(i,5)-ekin-emag-erad_loc)"
  write(ilun,format)""
  write(ilun,format)"                    call temperature_eos(rho,eps,t2,ht)"
  write(ilun,format)"                    t2    = Tr_floor ! comment this for radiative shock"
  write(ilun,format)""
  write(ilun,format)"                    unew(ind_cell(i),nvar+3) = t2"
  write(ilun,format)"                    unew(ind_cell(i),5)      = t2"
  write(ilun,format)"                    "
  write(ilun,format)"                    uold(ind_cell(i),firstindex_er+igroup)= uu(i,firstindex_er+igroup)*scale_d*scale_v**2/(scale_E0)"
  write(ilun,format)"                    unew(ind_cell(i),firstindex_er+igroup)= uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)"                    enew(ind_cell(i)         )= uold(ind_cell(i),firstindex_er+igroup)"
  write(ilun,format)"                    unew(ind_cell(i),2       )= 0.0_dp"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! Compute Rosseland opacity"
  write(ilun,format)"                    t2r = cal_Teg(unew(ind_cell(i),firstindex_er+igroup)*scale_E0,igroup)"
  write(ilun,format)"                    divu(ind_cell(i))= rosseland_ana(dd*scale_d,t2,t2r,igroup)/scale_kappa"
  write(ilun,format)"                    if(divu(ind_cell(i))*dx_loc .lt. min_optical_depth) divu(ind_cell(i))=min_optical_depth/dx_loc"
  write(ilun,format)"                    "
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"!!            end if"
  write(ilun,format)"              "
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"           "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over boundaries"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"111 format('   Entering make_boundary_diffusion for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_boundary_diffusion"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"  use amr_commons,only:boundary,son,ncoarse,nbor,xg"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  ! This routine set up boundary conditions for fine levels."
  write(ilun,format)"  ! -------------------------------------------------------------------"
  write(ilun,format)"  integer,intent(IN)::ilevel"
  write(ilun,format)"  integer::ibound,boundary_dir,idim,inbor,igroup,ht"
  write(ilun,format)"  integer::i,ncache,ivar,igrid,ngrid,ind"
  write(ilun,format)"  integer::iskip,iskip_ref,gdim,nx_loc,ix,iy,iz,igrp,irad"
  write(ilun,format)"  integer,dimension(1:8)::ind_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_grid,ind_grid_ref"
  write(ilun,format)"  integer,dimension(1:nvector),save::ind_cell,ind_cell_ref"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp)::rosseland_ana"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nvar+3),save::uu"
  write(ilun,format)"  real(dp),dimension(1:nvector)::cond,relax"
  write(ilun,format)"  real(dp)::dd,t2,t2r,cal_Teg,usquare,emag,erad_loc,eps,ekin,Cv,rho"
  write(ilun,format)""
  write(ilun,format)"  if(.not. simple_boundary)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/zero,zero,zero/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-half)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-half)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-half)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over boundaries"
  write(ilun,format)"  do ibound=1,nboundary"
  write(ilun,format)"     ! Compute direction of reference neighbors"
  write(ilun,format)"     boundary_dir=boundary_type(ibound)-10*(boundary_type(ibound)/10)"
  write(ilun,format)"     if(boundary_dir==1)inbor=2"
  write(ilun,format)""
  write(ilun,format)"     if(boundary_dir==2)inbor=1"
  write(ilun,format)"     if(boundary_dir==3)inbor=4"
  write(ilun,format)"     if(boundary_dir==4)inbor=3"
  write(ilun,format)"     if(boundary_dir==5)inbor=6"
  write(ilun,format)"     if(boundary_dir==6)inbor=5"
  write(ilun,format)""
  write(ilun,format)"     ! Compute index of reference cells"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)== 1)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 2)ind_ref(1:8)=(/2,1,4,3,6,5,8,7/)"
  write(ilun,format)"     if(boundary_type(ibound)== 3)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 4)ind_ref(1:8)=(/3,4,1,2,7,8,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)== 5)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)== 6)ind_ref(1:8)=(/5,6,7,8,1,2,3,4/)"
  write(ilun,format)"     ! Zero flux"
  write(ilun,format)"     if(boundary_type(ibound)==11)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==12)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==13)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==14)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==15)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==16)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)"     ! Imposed boundary"
  write(ilun,format)"     if(boundary_type(ibound)==21)ind_ref(1:8)=(/1,1,3,3,5,5,7,7/)"
  write(ilun,format)"     if(boundary_type(ibound)==22)ind_ref(1:8)=(/2,2,4,4,6,6,8,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==23)ind_ref(1:8)=(/1,2,1,2,5,6,5,6/)"
  write(ilun,format)"     if(boundary_type(ibound)==24)ind_ref(1:8)=(/3,4,3,4,7,8,7,8/)"
  write(ilun,format)"     if(boundary_type(ibound)==25)ind_ref(1:8)=(/1,2,3,4,1,2,3,4/)"
  write(ilun,format)"     if(boundary_type(ibound)==26)ind_ref(1:8)=(/5,6,7,8,5,6,7,8/)"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over grids by vector sweeps"
  write(ilun,format)"     ncache=boundary(ibound,ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=boundary(ibound,ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Gather neighboring reference grid"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid_ref(i)=son(nbor(ind_grid(i),inbor))"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather neighboring reference cell"
  write(ilun,format)"           iskip_ref=ncoarse+(ind_ref(ind)-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell_ref(i)=iskip_ref+ind_grid_ref(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"!!            ! Zero flux boundary conditions"
  write(ilun,format)"!!            if((boundary_type(ibound)/10).ne.2)then"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Gather reference variables and  scatter to boundary region"
  write(ilun,format)"!!               do i=1,ngrid"
  write(ilun,format)"!!                  if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"!! #if USE_FLD==1"
  write(ilun,format)"!!                     do igroup=1,ngrp"
  write(ilun,format)"!!                        kappaR_bicg(ind_cell(i),igroup)       = kappaR_bicg(ind_cell_ref(i),igroup)"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!! #endif"
  write(ilun,format)"!!                     do irad=1,nvar_trad"
  write(ilun,format)"!!                        unew    (ind_cell(i),ind_trad(irad)) = unew    (ind_cell_ref(i),ind_trad(irad))"
  write(ilun,format)"!!                        uold    (ind_cell(i),ind_trad(irad)) = uold    (ind_cell_ref(i),ind_trad(irad))"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!!                     do irad = 1,nvar_bicg"
  write(ilun,format)"!!                        if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = var_bicg(ind_cell_ref(i),irad, 2)"
  write(ilun,format)"!!                        var_bicg(ind_cell(i),irad, 5) = var_bicg(ind_cell_ref(i),irad, 5)"
  write(ilun,format)"!!                        if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = var_bicg(ind_cell_ref(i),irad, 6)"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  end if"
  write(ilun,format)"!!               end do"
  write(ilun,format)"!! "
  write(ilun,format)"!!               ! Imposed boundary conditions"
  write(ilun,format)"!!            else"
  write(ilun,format)""
  write(ilun,format)"              ! Compute cell center in code units and rescale position from code units to user units"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                       xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              call boundana(xx,uu,dx_loc,ibound,ngrid)"
  write(ilun,format)""
  write(ilun,format)"              ! Scatter variables"
  write(ilun,format)"              do i=1,ngrid "
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)"                    dd=max(uu(i,1),smallr)"
  write(ilun,format)""
  write(ilun,format)"                    usquare=zero"
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)"                       usquare=usquare+(uu(i,idim+1)/uu(i,1))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total magnetic energy"
  write(ilun,format)"                    emag = zero"
  write(ilun,format)"                    do ivar=1,3"
  write(ilun,format)"                       emag = emag + 0.125_dp*(uu(i,5+ivar) + uu(i,nvar+ivar))**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    ! Compute total non-thermal+radiative energy"
  write(ilun,format)"                    erad_loc=zero"
  write(ilun,format)"                    do igrp=1,nener"
  write(ilun,format)"                       erad_loc=erad_loc+uu(i,8+igrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    rho   = uu(i,1)"
  write(ilun,format)"                    ekin  = rho*usquare*half"
  write(ilun,format)"                    eps   = (uu(i,5)-ekin-emag-erad_loc)"
  write(ilun,format)""
  write(ilun,format)"                    call temperature_eos(rho,eps,t2,ht)"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"                    uu(i,ind_trad(1)) = t2"
  write(ilun,format)"                    uu(i,ind_trad(1)) = Tr_floor ! comment this for radiative shock"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                    ! Compute Rosseland opacity"
  write(ilun,format)"                    do igroup=1,ngrp"
  write(ilun,format)"                       t2r = cal_Teg(uu(i,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"                       kappaR_bicg(ind_cell(i),igroup)= rosseland_ana(dd*scale_d,uu(i,ind_trad(1)),t2r,igroup)/scale_kappa"
  write(ilun,format)"                       if( kappaR_bicg(ind_cell(i),igroup)*dx_loc .lt. min_optical_depth)  kappaR_bicg(ind_cell(i),igroup)=min_optical_depth/dx_loc"
  write(ilun,format)"                    enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"                    do irad=1,nvar_trad"
  write(ilun,format)"                       uold(ind_cell(i),ind_trad(irad)) = uu(i,ind_trad(irad)) / norm_trad(irad)"
  write(ilun,format)"                       unew(ind_cell(i),ind_trad(irad)) = uold(ind_cell(i),ind_trad(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                   do irad = 1,nvar_bicg"
  write(ilun,format)"                      if(bicg_to_cg) var_bicg(ind_cell(i),irad, 2) = zero"
  write(ilun,format)"                      var_bicg(ind_cell(i),irad, 5) = zero"
  write(ilun,format)"                      if(.not.bicg_to_cg) var_bicg(ind_cell(i),irad, 6) = zero"
  write(ilun,format)"                   enddo"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"!!            end if"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over boundaries"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering make_boundary_diffusion for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_boundary_diffusion_tot"
  write(ilun,format)"../patch/irradiation/test_pascucci/radiation_parameters.f90"
  write(ilun,format)"module radiation_parameters"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use hydro_parameters,only:ngrp,nvar_bicg,nvar_trad"
  write(ilun,format)""
  write(ilun,format)"  ! DT adaptatif"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::rad_flux ! Flux entrant dans une cellule"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::urad     ! Old values of Erg in NR iterations"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::frad     ! Radiative force  "
  write(ilun,format)"  real(dp)::Tr_floor=10.0 ! Background radiation field temperature - WARNING: it affects the pressure_fix in set_uold."
  write(ilun,format)"  integer::ntp,nfr"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: alpha_imp = 1.0d0	!0.0:explicite 0.5:CN 1.0:implicite"
  write(ilun,format)"  real(dp):: robin = 1.0d0	!0.0:Von Neumann 1.0:Dirichlet"
  write(ilun,format)""
  write(ilun,format)"  ! Multigroup"
  write(ilun,format)"  integer,parameter::Nomega=100     ! Number of points in the omega data to compute Q moment term"
  write(ilun,format)""
  write(ilun,format)"  real(dp),parameter:: aR=7.56591469318689378e-015_dp"
  write(ilun,format)"  real(dp),parameter::Tray_min=0.5d0 ! Minimum temperature in the radiative energy"
  write(ilun,format)"  real(dp),parameter:: eray_min=(aR)*Tray_min**4 ! minimum rad energy inside frequency group"
  write(ilun,format)"  real(dp),parameter:: deray_min=(4.0d0*aR)*Tray_min**3 ! minimum rad energy derivative inside frequency group"
  write(ilun,format)"  real(dp):: small_er=1.0d-30       ! minimum rad energy inside frequency group in code units"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp) :: numin=1.0d5,numax=1.0d19 ! Overall frequency boudaries"
  write(ilun,format)"  real(dp) :: frequency_upperlimit=1.0d35 ! High end frequency if 'extra_end_group = .true."
  write(ilun,format)""
  write(ilun,format)"  integer::Ninv_art4=1000                               ! Number of points in tabulated arT4 function"
  write(ilun,format)"  real(dp),dimension(:    ),allocatable::dEr_inv_art4   ! Radiative energy increment"
  write(ilun,format)"  real(dp),dimension(:,:  ),allocatable::inverse_art4_T ! array for tabulated arT4 function dT regular"
  write(ilun,format)"  real(dp),dimension(:,:,:),allocatable::inverse_art4_E ! array for tabulated arT4 function dE regular"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_min_hz ! minimum freq of given group in Hz"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_max_hz ! maximum freq of given group in Hz"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_min_ev ! minimum freq of given group in eV"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: nu_max_ev ! maximum freq of given group in eV"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp),dimension(0:Nomega):: f_array,w1_array,dw1_array,w2_array,dw2_array ! Arrays of omega terms for Q computation"
  write(ilun,format)""
  write(ilun,format)"  logical :: freqs_in_Hz=.true.      ! Frequency units in Hz if true; if not eV"
  write(ilun,format)"  logical :: read_groups=.false.     ! Read group boundaries from file if true"
  write(ilun,format)"  logical :: split_groups_log=.true. ! Automatic splitting of group in log if true; if not use regular splitting"
  write(ilun,format)"  logical :: extra_end_group=.false. ! The last group holds frequencies numax -> frequency_upperlimit if true"
  write(ilun,format)"  logical :: grey_rad_transfer=.true.! Default: grey radiation transfer"
  write(ilun,format)"  logical :: external_radiation_field=.false. ! Default: No external radiation background (@ Tr_floor)"
  write(ilun,format)"  logical :: stellar_photon=.false.  ! Stellar photons are treated as a separate group (igrp=1). No emission for this group (radiation_source=0)"
  write(ilun,format)""
  write(ilun,format)"  ! Opacities"
  write(ilun,format)"  character(len=12) :: opacity_type = 'grey'  ! 'grey' or 'multigroup'"
  write(ilun,format)""
  write(ilun,format)"  ! Radiation solver parameters"
  write(ilun,format)"  real(dp)::epsilon_diff=1d-6                        ! CG iteration break criteria"
  write(ilun,format)"  character(LEN=10)::fld_limiter='nolim'             ! Flux limiter (nolim, levermore or minerbo)"
  write(ilun,format)"  integer::i_fld_limiter"
  write(ilun,format)"  integer,parameter::i_fld_limiter_nolim=0"
  write(ilun,format)"  integer,parameter::i_fld_limiter_minerbo=1"
  write(ilun,format)"  integer,parameter::i_fld_limiter_levermore=2"
  write(ilun,format)"  integer :: niter=0                                 ! Total number of iteration"
  write(ilun,format)"  real(dp),dimension(1:10)::dtdiff_params=1d10       ! Conduction time step behaviour"
  write(ilun,format)"  real(dp),dimension(1:10)::rosseland_params=1.0     ! Rosseland opacity coefficient's parameters"
  write(ilun,format)"  real(dp),dimension(1:10)::planck_params=1.0        ! Planck opacity coefficient's parameters"
  write(ilun,format)"  real(dp)::mu_gas=2.31d0                            ! For Saumon Chabrier EOS"
  write(ilun,format)"  real(dp)::min_optical_depth=1.d-6        ! set the minimum optical depth in the cell (it may accelerate convergence in optically thin regions)"
  write(ilun,format)""
  write(ilun,format)"  ! Variables needed for BICG scheme"
  write(ilun,format)"  real(dp),dimension(:,:,:,:),allocatable :: coeff_glob_left,coeff_glob_right"
  write(ilun,format)"  real(dp),dimension(:,:,:  ),allocatable :: var_bicg,precond_bicg"
  write(ilun,format)"  real(dp),dimension(:,:,:  ),allocatable :: mat_residual_glob"
  write(ilun,format)"  real(dp),dimension(:,:    ),allocatable :: residual_glob"
  write(ilun,format)"  real(dp),dimension(:,:    ),allocatable :: kappaR_bicg"
  write(ilun,format)"  logical::block_diagonal_precond_bicg ! if .false. only diagonal, if .true. block diagonal"
  write(ilun,format)"  integer :: i_rho,i_beta,i_y,i_pAp,i_s"
  write(ilun,format)"  integer , dimension(1:nvar_bicg) :: ind_bicg"
  write(ilun,format)"  real(dp), dimension(1:nvar_bicg) :: norm_bicg"
  write(ilun,format)"  integer , dimension(1:nvar_trad) :: ind_trad"
  write(ilun,format)"  real(dp), dimension(1:nvar_trad) :: norm_trad"
  write(ilun,format)"  logical , dimension(1:nvar_trad) :: is_radiative_energy"
  write(ilun,format)""
  write(ilun,format)"  integer                                   :: irad_trans_model        !< Integer designating radiative transfer model: 0 = P1, 1 = M1"
  write(ilun,format)"  integer, parameter                        :: irad_trans_model_p1 = 0 !< P1 radiative transfer model identifier"
  write(ilun,format)"  integer, parameter                        :: irad_trans_model_m1 = 1 !< M1 radiative transfer model identifier"
  write(ilun,format)"  integer                                   :: n_points                !< Number of points in the tabulated eigenvalues curve"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: valp                    !< Array to hold the tabulated eigenvalues as a function of \f \theta\f  and \f \epsilon\f "
  write(ilun,format)"  real(dp)                                  :: valp_min=0.0_dp"
  write(ilun,format)""
  write(ilun,format)"  logical::store_matrix=.true."
  write(ilun,format)""
  write(ilun,format)"  real(dp)::Tstar        = 5000."
  write(ilun,format)"  real(dp)::rstar        = 1."
  write(ilun,format)"  character(LEN=8)::test = ''"
  write(ilun,format)"  real(dp)::rho_disk0    = 2.874d-18"
  write(ilun,format)"  real(dp)::Rin          = 0.1d0"
  write(ilun,format)"  real(dp)::dtmax        = 1.d32"
  write(ilun,format)"  logical ::isoscat      = .false."
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1 && NGRP == 1"
  write(ilun,format)"  logical, parameter :: bicg_to_cg = .true."
  write(ilun,format)"#else"
  write(ilun,format)"  logical, parameter :: bicg_to_cg = .false."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! RT source regions parameters----------------------------------------------------------                                                       "
  write(ilun,format)"!  integer                           ::rt_nsource=0"
  write(ilun,format)"!  character(LEN=10),dimension(1:MAXREGION)::rt_source_type='square'"
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_x_center=0."
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_y_center=0."
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_length_x=1.E10"
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_length_y=1.E10"
  write(ilun,format)" "
  write(ilun,format)"  ! RT source start and end times                                                                                                              "
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_start=0."
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_src_end=0."
  write(ilun,format)""
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_exp_source=2.0"
  write(ilun,format)"!  integer, dimension(1:MAXREGION)   ::rt_src_group=1"
  write(ilun,format)"!  real(dp),dimension(1:MAXREGION)   ::rt_n_source=0.                      ! Photon density                                                       "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end module radiation_parameters"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Module MOD_OPACITIES:"
  write(ilun,format)"!"
  write(ilun,format)"!>  Module for opacities"
  write(ilun,format)"!<"
  write(ilun,format)"module mod_opacities"
  write(ilun,format)"  use amr_parameters, only : dp"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_p      !< Regular mesh of Planck opacities"
  write(ilun,format)"  real(dp), dimension(:,:,:,:), allocatable :: kappa_opmesh_r      !< Regular mesh of Rosseland opacities"
  write(ilun,format)"  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_p     !< Rosseland opacities from Dust + Gas"
  write(ilun,format)"  real(dp), dimension(:,:,:  ), allocatable :: kappa_dustgas_r     !< Rosseland opacities from Dust + Gas"
  write(ilun,format)"  real(dp), dimension(:,:    ), allocatable :: kappa_pascucci_p    !< Planck opacities from Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:,:    ), allocatable :: kappa_pascucci_r    !< Rosseland opacities from Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:,:    ), allocatable :: kappaext_pascucci_p !< Planck extinction opa from Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:,:    ), allocatable :: kappaext_pascucci_r !< Rosseland extinction opa from Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:,:    ), allocatable :: kappasca_pascucci_p !< Planck scattering opa from Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: t_pascucci          !< Temperature of points for Draine & Lee"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: logt_dustgas        !< Temperature of points for Dust+Gas data"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: logd_dustgas        !< Density of points for Dust+Gas data"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: x_opmesh            !< X (density) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: y_opmesh            !< Y (temperature) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: z_opmesh            !< Z (rad temperature) coordinates of mesh points"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: numin_dustgas       !< Minimum freq. in Dust+Gas opacities"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: numax_dustgas       !< Maximum freq. in Dust+Gas opacities"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: extrapol_min        !< Extrapolation power for low frequencies"
  write(ilun,format)"  real(dp), dimension(:      ), allocatable :: extrapol_max        !< Extrapolation power for high frequencies"
  write(ilun,format)"  integer , dimension(:      ), allocatable :: nfreq_dustgas       !< Number of freq. in Dust+Gas opacities"
  write(ilun,format)"  integer                                   :: nx_opmesh           !< Number of X points in opacity mesh"
  write(ilun,format)"  integer                                   :: ny_opmesh           !< Number of Y points in opacity mesh"
  write(ilun,format)"  integer                                   :: nz_opmesh           !< Number of Z points in opacity mesh"
  write(ilun,format)"  integer                                   :: npoints             !< Number of points in freq. for Dust+Gas opacities"
  write(ilun,format)"  integer                                   :: pascucci_n_tab      !< Number of points in temperature for Draine & Lee"
  write(ilun,format)"  real(dp)                                  :: tmin_op             !< "
  write(ilun,format)"  real(dp)                                  :: dx_opmesh           !< dx in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: dy_opmesh           !< dy in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: dz_opmesh           !< dy in opacity mesh"
  write(ilun,format)"  real(dp)                                  :: opacity_dtemp"
  write(ilun,format)"  real(dp)                                  :: dt_kappa_pascucci   !< Temperature step for Draine & Lee"
  write(ilun,format)"  real(dp), parameter                       :: t_grain_sublim = 1.5e+06_dp !< Grain sublimation temperature"
  write(ilun,format)"end module mod_opacities"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Subroutine INIT_OPACITIES_DUST_AND_GAS:"
  write(ilun,format)"!"
  write(ilun,format)"!> Read opacities for dust from Semenov+Draine and gas from Franck."
  write(ilun,format)"!!    - The arbitrary points in Rho and T are read."
  write(ilun,format)"!!    - The Planck and Rosseland means are computed for each point for each group."
  write(ilun,format)"!!    - A Delaunay triangulation is computed from the points."
  write(ilun,format)"!!    - Each triangle defines a plane in 3D."
  write(ilun,format)"!!    - Then a finer but regular mesh in (Rho,T) is overlayed onto the triangulation."
  write(ilun,format)"!!    - This gives a regular mesh of Planck and Rosseland means to perform bicubic interpolations."
  write(ilun,format)"!<"
  write(ilun,format)"subroutine init_opacities"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use amr_commons, only : myid,nrestart"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer                                 :: i,igroup,ipoint,j,it,nnumax,k,l,kw,kernel_size,istep"
  write(ilun,format)"  integer                                 :: inu_min1,inu_max1,inu_min2,inu_max2,nparts,iprog,itrad"
  write(ilun,format)"  integer                                 :: datasize,dataread,percentage,nneighbours,in,ii,jj,kk,np"
  write(ilun,format)"  integer                                 :: iter,itermax,ntot,nmin,maxneighbours,nn,n,npasses,ntrad"
  write(ilun,format)"  logical                                 :: enough_points_found,hole_filled"
  write(ilun,format)"  real(dp), dimension(:    ), allocatable :: opnu,opknu"
  write(ilun,format)"  real(dp), dimension(:,:,:), allocatable :: bin_count"
  write(ilun,format)"  real(dp)                                :: integral1,integral2,integral3,integral4,integral5,integral6"
  write(ilun,format)"  real(dp)                                :: dist,distmin,temp,x,y,xa,ya,xx,yy,dtrad"
  write(ilun,format)"  real(dp)                                :: dmax_opmesh,dmin_opmesh,tmax_opmesh,tmin_opmesh,trmax_opmesh,trmin_opmesh"
  write(ilun,format)"  real(dp)                                :: nu1,nu2,op1,op2,m,slope,dnu,kappa_min,grad1,grad2,minmod"
  write(ilun,format)"  character (len=200)                     :: opfilename,fname"
  write(ilun,format)"  logical , dimension(:,:,:), allocatable :: i_am_a_hole"
  write(ilun,format)""
  write(ilun,format)"  if(opacity_type == 'multigroup')then"
  write(ilun,format)""
  write(ilun,format)"     if(nrestart .eq. 0)then"
  write(ilun,format)"        opfilename = 'VaytetEtAl2013AandA557A90_opacities.bin'"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           write(*,*)"
  write(ilun,format)"           write(*,*) '############# MULTIGROUP DUST AND GAS OPACITIES ##############'"
  write(ilun,format)"           write(*,*) 'Reading opacity table: '//trim(opfilename)"
  write(ilun,format)"           write(*,*) '=============================================================='"
  write(ilun,format)"           write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'"
  write(ilun,format)"           write(*,*) 'COMPUTING Planck and Rosseland mean opacities for:'"
  write(ilun,format)"           write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'"
  write(ilun,format)"           write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'"
  write(ilun,format)"           write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'"
  write(ilun,format)"           write(*,*) '=============================================================='"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        !####### Set variables #######"
  write(ilun,format)"        nx_opmesh      = 100"
  write(ilun,format)"        ny_opmesh      = 100"
  write(ilun,format)"        nz_opmesh      = 100"
  write(ilun,format)"        dmin_opmesh    = -24.00_dp"
  write(ilun,format)"        dmax_opmesh    =   6.00_dp"
  write(ilun,format)"        tmin_opmesh    =   0.00_dp"
  write(ilun,format)"        tmax_opmesh    =   8.00_dp"
  write(ilun,format)"        trmin_opmesh   =   0.00_dp"
  write(ilun,format)"        trmax_opmesh   =   8.00_dp"
  write(ilun,format)"        nparts         = 10"
  write(ilun,format)"        ntrad          = 150"
  write(ilun,format)"        kappa_min      = 1.0e-50_dp"
  write(ilun,format)"        datasize       = 31637055"
  write(ilun,format)"        !#############################"
  write(ilun,format)""
  write(ilun,format)"        dtrad = (trmax_opmesh-trmin_opmesh)/real(ntrad-1,dp)"
  write(ilun,format)""
  write(ilun,format)"        open(78,file=opfilename,form='unformatted')"
  write(ilun,format)"        read(78) npoints,nnumax"
  write(ilun,format)""
  write(ilun,format)"        allocate(opnu(nnumax),opknu(nnumax))"
  write(ilun,format)"        allocate(logt_dustgas(npoints),logd_dustgas(npoints))"
  write(ilun,format)"        allocate(numin_dustgas(npoints),numax_dustgas(npoints),nfreq_dustgas(npoints))"
  write(ilun,format)"        allocate(extrapol_min(npoints),extrapol_max(npoints))"
  write(ilun,format)"        allocate(kappa_dustgas_p(ngrp,npoints,ntrad),kappa_dustgas_r(ngrp,npoints,ntrad))"
  write(ilun,format)""
  write(ilun,format)"        istep = 1"
  write(ilun,format)"        iprog = 0"
  write(ilun,format)"        dataread = 0"
  write(ilun,format)""
  write(ilun,format)"        do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"           percentage = nint(real(dataread)*100.0/real(datasize))"
  write(ilun,format)""
  write(ilun,format)"           if((myid==1) .and. (percentage .ge. iprog*istep))then"
  write(ilun,format)"              write(*,'(i3,a)') percentage,'% complete'"
  write(ilun,format)"              iprog = iprog + 1"
  write(ilun,format)"           endif"
  write(ilun,format)""
  write(ilun,format)"           read(78) logd_dustgas(ipoint),logt_dustgas(ipoint)"
  write(ilun,format)"           read(78) nfreq_dustgas(ipoint),numin_dustgas(ipoint),numax_dustgas(ipoint)"
  write(ilun,format)"           read(78) extrapol_min(ipoint),extrapol_max(ipoint)"
  write(ilun,format)"           read(78) opnu (1:nfreq_dustgas(ipoint))"
  write(ilun,format)"           read(78) opknu(1:nfreq_dustgas(ipoint))"
  write(ilun,format)""
  write(ilun,format)"           dataread = dataread + nfreq_dustgas(ipoint)"
  write(ilun,format)""
  write(ilun,format)"           ! Begin loop over Trad"
  write(ilun,format)"           do itrad = 1,ntrad"
  write(ilun,format)""
  write(ilun,format)"              temp = 10.0_dp**(real(itrad-1,dp)*dtrad + trmin_opmesh)"
  write(ilun,format)""
  write(ilun,format)"              ! find group boundaries"
  write(ilun,format)"              inu_min1 = 0 ; inu_max1 = 0"
  write(ilun,format)"              inu_min2 = 0 ; inu_max2 = 0"
  write(ilun,format)""
  write(ilun,format)"              do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                 if(nu_min_hz(igroup) .lt. opnu(1))then"
  write(ilun,format)"                    inu_min1 = 1 ; inu_min2 = 1"
  write(ilun,format)"                 elseif(nu_min_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then"
  write(ilun,format)"                    inu_min1 = nfreq_dustgas(ipoint) ; inu_min2 = nfreq_dustgas(ipoint)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i = 1,nfreq_dustgas(ipoint)-1"
  write(ilun,format)"                       if((nu_min_hz(igroup) .ge. opnu(i)).and.(nu_min_hz(igroup) .lt. opnu(i+1)))then"
  write(ilun,format)"                          inu_min1 = i ; inu_min2 = i+1"
  write(ilun,format)"                          exit"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 if(nu_max_hz(igroup) .lt. opnu(1))then"
  write(ilun,format)"                    inu_max1 = 1 ; inu_max2 = 1"
  write(ilun,format)"                 elseif(nu_max_hz(igroup) .ge. opnu(nfreq_dustgas(ipoint)))then"
  write(ilun,format)"                    inu_max1 = nfreq_dustgas(ipoint) ; inu_max2 = nfreq_dustgas(ipoint)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i = 1,nfreq_dustgas(ipoint)-1"
  write(ilun,format)"                       if((nu_max_hz(igroup) .ge. opnu(i)).and.(nu_max_hz(igroup) .lt. opnu(i+1)))then"
  write(ilun,format)"                          inu_max1 = i ; inu_max2 = i+1"
  write(ilun,format)"                          exit"
  write(ilun,format)"                       endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! compute Planck and Rosseland mean opacities"
  write(ilun,format)""
  write(ilun,format)"                 integral1 = 0.0_dp"
  write(ilun,format)"                 integral2 = 0.0_dp"
  write(ilun,format)"                 integral3 = 0.0_dp"
  write(ilun,format)"                 integral4 = 0.0_dp"
  write(ilun,format)"                 integral5 = 0.0_dp"
  write(ilun,format)"                 integral6 = 0.0_dp"
  write(ilun,format)""
  write(ilun,format)"                 ! If first frequency is outside opacity frequency range"
  write(ilun,format)"                 if(inu_min1 .eq. inu_min2)then"
  write(ilun,format)"                    ! Case where both frequencies are outside table on the same side"
  write(ilun,format)"                    if(inu_min1 .eq. inu_max1)then"
  write(ilun,format)"                       ! Select which slope to use"
  write(ilun,format)"                       if(inu_min1 .eq. 1)then"
  write(ilun,format)"                          slope = extrapol_min(ipoint)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          slope = extrapol_max(ipoint)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       ! Split interval into 10 parts"
  write(ilun,format)"                       dnu = (log10(nu_max_hz(igroup)) - log10(nu_min_hz(igroup)))/real(nparts,dp)"
  write(ilun,format)"                       do i = 1,nparts"
  write(ilun,format)"                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op1 = max(op1,kappa_min)"
  write(ilun,format)"                          op2 = max(op2,kappa_min)"
  write(ilun,format)"                          call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                               integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    else"
  write(ilun,format)"                       !Case where only numin is outside of range"
  write(ilun,format)"                       ! Select which slope to use"
  write(ilun,format)"                       if(inu_min1 .eq. 1)then"
  write(ilun,format)"                          slope = extrapol_min(ipoint)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          slope = extrapol_max(ipoint)"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       ! Split interval into 10 parts"
  write(ilun,format)"                       dnu = (log10(opnu(inu_min1))-log10(nu_min_hz(igroup)))/real(nparts,dp)"
  write(ilun,format)"                       do i = 1,nparts"
  write(ilun,format)"                          nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(nu_min_hz(igroup)))"
  write(ilun,format)"                          op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_min1))) + log10(opknu(inu_min1)))"
  write(ilun,format)"                          op1 = max(op1,kappa_min)"
  write(ilun,format)"                          op2 = max(op2,kappa_min)"
  write(ilun,format)"                          call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                               integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! If last frequency is outside opacity frequency range"
  write(ilun,format)"                 if((inu_max1 .eq. nfreq_dustgas(ipoint)) .and. (inu_max1 .eq. inu_max1))then"
  write(ilun,format)"                    !Case where numax is outside of range"
  write(ilun,format)"                    slope = extrapol_max(ipoint)"
  write(ilun,format)"                    ! Split interval into 10 parts"
  write(ilun,format)"                    dnu = (log10(nu_max_hz(igroup))-log10(opnu(inu_max1)))/real(nparts,dp)"
  write(ilun,format)"                    do i = 1,nparts"
  write(ilun,format)"                       nu1 = 10.0_dp**(real(i-1,dp)*dnu + log10(opnu(inu_max1)))"
  write(ilun,format)"                       nu2 = 10.0_dp**(real(i  ,dp)*dnu + log10(opnu(inu_max1)))"
  write(ilun,format)"                       op1 = 10.0_dp**(slope * (log10(nu1)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))"
  write(ilun,format)"                       op2 = 10.0_dp**(slope * (log10(nu2)-log10(opnu(inu_max1))) + log10(opknu(inu_max1)))"
  write(ilun,format)"                       op1 = max(op1,kappa_min)"
  write(ilun,format)"                       op2 = max(op2,kappa_min)"
  write(ilun,format)"                       call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                            integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! First part of the curve between numin and inumin"
  write(ilun,format)"                 if(inu_min1 .ne. inu_min2)then"
  write(ilun,format)"                    nu1 = opnu (inu_min1)"
  write(ilun,format)"                    nu2 = opnu (inu_min2)"
  write(ilun,format)"                    m = ( opknu(inu_min2) - opknu(inu_min1) ) / (nu2 - nu1)"
  write(ilun,format)"                    op1 = m * (nu_min_hz(igroup)-nu1) + opknu(inu_min1)"
  write(ilun,format)"                    op2 = opknu(inu_min2)"
  write(ilun,format)"                    nu1 = nu_min_hz(igroup)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Last part of the curve between inumax and numax"
  write(ilun,format)"                 if(inu_max1 .ne. inu_max2)then"
  write(ilun,format)"                    nu1 = opnu (inu_max1)"
  write(ilun,format)"                    nu2 = opnu (inu_max2)"
  write(ilun,format)"                    m = ( opknu(inu_max2) - opknu(inu_max1) ) / (nu2 - nu1)"
  write(ilun,format)"                    op1 = opknu(inu_max1)"
  write(ilun,format)"                    op2 = m * (nu_max_hz(igroup)-nu1) + opknu(inu_max1)"
  write(ilun,format)"                    nu2 = nu_max_hz(igroup)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 ! Middle part between inumin and inumax"
  write(ilun,format)"                 do i = inu_min2,inu_max1-1"
  write(ilun,format)"                    nu1 = opnu (i  )"
  write(ilun,format)"                    nu2 = opnu (i+1)"
  write(ilun,format)"                    op1 = opknu(i  )"
  write(ilun,format)"                    op2 = opknu(i+1)"
  write(ilun,format)"                    call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                         integral5,integral6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if(abs(integral1) < 1.0e-50_dp)then"
  write(ilun,format)"                    kappa_dustgas_p(igroup,ipoint,itrad) = integral5 / integral6"
  write(ilun,format)"                 else"
  write(ilun,format)"                    kappa_dustgas_p(igroup,ipoint,itrad) = integral1 / integral2"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(abs(integral3) < 1.0e-50_dp)then"
  write(ilun,format)"                    kappa_dustgas_r(igroup,ipoint,itrad) = integral5 / integral6"
  write(ilun,format)"                 else"
  write(ilun,format)"                    kappa_dustgas_r(igroup,ipoint,itrad) = integral3 / integral4"
  write(ilun,format)"                 endif"
  write(ilun,format)""
  write(ilun,format)"                 !         if(logt_dustgas(ipoint) > 5.0)then"
  write(ilun,format)"                 !            write(*,*) ipoint,igroup,integral1,integral2,integral3,integral4,&"
  write(ilun,format)"                 !                       kappa_dustgas_p(igroup,ipoint),kappa_dustgas_r(igroup,ipoint)"
  write(ilun,format)"                 !         endif"
  write(ilun,format)""
  write(ilun,format)"              enddo ! end do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"           enddo ! end do itrad = 1,ntrad"
  write(ilun,format)""
  write(ilun,format)"        enddo ! end do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"        close(78)"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           write(*,*) 'Number of points:',npoints"
  write(ilun,format)"           write(*,*) 'Rhomin,Rhomax:',minval(logd_dustgas),maxval(logd_dustgas)"
  write(ilun,format)"           write(*,*) 'Tmin,Tmax:',minval(logt_dustgas),maxval(logt_dustgas)"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Create a mesh of (rho,T) points:"
  write(ilun,format)"        if(myid==1) write(*,*) 'Computing regular mesh of opacities'"
  write(ilun,format)""
  write(ilun,format)"        allocate(bin_count(nx_opmesh,ny_opmesh,nz_opmesh),i_am_a_hole(nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)"        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)"        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"        dx_opmesh = (dmax_opmesh-dmin_opmesh)/real(nx_opmesh-1,dp)"
  write(ilun,format)"        dy_opmesh = (tmax_opmesh-tmin_opmesh)/real(ny_opmesh-1,dp)"
  write(ilun,format)"        dz_opmesh = (trmax_opmesh-trmin_opmesh)/real(nz_opmesh-1,dp)     "
  write(ilun,format)""
  write(ilun,format)"        x_opmesh(1) = dmin_opmesh"
  write(ilun,format)"        y_opmesh(1) = tmin_opmesh"
  write(ilun,format)"        z_opmesh(1) = trmin_opmesh"
  write(ilun,format)""
  write(ilun,format)"        do i = 2,nx_opmesh"
  write(ilun,format)"           x_opmesh(i) = x_opmesh(i-1) + dx_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)"        do j = 2,ny_opmesh"
  write(ilun,format)"           y_opmesh(j) = y_opmesh(j-1) + dy_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)"        do k = 2,nz_opmesh"
  write(ilun,format)"           z_opmesh(k) = z_opmesh(k-1) + dz_opmesh"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        bin_count = 0.0_dp"
  write(ilun,format)"        kappa_opmesh_p = 0.0_dp"
  write(ilun,format)"        kappa_opmesh_r = 0.0_dp"
  write(ilun,format)"        i_am_a_hole = .true."
  write(ilun,format)""
  write(ilun,format)"        do ipoint = 1,npoints"
  write(ilun,format)""
  write(ilun,format)"           i = floor((logd_dustgas(ipoint)-dmin_opmesh)/dx_opmesh - 0.5_dp) + 2"
  write(ilun,format)"           j = floor((logt_dustgas(ipoint)-tmin_opmesh)/dy_opmesh - 0.5_dp) + 2"
  write(ilun,format)""
  write(ilun,format)"           ! now search along Trad direction"
  write(ilun,format)"           do itrad = 1,ntrad"
  write(ilun,format)"              temp = real(itrad-1,dp)*dtrad + trmin_opmesh"
  write(ilun,format)""
  write(ilun,format)"              k = floor((temp-tmin_opmesh)/dz_opmesh - 0.5_dp) + 2"
  write(ilun,format)""
  write(ilun,format)"              do igroup = 1,ngrp"
  write(ilun,format)"                 kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) + kappa_dustgas_p(igroup,ipoint,itrad)"
  write(ilun,format)"                 kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) + kappa_dustgas_r(igroup,ipoint,itrad)"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"              bin_count(i,j,k) = bin_count(i,j,k) + 1.0_dp"
  write(ilun,format)"              i_am_a_hole(i,j,k) = .false."
  write(ilun,format)""
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        do k = 1,nz_opmesh"
  write(ilun,format)"           do j = 1,ny_opmesh"
  write(ilun,format)"              do i = 1,nx_opmesh"
  write(ilun,format)"                 if(i_am_a_hole(i,j,k))then"
  write(ilun,format)"                    do igroup = 1,ngrp"
  write(ilun,format)"                       kappa_opmesh_p(igroup,i,j,k) = 1.0e-30_dp"
  write(ilun,format)"                       kappa_opmesh_r(igroup,i,j,k) = 1.0e-30_dp"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do igroup = 1,ngrp"
  write(ilun,format)"                       kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(igroup,i,j,k) / bin_count(i,j,k)"
  write(ilun,format)"                       kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(igroup,i,j,k) / bin_count(i,j,k)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 endif"
  write(ilun,format)"              enddo"
  write(ilun,format)"           enddo"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        ! Convert to log"
  write(ilun,format)"        kappa_opmesh_p = log10(kappa_opmesh_p)"
  write(ilun,format)"        kappa_opmesh_r = log10(kappa_opmesh_r)"
  write(ilun,format)""
  write(ilun,format)"        ! Now fill holes in table"
  write(ilun,format)"        if(myid==1)write(*,*) 'Filling holes in table...'"
  write(ilun,format)""
  write(ilun,format)"        ! First find holes which are surrounded by many points, and then go to bigger ang bigger holes"
  write(ilun,format)""
  write(ilun,format)"        npasses = 10 ! number of times to perform filling process"
  write(ilun,format)""
  write(ilun,format)"        do n = 1,npasses"
  write(ilun,format)""
  write(ilun,format)"           nneighbours = 26"
  write(ilun,format)"           maxneighbours = 0"
  write(ilun,format)"           itermax = 8"
  write(ilun,format)"           do in = nneighbours,0,-1"
  write(ilun,format)""
  write(ilun,format)"              do k = 1,nz_opmesh"
  write(ilun,format)"                 do j = 1,ny_opmesh"
  write(ilun,format)"                    do i = 1,nx_opmesh"
  write(ilun,format)"                       if(i_am_a_hole(i,j,k))then"
  write(ilun,format)""
  write(ilun,format)"                          ! Find number of neighbours"
  write(ilun,format)"                          nn = 0"
  write(ilun,format)"                          do ii = max(i-1,1),min(i+1,nx_opmesh)"
  write(ilun,format)"                             do jj = max(j-1,1),min(j+1,ny_opmesh)"
  write(ilun,format)"                                do kk = max(k-1,1),min(k+1,nz_opmesh)"
  write(ilun,format)"                                   if(.not.i_am_a_hole(ii,jj,kk))then"
  write(ilun,format)"                                      nn = nn + 1"
  write(ilun,format)"                                   endif"
  write(ilun,format)"                                enddo"
  write(ilun,format)"                             enddo"
  write(ilun,format)"                          enddo"
  write(ilun,format)""
  write(ilun,format)"                          if(nn == in)then"
  write(ilun,format)""
  write(ilun,format)"                             hole_filled = .false."
  write(ilun,format)""
  write(ilun,format)"                             do igroup = 1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                                do iter = 1,itermax"
  write(ilun,format)""
  write(ilun,format)"                                   np = 0"
  write(ilun,format)"                                   xx = 0.0_dp"
  write(ilun,format)"                                   yy = 0.0_dp"
  write(ilun,format)"                                   ntot = (1 + 2*iter)**3 - 1"
  write(ilun,format)"                                   nmin = int(2.0_dp*sqrt(real(ntot,dp)))   ! ntot / 2 + 1"
  write(ilun,format)"                                   enough_points_found = .false."
  write(ilun,format)""
  write(ilun,format)"                                   do ii = max(i-iter,1),min(i+iter,nx_opmesh)"
  write(ilun,format)"                                      do jj = max(j-iter,1),min(j+iter,ny_opmesh)"
  write(ilun,format)"                                         do kk = max(k-iter,1),min(k+iter,nz_opmesh)"
  write(ilun,format)""
  write(ilun,format)"                                            if(.not.i_am_a_hole(ii,jj,kk))then"
  write(ilun,format)"                                               xx = xx + kappa_opmesh_p(igroup,ii,jj,kk)"
  write(ilun,format)"                                               yy = yy + kappa_opmesh_r(igroup,ii,jj,kk)"
  write(ilun,format)"                                               np = np + 1"
  write(ilun,format)"                                            endif"
  write(ilun,format)""
  write(ilun,format)"                                         enddo"
  write(ilun,format)"                                      enddo"
  write(ilun,format)"                                   enddo"
  write(ilun,format)""
  write(ilun,format)"                                   if(np .ge. nmin)then"
  write(ilun,format)"                                      enough_points_found = .true."
  write(ilun,format)"                                      exit"
  write(ilun,format)"                                   endif"
  write(ilun,format)""
  write(ilun,format)"                                enddo"
  write(ilun,format)""
  write(ilun,format)"                                if(enough_points_found)then"
  write(ilun,format)"                                   kappa_opmesh_p(igroup,i,j,k) = xx / real(np,dp)"
  write(ilun,format)"                                   kappa_opmesh_r(igroup,i,j,k) = yy / real(np,dp)"
  write(ilun,format)"                                   hole_filled = .true."
  write(ilun,format)"                                endif"
  write(ilun,format)""
  write(ilun,format)"                             enddo"
  write(ilun,format)""
  write(ilun,format)"                             if(hole_filled) i_am_a_hole(i,j,k) = .false."
  write(ilun,format)""
  write(ilun,format)"                          endif"
  write(ilun,format)""
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    enddo ! end do i = 1,nx_opmesh"
  write(ilun,format)"                 enddo ! end do j = 1,ny_opmesh"
  write(ilun,format)"              enddo ! end do k = 1,nz_opmesh"
  write(ilun,format)""
  write(ilun,format)"           enddo ! end do in = nneighbours,0,-1"
  write(ilun,format)""
  write(ilun,format)"        enddo ! end do n = 1,npasses"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)write(*,*) 'Done'"
  write(ilun,format)""
  write(ilun,format)"        ! Free memory"
  write(ilun,format)"        deallocate(opnu,opknu)"
  write(ilun,format)"        deallocate(logt_dustgas,logd_dustgas)"
  write(ilun,format)"        deallocate(numin_dustgas,numax_dustgas,nfreq_dustgas)"
  write(ilun,format)"        deallocate(extrapol_min,extrapol_max)"
  write(ilun,format)"        deallocate(kappa_dustgas_p,kappa_dustgas_r)"
  write(ilun,format)"        deallocate(bin_count,i_am_a_hole)"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)then"
  write(ilun,format)"           open (79,file='multigroup_opacity.bin',form='unformatted')"
  write(ilun,format)"           write (79) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"           write (79) x_opmesh"
  write(ilun,format)"           write (79) y_opmesh"
  write(ilun,format)"           write (79) z_opmesh"
  write(ilun,format)"           write (79) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"           write (79) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"           close(79)"
  write(ilun,format)"        end if"
  write(ilun,format)"     else"
  write(ilun,format)"        if(myid==1)write(*,*) 'Reading opacity table from previous run'"
  write(ilun,format)""
  write(ilun,format)"        open (80,file='multigroup_opacity.bin',form='unformatted')"
  write(ilun,format)"        read (80) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"        allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)"        allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"        read (80) x_opmesh"
  write(ilun,format)"        read (80) y_opmesh"
  write(ilun,format)"        read (80) z_opmesh"
  write(ilun,format)"        read (80) kappa_opmesh_p(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"        read (80) kappa_opmesh_r(1:ngrp,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"        close(80)"
  write(ilun,format)""
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)""
  write(ilun,format)"     if(ngrp .gt. 1 .and. myid==1)then"
  write(ilun,format)"        write(*,*) "
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"        write(*,*) 'WARNING: using grey opacities with NGROUP>1!'"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     opfilename = 'vaytet_grey_opacities3D.bin'"
  write(ilun,format)""
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        write(*,*)"
  write(ilun,format)"        write(*,*) '################ GREY DUST AND GAS OPACITIES #################'"
  write(ilun,format)"        write(*,*) 'Reading opacity table: '//trim(opfilename)"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"        write(*,*) 'Opacities: Vaytet et al. 2013, A&A, 557, A90'"
  write(ilun,format)"        write(*,*) 'READING Planck and Rosseland mean opacities for:'"
  write(ilun,format)"        write(*,*) ' - DUST (Semenov et al. 2003, Draine 2003) : 5K < T < 1500K'"
  write(ilun,format)"        write(*,*) ' - MOLECULAR GAS (Ferguson et al. 2005): 1500K < T < 3200K'"
  write(ilun,format)"        write(*,*) ' - ATOMIC GAS (Badnell et al. 2005): 3200K < T < 1.0e8K'"
  write(ilun,format)"        write(*,*) '=============================================================='"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     open (78,file=trim(opfilename),form='unformatted')"
  write(ilun,format)"     read (78) nx_opmesh,ny_opmesh,nz_opmesh,dx_opmesh,dy_opmesh,dz_opmesh,dmin_opmesh,dmax_opmesh,tmin_opmesh,tmax_opmesh,trmin_opmesh,trmax_opmesh"
  write(ilun,format)""
  write(ilun,format)"     allocate(x_opmesh(nx_opmesh),y_opmesh(ny_opmesh),z_opmesh(nz_opmesh))"
  write(ilun,format)"     allocate(kappa_opmesh_p(ngrp,nx_opmesh,ny_opmesh,nz_opmesh),kappa_opmesh_r(ngrp,nx_opmesh,ny_opmesh,nz_opmesh))"
  write(ilun,format)""
  write(ilun,format)"     read (78) x_opmesh"
  write(ilun,format)"     read (78) y_opmesh"
  write(ilun,format)"     read (78) z_opmesh"
  write(ilun,format)"     read (78) kappa_opmesh_p(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"     read (78) kappa_opmesh_r(1,1:nx_opmesh,1:ny_opmesh,1:nz_opmesh)"
  write(ilun,format)"     close(78)"
  write(ilun,format)""
  write(ilun,format)"     if(ngrp .gt. 1)then"
  write(ilun,format)"        do k = 1,nz_opmesh"
  write(ilun,format)"           do j = 1,ny_opmesh"
  write(ilun,format)"              do i = 1,nx_opmesh"
  write(ilun,format)"                 do igroup=2,ngrp"
  write(ilun,format)"                    kappa_opmesh_p(igroup,i,j,k) = kappa_opmesh_p(1,i,j,k)"
  write(ilun,format)"                    kappa_opmesh_r(igroup,i,j,k) = kappa_opmesh_r(1,i,j,k)"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*) 'INIT_OPACITIES complete'"
  write(ilun,format)"     write(*,*) '##############################################################'"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine init_opacities"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Function PLANCK_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> Compute Planck average opacity."
  write(ilun,format)"!<"
  write(ilun,format)"real(dp) function planck_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use pm_commons,only:Teff_sink"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp), intent(in):: dens,Tp,Tr"
  write(ilun,format)"  integer, intent(in) :: igroup"
  write(ilun,format)"  integer             :: ival,jval,kval,i1,i2"
  write(ilun,format)"  real(dp)            :: div1,div2"
  write(ilun,format)"  real(dp)            :: x,y,z,dx,dy,dz,a,b"
  write(ilun,format)"  real(dp)            :: x0,x1,x2,y0,y1,y2,z0,z1"
  write(ilun,format)"  real(dp)            :: c00,c01,c10,c11,c0,c1"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  ! compute dust and gas opacities"
  write(ilun,format)"  x = log10(dens)"
  write(ilun,format)"  y = log10(Tp)"
  write(ilun,format)"  if(igroup==1 .and. stellar_photon)y=log10(Tstar) !for stellar_photon approach"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  i1 = floor((y - t_pascucci(1))/dt_kappa_pascucci) + 1"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(i1 >= pascucci_n_tab)then"
  write(ilun,format)"  "
  write(ilun,format)"!!      do ig = 1,ngr "
  write(ilun,format)"        planck_ana = dens*10.0d0**(kappa_pascucci_p(igroup,pascucci_n_tab)) "
  write(ilun,format)"!        kappar_t(ig,i) = ten**(kappa_pascucci_r(ig,pascucci_n_tab))"
  write(ilun,format)"!!      enddo"
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)"  "
  write(ilun,format)"     i2 = i1 + 1"
  write(ilun,format)""
  write(ilun,format)"     x1 = t_pascucci(i1)"
  write(ilun,format)"     x2 = t_pascucci(i2)"
  write(ilun,format)""
  write(ilun,format)"!!      do ig = 1,ngr"
  write(ilun,format)""
  write(ilun,format)"        y1 = kappa_pascucci_p(igroup,i1)"
  write(ilun,format)"        y2 = kappa_pascucci_p(igroup,i2)"
  write(ilun,format)"     "
  write(ilun,format)""
  write(ilun,format)"        a = (y2 - y1) / (x2 - x1)"
  write(ilun,format)"        b = y1 - a * x1"
  write(ilun,format)""
  write(ilun,format)"        planck_ana = dens*10.0d0**(a*y + b)"
  write(ilun,format)"     !write(*,*) 'Tstar, planck ana/dens for group : ', Tstar, 10.0d0**(a*y + b), igroup"
  write(ilun,format)"        "
  write(ilun,format)"  !      planck_ana = 0.0 !test1 Econs, pas de couplage gaz - radiation"
  write(ilun,format)"  !      write(*,*) 'test E cons, planck ana=0, rosseland ana = cst1, cst2'"
  write(ilun,format)""
  write(ilun,format)"!!         y1 = kappa_pascucci_r(igroup,i1)"
  write(ilun,format)"!!         y2 = kappa_pascucci_r(igroup,i2)"
  write(ilun,format)"!!   ! compute dust and gas opacities"
  write(ilun,format)"!!   x = log10(dens)"
  write(ilun,format)"!!   y = log10(Tp)"
  write(ilun,format)"!!   z = log10(Tr)"
  write(ilun,format)"!!   if(stellar_photon)then"
  write(ilun,format)"!!      if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) "
  write(ilun,format)"!!   end if"
  write(ilun,format)"!!     "
  write(ilun,format)"!!   ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1"
  write(ilun,format)"!!   jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1"
  write(ilun,format)"!!   kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Perform tri-linear interpolation"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Compute coordinate deltas"
  write(ilun,format)"!!   x0 = x_opmesh(ival  )"
  write(ilun,format)"!!   x1 = x_opmesh(ival+1)"
  write(ilun,format)"!!   y0 = y_opmesh(jval  )"
  write(ilun,format)"!!   y1 = y_opmesh(jval+1)"
  write(ilun,format)"!!   z0 = z_opmesh(kval  )"
  write(ilun,format)"!!   z1 = z_opmesh(kval+1)"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   dx = (x-x0)/(x1-x0)"
  write(ilun,format)"!!   dy = (y-y0)/(y1-y0)"
  write(ilun,format)"!!   dz = (z-z0)/(z1-z0)"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! First linear interpolation along x"
  write(ilun,format)"!!   c00 = kappa_opmesh_p(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval  )*dx"
  write(ilun,format)"!!   c10 = kappa_opmesh_p(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval  )*dx"
  write(ilun,format)"!!   c01 = kappa_opmesh_p(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval  ,kval+1)*dx"
  write(ilun,format)"!!   c11 = kappa_opmesh_p(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_p(igroup,ival+1,jval+1,kval+1)*dx"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Second linear interpolation along y"
  write(ilun,format)"!!   c0 = c00*(1.0_dp-dy) + c10*dy"
  write(ilun,format)"!!   c1 = c01*(1.0_dp-dy) + c11*dy"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Third linear interpolation along z"
  write(ilun,format)"!!   planck_ana = c0*(1.0_dp-dz) + c1*dz"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   planck_ana = dens*10.0_dp**(planck_ana)"
  write(ilun,format)""
  write(ilun,format)"!!   planck_ana = planck_params(1)*(dens**planck_params(2))*(Tp**planck_params(3))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!mat debug"
  write(ilun,format)"!!   if(igroup==1 .and. stellar_photon) then"
  write(ilun,format)"!!      x = log10(dens)"
  write(ilun,format)"!!      y = log10(Tp)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      i1 = floor((y - t_pascucci(1))/dt_kappa_pascucci) + 1"
  write(ilun,format)"!!      "
  write(ilun,format)"!!      if(i1 >= pascucci_n_tab)then"
  write(ilun,format)"!!          z = dens*10.0d0**(kappa_pascucci_p(igroup,pascucci_n_tab)) "
  write(ilun,format)"!!       else"
  write(ilun,format)"!!   "
  write(ilun,format)"!!          i2 = i1 + 1"
  write(ilun,format)"!!          "
  write(ilun,format)"!!          x1 = t_pascucci(i1)"
  write(ilun,format)"!!          x2 = t_pascucci(i2)"
  write(ilun,format)"!!          "
  write(ilun,format)"!!          y1 = kappa_pascucci_p(igroup,i1)"
  write(ilun,format)"!!          y2 = kappa_pascucci_p(igroup,i2)"
  write(ilun,format)"!!          "
  write(ilun,format)"!!          a = (y2 - y1) / (x2 - x1)"
  write(ilun,format)"!!          b = y1 - a * x1"
  write(ilun,format)"!!          "
  write(ilun,format)"!!          z = dens*10.0d0**(a*y + b)"
  write(ilun,format)"!!          "
  write(ilun,format)"!!       endif"
  write(ilun,format)"!! "
  write(ilun,format)"!!       print*,'planck_ana stellar vs grey =',dens,Tp,planck_ana,z"
  write(ilun,format)"!!    endif"
  write(ilun,format)"!mat debug"
  write(ilun,format)""
  write(ilun,format)"end function planck_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!  Function PLANCK_ANA_SCAT:                 "
  write(ilun,format)"!                                        "
  write(ilun,format)"!> Compute Planck average opacity on scattering, for M1 flux equation. Useless for energy equation"
  write(ilun,format)"!<                              "
  write(ilun,format)"real(dp) function planck_ana_scat(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons, only : myid"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp),intent(in) :: dens,Tp,Tr"
  write(ilun,format)"  integer,intent(in)  :: igroup"
  write(ilun,format)"  integer             :: i1,i2"
  write(ilun,format)"  real(dp)            :: x,y,a,b"
  write(ilun,format)"  real(dp)            :: x1,x2,y1,y2"
  write(ilun,format)""
  write(ilun,format)"  ! compute dust and gas opacities                                             "
  write(ilun,format)"  x = log10(dens)"
  write(ilun,format)"  y = log10(Tp)"
  write(ilun,format)""
  write(ilun,format)"  i1 = floor((y - t_pascucci(1))/dt_kappa_pascucci) + 1"
  write(ilun,format)""
  write(ilun,format)"  if(i1 >= pascucci_n_tab)then"
  write(ilun,format)""
  write(ilun,format)"!!      do ig = 1,ngr                                                   "
  write(ilun,format)"        planck_ana_scat = dens*10.0d0**kappasca_pascucci_p(igroup,pascucci_n_tab)"
  write(ilun,format)"        ! scattering = extinction - absorption"
  write(ilun,format)"!!      enddo                                                       "
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)""
  write(ilun,format)"     i2 = i1 + 1"
  write(ilun,format)""
  write(ilun,format)"     x1 = t_pascucci(i1)"
  write(ilun,format)"     x2 = t_pascucci(i2)"
  write(ilun,format)""
  write(ilun,format)"     if (isoscat) then !add condition on rtprotostarm1 to be sure?"
  write(ilun,format)"        !isotropic scattering => kp(kabs+ksca) pour M1 flux, kp(kabs) for M1 energy, kp(kabs) pour fld from planck_ana"
  write(ilun,format)"        y1 = kappasca_pascucci_p(igroup,i1)"
  write(ilun,format)"        y2 = kappasca_pascucci_p(igroup,i2)"
  write(ilun,format)"     else"
  write(ilun,format)"        if(myid == 1) write(*,*) 'Trying to add scattering without isoscat on'"
  write(ilun,format)"        y1 = 0"
  write(ilun,format)"        y2 = 0"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     a = (y2 - y1) / (x2 - x1)"
  write(ilun,format)"     b = y1 - a * x1"
  write(ilun,format)""
  write(ilun,format)"     planck_ana_scat = dens*10.0d0**(a*y + b)"
  write(ilun,format)"     !write(*,*) 'Tstar, planck ana/dens for group : ', Tstar, 10.0d0**(a*y + b), igroup"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"end function planck_ana_scat"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!  Function ROSSELAND_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> Compute Rosseland mean opacity."
  write(ilun,format)"!<"
  write(ilun,format)"function rosseland_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use pm_commons,only:Teff_sink"
  write(ilun,format)"  "
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer, intent(in) :: igroup"
  write(ilun,format)"  integer             :: i,ival,jval,kval,i1,i2"
  write(ilun,format)"  real(dp),intent(in) :: dens,Tp,Tr"
  write(ilun,format)"  real(dp)            :: x,y,z,dx,dy,dz"
  write(ilun,format)"  real(dp)            :: x0,x1,x2,y0,y1,y2,a,b,z0,z1"
  write(ilun,format)"  real(dp)            :: c00,c01,c10,c11,c0,c1"
  write(ilun,format)"  real(dp)            :: rosseland_ana "
  write(ilun,format)"!!   if(igroup==1)Tp=5800.0d0"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! compute dust and gas opacities"
  write(ilun,format)"  x = log10(dens)"
  write(ilun,format)"  y = log10(Tp)"
  write(ilun,format)"  if(igroup==1 .and. stellar_photon)y=log10(Tstar)  !for stellar_photon approach"
  write(ilun,format)""
  write(ilun,format)"  ! original part from pinte_mat "
  write(ilun,format)"!!   z = log10(Tr)"
  write(ilun,format)"!!   if(stellar_photon)then"
  write(ilun,format)"!!      if(igroup==1 .and. maxval(Teff_sink).gt.0)z = log10(maxval(Teff_sink)) "
  write(ilun,format)"!!   end if"
  write(ilun,format)"!! "
  write(ilun,format)"!!   ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1"
  write(ilun,format)"!!   jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1"
  write(ilun,format)"!!   kval = floor((z - z_opmesh(1)) / dz_opmesh) + 1"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Perform tri-linear interpolation"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Compute coordinate deltas"
  write(ilun,format)"!!   x0 = x_opmesh(ival  )"
  write(ilun,format)"!!   x1 = x_opmesh(ival+1)"
  write(ilun,format)"!!   y0 = y_opmesh(jval  )"
  write(ilun,format)"!!   y1 = y_opmesh(jval+1)"
  write(ilun,format)"!!   z0 = z_opmesh(kval  )"
  write(ilun,format)"!!   z1 = z_opmesh(kval+1)"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   dx = (x-x0)/(x1-x0)"
  write(ilun,format)"!!   dy = (y-y0)/(y1-y0)"
  write(ilun,format)"!!   dz = (z-z0)/(z1-z0)"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! First linear interpolation along x"
  write(ilun,format)"!!   c00 = kappa_opmesh_r(igroup,ival  ,jval  ,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval  )*dx"
  write(ilun,format)"!!   c10 = kappa_opmesh_r(igroup,ival  ,jval+1,kval  )*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval  )*dx"
  write(ilun,format)"!!   c01 = kappa_opmesh_r(igroup,ival  ,jval  ,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval  ,kval+1)*dx"
  write(ilun,format)"!!   c11 = kappa_opmesh_r(igroup,ival  ,jval+1,kval+1)*(1.0_dp-dx) + kappa_opmesh_r(igroup,ival+1,jval+1,kval+1)*dx"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Second linear interpolation along y"
  write(ilun,format)"!!   c0 = c00*(1.0_dp-dy) + c10*dy"
  write(ilun,format)"!!   c1 = c01*(1.0_dp-dy) + c11*dy"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   ! Third linear interpolation along z"
  write(ilun,format)"!!   rosseland_ana = c0*(1.0_dp-dz) + c1*dz"
  write(ilun,format)"!!   "
  write(ilun,format)"!!   rosseland_ana = dens*10.0_dp**(rosseland_ana)"
  write(ilun,format)"!!  rosseland_ana = rosseland_params(1)*(dens**rosseland_params(2))*(Tp**rosseland_params(3))"
  write(ilun,format)""
  write(ilun,format)"  i1 = floor((y - t_pascucci(1))/dt_kappa_pascucci) + 1"
  write(ilun,format)""
  write(ilun,format)"  if(i1 >= pascucci_n_tab)then"
  write(ilun,format)""
  write(ilun,format)"!!      do ig = 1,ngr"
  write(ilun,format)"        rosseland_ana = dens*10.0d0**(kappa_pascucci_r(igroup,pascucci_n_tab))"
  write(ilun,format)"        if (isoscat) rosseland_ana = dens*10.0d0**(kappaext_pascucci_r(igroup,pascucci_n_tab))"
  write(ilun,format)"!        kappar_t(ig,i) = ten**(kappa_pascucci_r(ig,pascucci_n_tab))"
  write(ilun,format)"!!      enddo"
  write(ilun,format)""
  write(ilun,format)"  else"
  write(ilun,format)""
  write(ilun,format)"     i2 = i1 + 1"
  write(ilun,format)""
  write(ilun,format)"     x1 = t_pascucci(i1)"
  write(ilun,format)"     x2 = t_pascucci(i2)"
  write(ilun,format)""
  write(ilun,format)"!!      do ig = 1,ngr"
  write(ilun,format)""
  write(ilun,format)"        if (isoscat) then"
  write(ilun,format)"           y1 = kappaext_pascucci_r(igroup,i1)"
  write(ilun,format)"           y2 = kappaext_pascucci_r(igroup,i2)"
  write(ilun,format)"        else "
  write(ilun,format)"           y1 = kappa_pascucci_r(igroup,i1)"
  write(ilun,format)"           y2 = kappa_pascucci_r(igroup,i2)"
  write(ilun,format)"        endif"
  write(ilun,format)"        a = (y2 - y1) / (x2 - x1)"
  write(ilun,format)"        b = y1 - a * x1"
  write(ilun,format)""
  write(ilun,format)"        rosseland_ana = dens*10.0d0**(a*y + b)"
  write(ilun,format)""
  write(ilun,format)"!        if(stellar_photon .and. igroup==1)  rosseland_ana =7.9*10.0d0**(-20.0)"
  write(ilun,format)""
  write(ilun,format)"!!         y1 = kappa_pascucci_r(igroup,i1)"
  write(ilun,format)"!!         y2 = kappa_pascucci_r(igroup,i2)"
  write(ilun,format)"!! "
  write(ilun,format)"!!         a = (y2 - y1) / (x2 - x1)"
  write(ilun,format)"!!         b = y1 - a * x1"
  write(ilun,format)"!! "
  write(ilun,format)"!!         kappar_t(igroup,i) = ten**(a*y + b)"
  write(ilun,format)""
  write(ilun,format)"!!      enddo"
  write(ilun,format)""
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"!!   ! check if we are outside of opacity mesh table"
  write(ilun,format)"!!   ! top right corner"
  write(ilun,format)"!!   if((x >= x_opmesh(nx_opmesh)).and.(y >= y_opmesh(ny_opmesh)))then"
  write(ilun,format)"!!      ival = nx_opmesh"
  write(ilun,format)"!!      jval = ny_opmesh"
  write(ilun,format)"!!      rosseland_ana = kappa_opmesh_r(igroup,ival,jval)"
  write(ilun,format)"!!   ! bottom left corner"
  write(ilun,format)"!!   elseif((x < x_opmesh(1)).and.(y < y_opmesh(1)))then"
  write(ilun,format)"!!      ival = 1"
  write(ilun,format)"!!      jval = 1"
  write(ilun,format)"!!      rosseland_ana = kappa_opmesh_r(igroup,ival,jval)"
  write(ilun,format)"!!   ! bottom right corner"
  write(ilun,format)"!!   elseif((x >= x_opmesh(nx_opmesh)).and.(y < y_opmesh(1)))then"
  write(ilun,format)"!!      ival = nx_opmesh"
  write(ilun,format)"!!      jval = 1"
  write(ilun,format)"!!      rosseland_ana = kappa_opmesh_r(igroup,ival,jval)"
  write(ilun,format)"!!   ! top left corner"
  write(ilun,format)"!!   elseif((x < x_opmesh(1)).and.(y >= y_opmesh(ny_opmesh)))then"
  write(ilun,format)"!!      ival = 1"
  write(ilun,format)"!!      jval = ny_opmesh"
  write(ilun,format)"!!      rosseland_ana = kappa_opmesh_r(igroup,ival,jval)"
  write(ilun,format)"!!   ! left edge"
  write(ilun,format)"!!   elseif(x >= x_opmesh(nx_opmesh))then"
  write(ilun,format)"!!      ival = nx_opmesh"
  write(ilun,format)"!!      jval = ny_opmesh"
  write(ilun,format)"!!      do jj = 1,ny_opmesh-1"
  write(ilun,format)"!!         if((y >= y_opmesh(jj)) .and. (y < y_opmesh(jj+1)))then"
  write(ilun,format)"!!            jval = jj"
  write(ilun,format)"!!            exit"
  write(ilun,format)"!!         endif"
  write(ilun,format)"!!      enddo"
  write(ilun,format)"!!      x2l = y_opmesh(jval  )"
  write(ilun,format)"!!      x2u = y_opmesh(jval+1)"
  write(ilun,format)"!!      a = (kappa_opmesh_r(igroup,ival,jval+1)-kappa_opmesh_r(igroup,ival,jval))/(x2u-x2l)"
  write(ilun,format)"!!      b = kappa_opmesh_r(igroup,ival,jval) - a*x2l"
  write(ilun,format)"!!      rosseland_ana = a*y + b"
  write(ilun,format)"!!   ! right edge"
  write(ilun,format)"!!   elseif(x < x_opmesh(1))then"
  write(ilun,format)"!!      ival = 1"
  write(ilun,format)"!!      jval = ny_opmesh"
  write(ilun,format)"!!      do jj = 1,ny_opmesh-1"
  write(ilun,format)"!!         if((y >= y_opmesh(jj)) .and. (y < y_opmesh(jj+1)))then"
  write(ilun,format)"!!            jval = jj"
  write(ilun,format)"!!            exit"
  write(ilun,format)"!!         endif"
  write(ilun,format)"!!      enddo"
  write(ilun,format)"!!      x2l = y_opmesh(jval  )"
  write(ilun,format)"!!      x2u = y_opmesh(jval+1)"
  write(ilun,format)"!!      a = (kappa_opmesh_r(igroup,ival,jval+1)-kappa_opmesh_r(igroup,ival,jval))/(x2u-x2l)"
  write(ilun,format)"!!      b = kappa_opmesh_r(igroup,ival,jval) - a*x2l"
  write(ilun,format)"!!      rosseland_ana = a*y + b"
  write(ilun,format)"!!   ! top edge"
  write(ilun,format)"!!   elseif(y >= y_opmesh(ny_opmesh))then"
  write(ilun,format)"!!      jval = ny_opmesh"
  write(ilun,format)"!!      ival = nx_opmesh"
  write(ilun,format)"!!      do ii = 1,nx_opmesh-1"
  write(ilun,format)"!!         if((x >= x_opmesh(ii)) .and. (x < x_opmesh(ii+1)))then"
  write(ilun,format)"!!            ival = ii"
  write(ilun,format)"!!            exit"
  write(ilun,format)"!!         endif"
  write(ilun,format)"!!      enddo"
  write(ilun,format)"!!      x1l = x_opmesh(ival  )"
  write(ilun,format)"!!      x1u = x_opmesh(ival+1)"
  write(ilun,format)"!!      a = (kappa_opmesh_r(igroup,ival+1,jval)-kappa_opmesh_r(igroup,ival,jval))/(x1u-x1l)"
  write(ilun,format)"!!      b = kappa_opmesh_r(igroup,ival,jval) - a*x1l"
  write(ilun,format)"!!      rosseland_ana = a*x + b"
  write(ilun,format)"!!   ! bottom edge"
  write(ilun,format)"!!   elseif(y < y_opmesh(1))then"
  write(ilun,format)"!!      jval = 1"
  write(ilun,format)"!!      ival = nx_opmesh"
  write(ilun,format)"!!      do ii = 1,nx_opmesh-1"
  write(ilun,format)"!!         if((x >= x_opmesh(ii)) .and. (x < x_opmesh(ii+1)))then"
  write(ilun,format)"!!            ival = ii"
  write(ilun,format)"!!            exit"
  write(ilun,format)"!!         endif"
  write(ilun,format)"!!      enddo"
  write(ilun,format)"!!      x1l = x_opmesh(ival  )"
  write(ilun,format)"!!      x1u = x_opmesh(ival+1)"
  write(ilun,format)"!!      a = (kappa_opmesh_r(igroup,ival+1,jval)-kappa_opmesh_r(igroup,ival,jval))/(x1u-x1l)"
  write(ilun,format)"!!      b = kappa_opmesh_r(igroup,ival,jval) - a*x1l"
  write(ilun,format)"!!      rosseland_ana = a*x + b"
  write(ilun,format)"!!   else"
  write(ilun,format)"!!      ! find i,j indices"
  write(ilun,format)"!!      ival = floor((x - x_opmesh(1)) / dx_opmesh) + 1"
  write(ilun,format)"!!      jval = floor((y - y_opmesh(1)) / dy_opmesh) + 1"
  write(ilun,format)"!! "
  write(ilun,format)"!!      x1l = x_opmesh(ival  )"
  write(ilun,format)"!!      x1u = x_opmesh(ival+1)"
  write(ilun,format)"!!      x2l = y_opmesh(jval  )"
  write(ilun,format)"!!      x2u = y_opmesh(jval+1)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      p(1) = kappa_opmesh_r(igroup,ival  ,jval  )"
  write(ilun,format)"!!      p(2) = kappa_opmesh_r(igroup,ival+1,jval  )"
  write(ilun,format)"!!      p(3) = kappa_opmesh_r(igroup,ival+1,jval+1)"
  write(ilun,format)"!!      p(4) = kappa_opmesh_r(igroup,ival  ,jval+1)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      p1(1) = gradx_opmesh_r(igroup,ival  ,jval  )"
  write(ilun,format)"!!      p1(2) = gradx_opmesh_r(igroup,ival+1,jval  )"
  write(ilun,format)"!!      p1(3) = gradx_opmesh_r(igroup,ival+1,jval+1)"
  write(ilun,format)"!!      p1(4) = gradx_opmesh_r(igroup,ival  ,jval+1)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      p2(1) = grady_opmesh_r(igroup,ival  ,jval  )"
  write(ilun,format)"!!      p2(2) = grady_opmesh_r(igroup,ival+1,jval  )"
  write(ilun,format)"!!      p2(3) = grady_opmesh_r(igroup,ival+1,jval+1)"
  write(ilun,format)"!!      p2(4) = grady_opmesh_r(igroup,ival  ,jval+1)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      p12(1) = gradxy_opmesh_r(igroup,ival  ,jval  )"
  write(ilun,format)"!!      p12(2) = gradxy_opmesh_r(igroup,ival+1,jval  )"
  write(ilun,format)"!!      p12(3) = gradxy_opmesh_r(igroup,ival+1,jval+1)"
  write(ilun,format)"!!      p12(4) = gradxy_opmesh_r(igroup,ival  ,jval+1)"
  write(ilun,format)"!! "
  write(ilun,format)"!!      call bcuint(p,p1,p2,p12,x1l,x1u,x2l,x2u,x,y,rosseland_ana,div1,div2)"
  write(ilun,format)"!! "
  write(ilun,format)"!!   endif"
  write(ilun,format)"!! "
  write(ilun,format)"!!   rosseland_ana = dens*10.0_dp**(rosseland_ana)"
  write(ilun,format)"!! "
  write(ilun,format)"!  if(dens .gt. 5.d-15)print*,igroup,rosseland_ana/dens,dens"
  write(ilun,format)"!  rosseland_ana=1.5d4*dens*0.01!rosseland_ana*1.d6"
  write(ilun,format)""
  write(ilun,format)"end function rosseland_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Function SCATTERING_ANA:"
  write(ilun,format)"!"
  write(ilun,format)"!> This routine computes the scattering opacity kappa_s*rho"
  write(ilun,format)"!! as a function of density and temperature."
  write(ilun,format)"!! Units are supposed to be in cgs here (as in units.f90)"
  write(ilun,format)"!<"
  write(ilun,format)"function scattering_ana(dens,Tp,Tr,igroup)"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use const"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer ,intent(in)    :: igroup"
  write(ilun,format)"  real(dp),intent(in)    :: dens,Tp,Tr"
  write(ilun,format)"  real(dp)               :: scattering_ana"
  write(ilun,format)"  "
  write(ilun,format)"  scattering_ana = zero"
  write(ilun,format)""
  write(ilun,format)"end function scattering_ana"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Subroutine COMPUTE_INTEGRAL:"
  write(ilun,format)"!"
  write(ilun,format)"!> Computes integrals for Planck and Rosseland means between nu1 and nu2."
  write(ilun,format)"!<"
  write(ilun,format)"subroutine compute_integral(int1,int2,int3,int4,int5,int6,nu1,nu2,op1,op2,temp)"
  write(ilun,format)""
  write(ilun,format)"  use amr_parameters, only : dp"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp), intent(inout) :: int1,int2,int3,int4,int5,int6"
  write(ilun,format)"  real(dp), intent(in   ) :: nu1,nu2,op1,op2,temp"
  write(ilun,format)"  real(dp)                :: BPlanck,Div_BPlanck"
  write(ilun,format)""
  write(ilun,format)"  int1 = int1 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp) * op1 + &"
  write(ilun,format)"                                           BPlanck(nu2,temp) * op2 )"
  write(ilun,format)"  int2 = int2 + 0.5_dp * (nu2-nu1) * (     BPlanck(nu1,temp)       + &"
  write(ilun,format)"                                           BPlanck(nu2,temp)       )"
  write(ilun,format)"  int3 = int3 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp)       + &"
  write(ilun,format)"                                       Div_BPlanck(nu2,temp)       )"
  write(ilun,format)"  int4 = int4 + 0.5_dp * (nu2-nu1) * ( Div_BPlanck(nu1,temp) / op1 + &"
  write(ilun,format)"                                       Div_BPlanck(nu2,temp) / op2 )"
  write(ilun,format)"  int5 = int5 + 0.5_dp * (nu2-nu1) * ( op1 + op2 )"
  write(ilun,format)"  int6 = int6 +          (nu2-nu1)"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_integral"
  write(ilun,format)""
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)"!##################################################################################################"
  write(ilun,format)""
  write(ilun,format)"!  Subroutine INIT_OPACITIES_pascucci:"
  write(ilun,format)"!"
  write(ilun,format)"!> Reads opacities from pascucci et al. 2004 files and computes Planck and Rosseland means."
  write(ilun,format)"!<"
  write(ilun,format)"subroutine init_opacities_pascucci"
  write(ilun,format)""
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use amr_commons, only : myid"
  write(ilun,format)"  use const"
  write(ilun,format)"  use cooling_module,ONLY:clight"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  "
  write(ilun,format)"  real(dp), dimension(:), allocatable :: opnu,opknu,opknuext"
  write(ilun,format)"  integer , parameter                 :: nopmax = 1000"
  write(ilun,format)"  integer                             :: i,n,ig,it,is"
  write(ilun,format)"  integer , dimension(ngrp)           :: inu_min1,inu_max1,inu_min2,inu_max2"
  write(ilun,format)"  real(dp), dimension(nopmax)         :: oplambda,opknul,opknule"
  write(ilun,format)"  real(dp)                            :: dum1,dum2,dum3,integral1,integral2"
  write(ilun,format)"  real(dp)                            :: integral3,integral4,integral5,integral6"
  write(ilun,format)"  real(dp)                            :: temp,temp1,dt,tmin,m,nu1,nu2,op1,op2,grain_size,rho_grain,grain_mass"
  write(ilun,format)"  real(dp)                            :: mext,op1ext, op2ext"
  write(ilun,format)"  character (len=200)                 :: opafname,opfilelist,path"
  write(ilun,format)"  integer                             :: kernel_size,j,kw"
  write(ilun,format)"  real(dp), dimension(:), allocatable :: gkernel"
  write(ilun,format)"  logical                             :: nml_ok"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*) '################### DRAINE & LEE (1984) OPACITIES ###################'"
  write(ilun,format)"     write(*,*)"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! set array space"
  write(ilun,format)"  pascucci_n_tab = 1000"
  write(ilun,format)"  if (test=='pascucci') then"
  write(ilun,format)"     grain_size = 1.2e-05_dp"
  write(ilun,format)"     rho_grain  = 3.6_dp"
  write(ilun,format)"     opafname   = 'optSi.dat' !'kappa_DraineLee_1984.dat' is the same with more points"
  write(ilun,format)"     !optSi : wavelength (microns), scat cross section (m2), ext cross section (m2)"
  write(ilun,format)"  else if (test=='pinte') then"
  write(ilun,format)"     grain_size = 1.0e-04_dp"
  write(ilun,format)"     rho_grain  = 3.5_dp"
  write(ilun,format)"     opafname   = 'kappa_weingartnerdraine.dat'"
  write(ilun,format)"     !kappa_wd : wavelength (microns), ext cross section (cm2/g), abs, sca"
  write(ilun,format)"  endif"
  write(ilun,format)"  grain_mass = 4.0d0/3.0d0 * 3.1415 * grain_size**3 * rho_grain"
  write(ilun,format)""
  write(ilun,format)"  allocate(kappa_pascucci_p(ngrp,pascucci_n_tab),kappa_pascucci_r(ngrp,pascucci_n_tab))"
  write(ilun,format)"  if (isoscat) allocate(kappaext_pascucci_p(ngrp,pascucci_n_tab),kappaext_pascucci_r(ngrp,pascucci_n_tab),kappasca_pascucci_p(ngrp,pascucci_n_tab))"
  write(ilun,format)"  allocate(t_pascucci(pascucci_n_tab))"
  write(ilun,format)"  allocate(opnu(nopmax),opknu(nopmax))"
  write(ilun,format)"  if (isoscat) allocate(opknuext(nopmax))"
  write(ilun,format)""
  write(ilun,format)"  ! read data from opacity file"
  write(ilun,format)"  i = 1"
  write(ilun,format)""
  write(ilun,format)"  inquire(file=opafname,exist=nml_ok)"
  write(ilun,format)"  if(.not. nml_ok)then"
  write(ilun,format)"     if(myid==1)then"
  write(ilun,format)"        write(*,*)'File '//TRIM(opafname)//' does not exist'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  open(46,file=opafname)"
  write(ilun,format)"  do while(.true.)"
  write(ilun,format)"     read(46,*,end=556) oplambda(i),dum1,dum2"
  write(ilun,format)"     if (test=='pascucci') then"
  write(ilun,format)"        opknul(i) = dum2 - dum1 ! abs = ext - scat"
  write(ilun,format)"        if (isoscat) opknule(i) = dum2"
  write(ilun,format)"     else if (test=='pinte') then"
  write(ilun,format)"        opknul(i) = dum2 !dum1 = ext ; dum2 = abs; dum3 = sca"
  write(ilun,format)"        if (isoscat) opknule(i) = dum1"
  write(ilun,format)"     endif"
  write(ilun,format)"     i = i + 1"
  write(ilun,format)"  enddo"
  write(ilun,format)"  556 continue"
  write(ilun,format)"  close(46)"
  write(ilun,format)"  n = i - 1"
  write(ilun,format)""
  write(ilun,format)"  ! convert wavelengths to cm"
  write(ilun,format)"  do i = 1,n"
  write(ilun,format)"     oplambda(i) = oplambda(i)*1.0e-04_dp !wavelength to cm"
  write(ilun,format)"     opnu(i) = clight / oplambda(i) !wavelength to frequency"
  write(ilun,format)"     if (test=='pascucci') then"
  write(ilun,format)"        opknu(i) =  opknul(i) * 1.0e04_dp / grain_mass / 100_dp !op in m2 => cm2 in opsi.dat, div my mass and dust to gas ratio"
  write(ilun,format)"        if (isoscat) opknuext(i) = opknule(i) * 1.0e04_dp / grain_mass / 100_dp"
  write(ilun,format)"     else if (test=='pinte') then"
  write(ilun,format)"        opknu(i) =  opknul(i) / 100_dp !op in cm2/g in kWD, div my dust to gas ratio"
  write(ilun,format)"        if (isoscat) opknuext(i) = opknule(i) / 100_dp"
  write(ilun,format)"     endif"
  write(ilun,format)"!         write(*,*) opnu(n-i+1),opknu(n-i+1)"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     write(*,*) 'opacities frequency range (Hz):',opnu(1),opnu(n)"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Tabulate opacities"
  write(ilun,format)"  tmin = one"
  write(ilun,format)"!   dt = (t_grain_sublim-tmin) / real(pascucci_n_tab-1)              ! linear"
  write(ilun,format)"  dt_kappa_pascucci = (log10(t_grain_sublim)-log10(tmin)) / real(pascucci_n_tab-1,dp)  ! log"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"  do is = 1,pascucci_n_tab"
  write(ilun,format)"          "
  write(ilun,format)"!      t_pascucci(is) = real(is-1)*dt + tmin"
  write(ilun,format)"     t_pascucci(is) = real(is-1,dp)*dt_kappa_pascucci + log10(tmin)"
  write(ilun,format)"     "
  write(ilun,format)"     ! find group boundaries"
  write(ilun,format)"     inu_min1 = 0 ; inu_max1 = 0"
  write(ilun,format)"     inu_min2 = 0 ; inu_max2 = 0"
  write(ilun,format)"     do ig = 1,ngrp"
  write(ilun,format)"     "
  write(ilun,format)"        if(nu_min_hz(ig) .lt. opnu(1))then"
  write(ilun,format)"           inu_min1(ig) = 1 ; inu_min2(ig) = 1"
  write(ilun,format)"        elseif(nu_min_hz(ig) .ge. opnu(n))then"
  write(ilun,format)"           inu_min1(ig) = n ; inu_min2(ig) = n "
  write(ilun,format)"        else"
  write(ilun,format)"           do i = 1,n-1"
  write(ilun,format)"              if((nu_min_hz(ig) .ge. opnu(i)).and.(nu_min_hz(ig) .lt. opnu(i+1)))then"
  write(ilun,format)"                 inu_min1(ig) = i ; inu_min2(ig) = i + 1"
  write(ilun,format)"                 exit"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"        if(nu_max_hz(ig) .lt. opnu(1))then"
  write(ilun,format)"           inu_max1(ig) = 1 ; inu_max2(ig) = 1"
  write(ilun,format)"        elseif(nu_max_hz(ig) .ge. opnu(n))then"
  write(ilun,format)"           inu_max1(ig) = n ; inu_max2(ig) = n "
  write(ilun,format)"        else"
  write(ilun,format)"           do i = 1,n-1"
  write(ilun,format)"              if((nu_max_hz(ig) .ge. opnu(i)).and.(nu_max_hz(ig) .lt. opnu(i+1)))then"
  write(ilun,format)"                 inu_max1(ig) = i ; inu_max2(ig) = i + 1"
  write(ilun,format)"                 exit"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"     enddo"
  write(ilun,format)"     "
  write(ilun,format)"!      ig = 1"
  write(ilun,format)"!      write(*,*) 'got to here 1',inu_min1(ig),inu_min2(ig),inu_max1(ig),inu_max2(ig)"
  write(ilun,format)"     "
  write(ilun,format)"     ! compute Planck and Rosseland mean opacities"
  write(ilun,format)"     do ig = 1,ngrp"
  write(ilun,format)"     "
  write(ilun,format)"        integral1 = zero"
  write(ilun,format)"        integral2 = zero"
  write(ilun,format)"        integral3 = zero"
  write(ilun,format)"        integral4 = zero"
  write(ilun,format)"        integral5 = zero"
  write(ilun,format)"        integral6 = zero"
  write(ilun,format)""
  write(ilun,format)"        ! First part of the curve between numin and inumin"
  write(ilun,format)"        if(inu_min1(ig) .ne. inu_min2(ig))then"
  write(ilun,format)"           nu1 = opnu (inu_min1(ig))"
  write(ilun,format)"           nu2 = opnu (inu_min2(ig))"
  write(ilun,format)"           m    = ( opknu(inu_min2(ig)) - opknu(inu_min1(ig)) ) / (nu2 - nu1)"
  write(ilun,format)"           op1 = m * (nu_min_hz(ig)-nu1) + opknu(inu_min1(ig))"
  write(ilun,format)"           op2 = opknu(inu_min2(ig))"
  write(ilun,format)"           nu1 = nu_min_hz(ig)"
  write(ilun,format)"           call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                                 integral5,integral6,nu1,nu2,op1,op2,ten**(t_pascucci(is)))"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"!         write(*,*) 'got to here 2',integral1,integral2,integral3,integral4,integral5,integral6"
  write(ilun,format)"        "
  write(ilun,format)"        ! Last part of the curve between inumax and numax"
  write(ilun,format)"        if(inu_max1(ig) .ne. inu_max2(ig))then"
  write(ilun,format)"           nu1 = opnu (inu_max1(ig))"
  write(ilun,format)"           nu2 = opnu (inu_max2(ig))"
  write(ilun,format)"           m = ( opknu(inu_max2(ig)) - opknu(inu_max1(ig)) ) / (nu2 - nu1)"
  write(ilun,format)"           op1 = opknu(inu_max1(ig))"
  write(ilun,format)"           op2 = m * (nu_max_hz(ig)-op1) + opknu(inu_max1(ig))"
  write(ilun,format)"           nu2 = nu_max_hz(ig)"
  write(ilun,format)"           call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                                 integral5,integral6,nu1,nu2,op1,op2,ten**(t_pascucci(is)))"
  write(ilun,format)"        endif"
  write(ilun,format)"        "
  write(ilun,format)"!         write(*,*) 'got to here 3',integral1,integral2,integral3,integral4,integral5,integral6"
  write(ilun,format)"     "
  write(ilun,format)"        ! Middle part between inumin and inumax"
  write(ilun,format)"        do i = inu_min2(ig),inu_max1(ig)-1"
  write(ilun,format)"           nu1 = opnu (i  )"
  write(ilun,format)"           nu2 = opnu (i+1)"
  write(ilun,format)"           op1 = opknu(i  )"
  write(ilun,format)"           op2 = opknu(i+1)"
  write(ilun,format)"           call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                                 integral5,integral6,nu1,nu2,op1,op2,ten**(t_pascucci(is)))"
  write(ilun,format)"        enddo"
  write(ilun,format)"        "
  write(ilun,format)"!         write(*,*) 'got to here 4',integral1,integral2,integral3,integral4,integral5,integral6"
  write(ilun,format)"        if(abs(integral2) < 1.0e-50_dp)then"
  write(ilun,format)"           kappa_pascucci_p(ig,is) = integral5 / integral6"
  write(ilun,format)"        else"
  write(ilun,format)"           kappa_pascucci_p(ig,is) = integral1 / integral2"
  write(ilun,format)"        endif"
  write(ilun,format)"        if(abs(integral4) < 1.0e-50_dp)then"
  write(ilun,format)"           kappa_pascucci_r(ig,is) = integral5 / integral6"
  write(ilun,format)"        else"
  write(ilun,format)"           kappa_pascucci_r(ig,is) = integral3 / integral4"
  write(ilun,format)"        endif"
  write(ilun,format)"!         write(*,*) 'got to here 5'"
  write(ilun,format)"!     write(*,*) 'is, kp1 kr1, kp2, kr2',is, kappa_pascucci_p(1,is),kappa_pascucci_r(1,is),kappa_pascucci_p(2,is),kappa_pascucci_r(2,is)"
  write(ilun,format)""
  write(ilun,format)"        if (isoscat) then"
  write(ilun,format)"           !Same for the extinction"
  write(ilun,format)"           integral1 = zero"
  write(ilun,format)"           integral2 = zero"
  write(ilun,format)"           integral3 = zero"
  write(ilun,format)"           integral4 = zero"
  write(ilun,format)"           integral5 = zero"
  write(ilun,format)"           integral6 = zero"
  write(ilun,format)"           ! First part of the curve between numin and inumin"
  write(ilun,format)"           if(inu_min1(ig) .ne. inu_min2(ig))then"
  write(ilun,format)"              nu1 = opnu (inu_min1(ig))"
  write(ilun,format)"              nu2 = opnu (inu_min2(ig))"
  write(ilun,format)"              mext   = ( opknuext(inu_min2(ig)) - opknuext(inu_min1(ig)) ) / (nu2 - nu1)"
  write(ilun,format)"              op1ext = mext * (nu_min_hz(ig)-nu1) + opknuext(inu_min1(ig))"
  write(ilun,format)"              op2ext = opknuext(inu_min2(ig))"
  write(ilun,format)"              nu1 = nu_min_hz(ig)"
  write(ilun,format)"              call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                   integral5,integral6,nu1,nu2,op1ext,op2ext,ten**(t_pascucci(is)))"
  write(ilun,format)"           endif"
  write(ilun,format)"           ! Last part of the curve between inumax and numax"
  write(ilun,format)"           if(inu_max1(ig) .ne. inu_max2(ig))then"
  write(ilun,format)"              nu1 = opnu (inu_max1(ig))"
  write(ilun,format)"              nu2 = opnu (inu_max2(ig))"
  write(ilun,format)"              mext = ( opknuext(inu_max2(ig)) - opknuext(inu_max1(ig)) ) / (nu2 - nu1)"
  write(ilun,format)"              op1ext = opknuext(inu_max1(ig))"
  write(ilun,format)"              op2ext = m * (nu_max_hz(ig)-op1) + opknuext(inu_max1(ig))"
  write(ilun,format)"              nu2 = nu_max_hz(ig)"
  write(ilun,format)"              call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                   integral5,integral6,nu1,nu2,op1ext,op2ext,ten**(t_pascucci(is)))"
  write(ilun,format)"           endif"
  write(ilun,format)"           ! Middle part between inumin and inumax"
  write(ilun,format)"           do i = inu_min2(ig),inu_max1(ig)-1"
  write(ilun,format)"              nu1 = opnu (i  )"
  write(ilun,format)"              nu2 = opnu (i+1)"
  write(ilun,format)"              op1ext = opknuext(i  )"
  write(ilun,format)"              op2ext = opknuext(i+1)"
  write(ilun,format)"              call compute_integral(integral1,integral2,integral3,integral4, &"
  write(ilun,format)"                   integral5,integral6,nu1,nu2,op1ext,op2ext,ten**(t_pascucci(is)))"
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"           if(abs(integral2) < 1.0e-50_dp)then"
  write(ilun,format)"              kappaext_pascucci_p(ig,is) = integral5 / integral6"
  write(ilun,format)"           else"
  write(ilun,format)"              kappaext_pascucci_p(ig,is) = integral1 / integral2"
  write(ilun,format)"           endif"
  write(ilun,format)"           if(abs(integral4) < 1.0e-50_dp)then"
  write(ilun,format)"              kappaext_pascucci_r(ig,is) = integral5 / integral6"
  write(ilun,format)"           else"
  write(ilun,format)"              kappaext_pascucci_r(ig,is) = integral3 / integral4"
  write(ilun,format)"           endif"
  write(ilun,format)"        endif"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"!     write(*,*) t_pascucci(is),kappa_pascucci_p(1,is),kappa_pascucci_r(1,is)"
  write(ilun,format)"  "
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)"!  if(myid==1) write(*,*) kappa_pascucci_p, kappa_pascucci_r, kappaext_pascucci_p, kappaext_pascucci_r"
  write(ilun,format)"  if (isoscat) kappasca_pascucci_p = kappaext_pascucci_p - kappa_pascucci_p"
  write(ilun,format)"  kappa_pascucci_p = log10(kappa_pascucci_p)"
  write(ilun,format)"  kappa_pascucci_r = log10(kappa_pascucci_r)"
  write(ilun,format)"  !if(myid==1) write(*,*) 'kp abs = ', kappa_pascucci_p"
  write(ilun,format)"  !if(myid==1) write(*,*) 'kr abs = ', kappa_pascucci_r"
  write(ilun,format)"  if (isoscat) then"
  write(ilun,format)"     kappaext_pascucci_p = log10(kappaext_pascucci_p)"
  write(ilun,format)"     kappaext_pascucci_r = log10(kappaext_pascucci_r)"
  write(ilun,format)"     kappasca_pascucci_p = log10(kappasca_pascucci_p)"
  write(ilun,format)"     !if(myid==1) write(*,*) 'kp ext = ', kappaext_pascucci_p"
  write(ilun,format)"     !if(myid==1) write(*,*) 'kr ext = ', kappaext_pascucci_r"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1) write(*,*) '#########################################################'"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"  return"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine init_opacities_pascucci"
  write(ilun,format)"../patch/irradiation/test_pascucci/radiative_transfer_bicg.f90"
  write(ilun,format)"subroutine diffusion_cg (ilevel,Nsub)"
  write(ilun,format)"  use amr_commons,only:myid,numbtot,active,son,ncpu,reception,dtnew,ncoarse,nstep"
  write(ilun,format)"  use amr_parameters, only : verbose, ndim"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)""
  write(ilun,format)"  use rt_hydro_commons !raph, M1 heating "
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use rt_cooling_module"
  write(ilun,format)"  use cloud_module, only : rt_protostar_m1"
  write(ilun,format)""
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !========================================================="
  write(ilun,format)"  ! Iterative solver with Stabilised Bi-Conjugate Gradient method"
  write(ilun,format)"  ! to solve A x = b"
  write(ilun,format)"  !  i   : cell index"
  write(ilun,format)"  !  irad: radiative variable index (from 1 to ngrp if FLD, from 1 to (1+ndim)*ngrp if M1)"
  write(ilun,format)"  !"
  write(ilun,format)"  !   r         : stored in var_bicg(i,irad,1)"
  write(ilun,format)"  !   p         : stored in var_bicg(i,irad,2)"
  write(ilun,format)"  !   v         : stored in var_bicg(i,irad,3)"
  write(ilun,format)"  !   K^{-1}    : stored in var_bicg(i,irad,4)"
  write(ilun,format)"  !   y         : stored in var_bicg(i,irad,5)"
  write(ilun,format)"  !   z         : stored in var_bicg(i,irad,6)"
  write(ilun,format)"  !   s         : stored in var_bicg(i,irad,7)"
  write(ilun,format)"  !   t         : stored in var_bicg(i,irad,8) "
  write(ilun,format)"  !   rbar_0    : stored in var_bicg(i,irad,9)"
  write(ilun,format)"  !   K^{-1}*t  : stored in var_bicg(i,irad,10)"
  write(ilun,format)"  !"
  write(ilun,format)"  !  radflux (cell_left ,idim=1)   : stored in var_bicg(i,irad,11)"
  write(ilun,format)"  !  radflux (cell_right,idim=1)   : stored in var_bicg(i,irad,12)"
  write(ilun,format)"  !  radflux (cell_left ,idim=2)   : stored in var_bicg(i,irad,13)"
  write(ilun,format)"  !  radflux (cell_right,idim=2)   : stored in var_bicg(i,irad,14)"
  write(ilun,format)"  !  radflux (cell_left ,idim=3)   : stored in var_bicg(i,irad,15)"
  write(ilun,format)"  !  radflux (cell_right,idim=3)   : stored in var_bicg(i,irad,16)"
  write(ilun,format)"  !"
  write(ilun,format)"  !  new radiative energy at time n+1 : stored in unew(i,irad)"
  write(ilun,format)"  !      radiative energy at time n   : stored in uold(i,irad)"
  write(ilun,format)"  !"
  write(ilun,format)"  !Tgas (iteration) : stored in unew(i,nvar)"
  write(ilun,format)"  !Tgas (old)       : stored in uold(i,nvar)"
  write(ilun,format)"  !"
  write(ilun,format)"  !"
  write(ilun,format)"  !========================================================="
  write(ilun,format)"  integer,intent(IN)::ilevel,Nsub"
  write(ilun,format)"  complex*16 :: final_sum"
  write(ilun,format)"  real(dp)::error,error_ini,epsilon"
  write(ilun,format)"  real(dp)::Cv,told,rho,dt_exp,wdtB,wdtE,Tr,Trold,cal_Teg"
  write(ilun,format)"  real(dp)::r2,rhs_norm1,r3"
  write(ilun,format)"  real(dp)::temp,density,planck_ana,rosseland_ana,planck_ana_scat"
  write(ilun,format)"  integer::i,ind,iter,iskip,itermax,icpu,igroup,igrp,irad,jrad,ivar"
  write(ilun,format)"  integer::this,nleaf_tot"
  write(ilun,format)"  real(dp)::radiation_source,deriv_radiation_source,rhs,lhs"
  write(ilun,format)" "
  write(ilun,format)"  real(dp)::rho_bicg_new,rho_bicg_old,alpha_bicg,omega_bicg,beta_bicg"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::max_loc"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::protostellar_heating !raph for M1 heating"
  write(ilun,format)"  integer ::im1"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  integer::info,nleaf_all"
  write(ilun,format)"  real(dp)::max_loc_all"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  logical::exist_leaf_cell=.true.,debug_energy=.false."
  write(ilun,format)""
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  real(dp)::scale,dx,dx_loc"
  write(ilun,format)""
  write(ilun,format)"  !benoit"
  write(ilun,format)"  integer::isub,nsub_imp"
  write(ilun,format)"  real(dp)::min_ener,min_ener_all,max_ener,max_ener_all"
  write(ilun,format)"  real(dp),dimension(1:ngrp)::dener"
  write(ilun,format)"  !benoit"
  write(ilun,format)""
  write(ilun,format)"  !raph, M1 injection"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  real(dp)::scale_Np,scale_Fp"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  call rt_units(scale_Np,scale_Fp)"
  write(ilun,format)"#endif"
  write(ilun,format)"  !raph"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1 .and. (mod(nstep,ncontrol)==0)) write(*,*) 'entering radiative transfer for level ',ilevel"
  write(ilun,format)""
  write(ilun,format)"  if(bicg_to_cg)then"
  write(ilun,format)"     block_diagonal_precond_bicg=.false."
  write(ilun,format)"     i_rho  = 6"
  write(ilun,format)"     i_beta = 6"
  write(ilun,format)"     i_y    = 2"
  write(ilun,format)"     i_pAp  = 2"
  write(ilun,format)"     i_s    = 1"
  write(ilun,format)"  else"
  write(ilun,format)"     block_diagonal_precond_bicg=.true."
  write(ilun,format)"     i_rho  = 9"
  write(ilun,format)"     i_beta = 1"
  write(ilun,format)"     i_y    = 5"
  write(ilun,format)"     i_pAp  = 9"
  write(ilun,format)"     i_s    = 7"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,111)"
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  allocate(liste_ind (1:twotondim*active(ilevel)%ngrid))"
  write(ilun,format)""
  write(ilun,format)"  nb_ind = 0"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,active(ilevel)%ngrid"
  write(ilun,format)"        if(son(active(ilevel)%igrid(i)+iskip) == 0)then"
  write(ilun,format)"           nb_ind = nb_ind+1 "
  write(ilun,format)"           liste_ind(nb_ind) = active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do icpu=1,ncpu"
  write(ilun,format)"           do i=1,reception(icpu,ilevel)%ngrid"
  write(ilun,format)"              rad_flux(reception(icpu,ilevel)%igrid(i)+iskip,irad)=zero"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,reception(icpu,ilevel-1)%ngrid"
  write(ilun,format)"              rad_flux(reception(icpu,ilevel-1)%igrid(i)+iskip,irad)=zero"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  if(debug_energy)then"
  write(ilun,format)"  write(*,*) 'At the beginning of uplmde - uold(5-9)-unew(5-9)'"
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     write(*,'(12(ES15.6))') uold(this,5),uold(this,nvar),uold(this,9),uold(this,10),unew(this,5),unew(this,nvar),unew(this,9),unew(this,10)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  read(*,*)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  ! Begin of subcycles...."
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  dt_exp = dtnew(ilevel)"
  write(ilun,format)"  dt_imp = dtnew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  if (nb_ind == 0)then"
  write(ilun,format)"     !print*,'No leaf-cell - myid=',myid"
  write(ilun,format)"     exist_leaf_cell=.false."
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  nleaf_tot=nb_ind"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(nb_ind,nleaf_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  nleaf_tot=nleaf_all"
  write(ilun,format)"#endif"
  write(ilun,format)"     "
  write(ilun,format)"  if(nleaf_tot .eq. 0)then"
  write(ilun,format)"     !write(*,*)'No leaf cells at level',ilevel,'. Exiting BiCG'"
  write(ilun,format)"     deallocate(liste_ind)"
  write(ilun,format)"     return"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)""
  write(ilun,format)"     var_bicg(this,:,:)=zero"
  write(ilun,format)"     if(block_diagonal_precond_bicg) precond_bicg(this,:,:)=zero"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        unew(this,ind_bicg(irad))=zero"
  write(ilun,format)"     enddo"
  write(ilun,format)"     unew(this,nvar+1)=zero"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"     kappaR_bicg(this,:)=zero"
  write(ilun,format)"#endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Set constants"
  write(ilun,format)"  epsilon = epsilon_diff"
  write(ilun,format)""
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  ! Compute gas temperature stored in uold(i,nvar) and in unew(i,nvar)"
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  call cmp_energy(1)"
  write(ilun,format)""
  write(ilun,format)"  if(debug_energy)then"
  write(ilun,format)"  write(*,*) 'After cmp_energy(1) - uold(5-9)-unew(5-9)'"
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     write(*,'(12(ES15.6))') uold(this,5),uold(this,nvar),uold(this,9),uold(this,10),unew(this,5),unew(this,nvar),unew(this,9),unew(this,10)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  read(*,*)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !benoit"
  write(ilun,format)""
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  ! Begin of subcycles...."
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  dt_exp = dtnew(ilevel)"
  write(ilun,format)"  dt_imp = dtnew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  dener=0.0d0"
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     max_ener=0.0d0"
  write(ilun,format)"     min_ener=1.0d30"
  write(ilun,format)"     do i=1,nb_ind"
  write(ilun,format)"        this = liste_ind(i)"
  write(ilun,format)"        max_ener=max(max_ener, uold(liste_ind(i),firstindex_er+igroup))"
  write(ilun,format)"        min_ener=min(min_ener, uold(liste_ind(i),firstindex_er+igroup))"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute maximum error"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(max_ener,max_ener_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"     max_ener=max_ener_all"
  write(ilun,format)"     call MPI_ALLREDUCE(min_ener,min_ener_all,1,MPI_DOUBLE_PRECISION,MPI_MIN,MPI_COMM_WORLD,info)"
  write(ilun,format)"     min_ener=min_ener_all"
  write(ilun,format)"#endif"
  write(ilun,format)"     dener(igroup)=max_ener/min_ener"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  nsub_imp=1"
  write(ilun,format)"!!   if(ngrp .gt. 1 .and. maxval(dener) .gt. 1.d4)then"
  write(ilun,format)"!!      nsub_imp=int(maxval(dener)**0.25)"
  write(ilun,format)"!!      dt_imp=dt_imp/real(nsub_imp)"
  write(ilun,format)"!!   endif"
  write(ilun,format)"  if(ngrp .gt. 1 .and. maxval(dener) .gt. 1.d4)then"
  write(ilun,format)"     nsub_imp=10"
  write(ilun,format)"     dt_imp=dt_imp/real(nsub_imp)"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        print*,'ilevel',ilevel,'igroup',igroup,'MAXIMUM OF DENER=',dener(igroup),'NSUB_IMP=',nsub_imp"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do isub=1,nsub_imp"
  write(ilun,format)"  !benoit"
  write(ilun,format)""
  write(ilun,format)"  "
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)""
  write(ilun,format)"     density = scale_d * max(uold(this,1),smallr)"
  write(ilun,format)"     temp = uold(this,nvar)*Tr_floor"
  write(ilun,format)""
  write(ilun,format)"     ! Compute Rosseland opacity (Compute kappa*rho)"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        !do igrp=1, 1000"
  write(ilun,format)"        !   temp = 10.0d0**(0.5+log10(igrp*1.0d0))"
  write(ilun,format)"        !   if(myid==1)write(*,*) 'temp= , kr = ', temp, rosseland_ana(density,temp,tr,igroup)/density"
  write(ilun,format)"        !enddo"
  write(ilun,format)"        Tr = cal_Teg(uold(this,firstindex_er+igroup)*scale_E0,igroup)"
  write(ilun,format)"        kappaR_bicg(this,igroup)= rosseland_ana(density,temp,tr,igroup) / scale_kappa"
  write(ilun,format)"        if(kappaR_bicg(this,igroup)*dx_loc .lt. min_optical_depth) kappaR_bicg(this,igroup)=min_optical_depth/dx_loc"
  write(ilun,format)"     enddo"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Update boundaries"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  call make_virtual_fine_dp(uold(1,nvar),ilevel)"
  write(ilun,format)"  call make_virtual_fine_dp(unew(1,nvar),ilevel)"
  write(ilun,format)"  do igrp=1,ngrp"
  write(ilun,format)"     call make_virtual_fine_dp(kappaR_bicg(1,igrp),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"#endif"
  write(ilun,format)"  call make_virtual_fine_dp(unew(1,nvar+1),ilevel)"
  write(ilun,format)""
  write(ilun,format)"  call make_virtual_fine_dp(uold(1,5),ilevel)"
  write(ilun,format)"  call make_virtual_fine_dp(unew(1,5),ilevel)"
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,ind_bicg(irad)),ilevel)"
  write(ilun,format)"     call make_virtual_fine_dp(unew(1,ind_bicg(irad)),ilevel)"
  write(ilun,format)""
  write(ilun,format)"     do ivar=1,10+2*ndim"
  write(ilun,format)"        call make_virtual_fine_dp(var_bicg(:,irad,ivar),ilevel)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     if(block_diagonal_precond_bicg) then"
  write(ilun,format)"        do ivar=1,nvar_bicg"
  write(ilun,format)"           call make_virtual_fine_dp(precond_bicg(:,irad,ivar),ilevel)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  call make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  !==========================================="
  write(ilun,format)"  ! Compute the matrix and vector coefficients"
  write(ilun,format)"  !==========================================="
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  call cmp_matrix_and_vector_coeff_fld(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  call cmp_matrix_and_vector_coeff_m1(ilevel)"
  write(ilun,format)"#endif"
  write(ilun,format)"  !=============================================="
  write(ilun,format)"  ! Update preconditionner M=1/diag(A) boundaries"
  write(ilun,format)"  !=============================================="
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     if(block_diagonal_precond_bicg) then"
  write(ilun,format)"        do i=1,nvar_bicg"
  write(ilun,format)"           call make_virtual_fine_dp(precond_bicg(:,irad,i),ilevel)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     else"
  write(ilun,format)"        call make_virtual_fine_dp(var_bicg(:,irad,4),ilevel)"
  write(ilun,format)"     endif"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"!!   write(*,*) 'debug matrix - vect'"
  write(ilun,format)"!!   do i=1,nb_ind"
  write(ilun,format)"!!      this = liste_ind(i)"
  write(ilun,format)"!!      do irad=1,nvar_bicg"
  write(ilun,format)"!!         write(*,'(3(3(ES11.3),2x),5x,ES11.3)') (coeff_glob_left(this,irad,jrad,1),jrad=1,nvar_bicg),(mat_residual_glob(this,irad,jrad),jrad=1,nvar_bicg),(coeff_glob_right(this,irad,jrad,1),jrad=1,nvar_bicg),residual_glob(this,irad)"
  write(ilun,format)"!!      enddo"
  write(ilun,format)"!!      write(*,*)"
  write(ilun,format)"!!   enddo"
  write(ilun,format)"!!   read(*,*)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !=================================================================="
  write(ilun,format)"  ! Compute r1 = b1 - A1x1 and store it into var_bicg(1:ncell,irad,1)"
  write(ilun,format)"  !=================================================================="
  write(ilun,format)"  call cmp_matrix_vector_product(ilevel,1)"
  write(ilun,format)"  if(bicg_to_cg)then"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           this = liste_ind(i)"
  write(ilun,format)"           var_bicg(this,irad,2) = var_bicg(this,irad,1)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"  endif"
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     call make_virtual_fine_dp(var_bicg(:,irad,1),ilevel)"
  write(ilun,format)"     call make_virtual_fine_dp(var_bicg(:,irad,2),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  if(.not.bicg_to_cg) then"
  write(ilun,format)"     !========================================================================="
  write(ilun,format)"     ! BiCGSTAB: Compute rbar_0 = r1 and store it into var_bicg(1:ncell,irad,9)"
  write(ilun,format)"     !========================================================================="
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           this = liste_ind(i)"
  write(ilun,format)"           var_bicg(this,irad,9) = var_bicg(this,irad,1)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"    rho_bicg_old = one"
  write(ilun,format)"    rho_bicg_new = one"
  write(ilun,format)"  alpha_bicg     = one"
  write(ilun,format)"  omega_bicg     = one"
  write(ilun,format)"  if(bicg_to_cg) omega_bicg=zero"
  write(ilun,format)""
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  ! All     : Set v0 = 0 and store it into var_bicg(1:ncell,irad,3)"
  write(ilun,format)"  ! BiCGSTAB: Set p0 = 0 and store it into var_bicg(1:ncell,irad,2)"
  write(ilun,format)"  !================================================================"
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     do i=1,nb_ind"
  write(ilun,format)"        this = liste_ind(i)"
  write(ilun,format)"        if(.not.bicg_to_cg) var_bicg(this,irad,2) = zero"
  write(ilun,format)"        var_bicg(this,irad,3) = zero"
  write(ilun,format)"     enddo"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  !============================="
  write(ilun,format)"  ! Compute right-hand side norm"
  write(ilun,format)"  !============================="
  write(ilun,format)"  call dot_product_tot(var_bicg(:,:,1),var_bicg(:,:,1),rhs_norm1,final_sum)"
  write(ilun,format)" "
  write(ilun,format)"  !============================================================"
  write(ilun,format)"  ! Compute z_0 = K^{-1} r and store it into var_bicg(i,irad,6)"
  write(ilun,format)"  !============================================================"
  write(ilun,format)"  if(bicg_to_cg)then!neilneil"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           this = liste_ind(i)"
  write(ilun,format)"           if(block_diagonal_precond_bicg) then"
  write(ilun,format)"              var_bicg(this,irad,6)=zero"
  write(ilun,format)"              do jrad=1,nvar_bicg"
  write(ilun,format)"                 var_bicg(this,irad,6) = var_bicg(this,irad,6) + precond_bicg(this,irad,jrad) * var_bicg(this,jrad,1)"
  write(ilun,format)"              enddo"
  write(ilun,format)"           else"
  write(ilun,format)"              var_bicg(this,irad,6) = var_bicg(this,irad,4) * var_bicg(this,irad,1)"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     enddo"
  write(ilun,format)"  endif !neilneil"
  write(ilun,format)""
  write(ilun,format)"  !===================="
  write(ilun,format)"  ! MAIN ITERATION LOOP"
  write(ilun,format)"  !====================   "
  write(ilun,format)""
  write(ilun,format)"  iter=0; itermax=200000"
  write(ilun,format)""
  write(ilun,format)"  error_ini=sqrt(rhs_norm1)"
  write(ilun,format)"  error=error_ini"
  write(ilun,format)""
  write(ilun,format)"  max_loc=2.*epsilon"
  write(ilun,format)""
  write(ilun,format)"!  do while(error_ini.ne.zero .and. error/error_ini>epsilon .and.iter<itermax .and. error_ini .gt. 1.0e-12_dp)"
  write(ilun,format)"!  do while(error/error_ini>epsilon .and.iter<itermax .and. error_cg_loc .gt. epsilon)! .and. error_ini/norm_er .gt. 1.0d-15)"
  write(ilun,format)"  do while((max_loc>epsilon .or. error/error_ini>epsilon).and.iter<itermax)"
  write(ilun,format)""
  write(ilun,format)"     iter=iter+1"
  write(ilun,format)""
  write(ilun,format)"     !========================================="
  write(ilun,format)"     ! BiCGSTAB: Compute rho_bicg_new = rbar0.r"
  write(ilun,format)"     ! BiCG2CG : Compute rho_bicg_new = r.z"
  write(ilun,format)"     !========================================="
  write(ilun,format)"     call dot_product_tot(var_bicg(:,:,i_rho),var_bicg(:,:,1),r2,final_sum)"
  write(ilun,format)"     rho_bicg_new = r2 ! real(final_sum)"
  write(ilun,format)""
  write(ilun,format)"     !================================================================================"
  write(ilun,format)"     ! BiCGSTAB: Compute beta_bicg = rho_bicg_new/rho_bicg_old * alpha_bicg/omega_bicg"
  write(ilun,format)"     ! BiCG2CG : Compute beta_bicg = rho_bicg_new/rho_bicg_old = (r.z)/(rold.zold)"
  write(ilun,format)"     !================================================================================"
  write(ilun,format)"     if(bicg_to_cg) then"
  write(ilun,format)"        if(iter==1) then"
  write(ilun,format)"           beta_bicg = zero"
  write(ilun,format)"        else"
  write(ilun,format)"           beta_bicg = rho_bicg_new/rho_bicg_old"
  write(ilun,format)"        endif"
  write(ilun,format)"     else"
  write(ilun,format)"        beta_bicg = rho_bicg_new/rho_bicg_old * alpha_bicg/omega_bicg"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !====================================================================="
  write(ilun,format)"     ! BiCGSTAB: Recurrence on p = r + beta_bicg*p - omega_bicg*beta_bicg*v "
  write(ilun,format)"     ! BiCG2CG : Recurrence on p = z + beta_bicg*p "
  write(ilun,format)"     !====================================================================="
  write(ilun,format)"     call cX_plus_Y_to_Z_tot (beta_bicg,var_bicg(:,:,2),var_bicg(:,:,i_beta),var_bicg(:,:,2))"
  write(ilun,format)"     if(.not.bicg_to_cg)then"
  write(ilun,format)"        call cX_plus_Y_to_Z_tot (-omega_bicg*beta_bicg,var_bicg(:,:,3),var_bicg(:,:,2),var_bicg(:,:,2))"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     call make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        call make_virtual_fine_dp(var_bicg(:,irad,2),ilevel)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     if(.not.bicg_to_cg)then"
  write(ilun,format)"        !===================================================================="
  write(ilun,format)"        ! BiCGSTAB: Compute y = K^{-1} p and store it into var_bicg(i,irad,5)"
  write(ilun,format)"        !===================================================================="
  write(ilun,format)"        do irad=1,nvar_bicg"
  write(ilun,format)"           do i=1,nb_ind"
  write(ilun,format)"              this = liste_ind(i)"
  write(ilun,format)"              "
  write(ilun,format)"              if(block_diagonal_precond_bicg) then"
  write(ilun,format)"                 var_bicg(this,irad,5)=zero"
  write(ilun,format)"                 do jrad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(this,irad,5) = var_bicg(this,irad,5) + precond_bicg(this,irad,jrad) * var_bicg(this,jrad,2)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              else"
  write(ilun,format)"                 var_bicg(this,irad,5) = var_bicg(this,irad,4) * var_bicg(this,irad,2)"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"        enddo"
  write(ilun,format)"        ! Update boundaries"
  write(ilun,format)"        call make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"        do irad=1,nvar_bicg"
  write(ilun,format)"           call make_virtual_fine_dp(var_bicg(:,irad,5),ilevel)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !==============================================================="
  write(ilun,format)"     ! BiCGSTAB: Compute v = A y and store it into var_bicg(i,irad,3)"
  write(ilun,format)"     ! BiCG2CG : Compute v = A p and store it into var_bicg(i,irad,3)"
  write(ilun,format)"     !==============================================================="
  write(ilun,format)"     call cmp_matrix_vector_product(ilevel,2)"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        call make_virtual_fine_dp(var_bicg(:,irad,3),ilevel)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     !=========================="
  write(ilun,format)"     ! BiCGSTAB: Compute rbar0.v"
  write(ilun,format)"     ! BiCG2CG : Compute p.Ap"
  write(ilun,format)"     !=========================="
  write(ilun,format)"     call dot_product_tot(var_bicg(:,:,i_pAp),var_bicg(:,:,3),r2,final_sum)"
  write(ilun,format)""
  write(ilun,format)"     !==========================================================================="
  write(ilun,format)"     ! BiCGSTAB: Compute scalar alpha_bicg = rho_bicg_new (=rbar0.r) / (rbar_0,v)"
  write(ilun,format)"     ! BiCG2CG : Compute scalar alpha_bicg = rho_bicg_new (=r.z) / p.Ap"
  write(ilun,format)"     !==========================================================================="
  write(ilun,format)"     if(r2.eq.zero) then"
  write(ilun,format)"        alpha_bicg = zero"
  write(ilun,format)"     else"
  write(ilun,format)"        alpha_bicg = rho_bicg_new / r2  ! real(final_sum)"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !==============================================================================="
  write(ilun,format)"     ! BiCGSTAB: Recurrence on s = r - alpha_bicg*v   and store it in var_bicg(:,:,7)"
  write(ilun,format)"     ! BiCG2CG : Recurrence on r = r - alpha_bicg*A.p and store it in var_bicg(:,:,1)"
  write(ilun,format)"     !==============================================================================="
  write(ilun,format)"     call cX_plus_Y_to_Z_tot (-alpha_bicg,var_bicg(:,:,3),var_bicg(:,:,1),var_bicg(:,:,i_s))"
  write(ilun,format)""
  write(ilun,format)"     !===================================================================="
  write(ilun,format)"     ! BiCGSTAB: Compute z = K^{-1} s and store it into var_bicg(i,irad,6)"
  write(ilun,format)"     ! BiCG2CG : Compute z = K^{-1} r and store it into var_bicg(i,irad,6)"
  write(ilun,format)"     !===================================================================="
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           this = liste_ind(i)"
  write(ilun,format)""
  write(ilun,format)"           if(block_diagonal_precond_bicg) then"
  write(ilun,format)"              var_bicg(this,irad,6)=zero"
  write(ilun,format)"              do jrad=1,nvar_bicg"
  write(ilun,format)"                 var_bicg(this,irad,6) = var_bicg(this,irad,6) + precond_bicg(this,irad,jrad) * var_bicg(this,jrad,i_s)"
  write(ilun,format)"              enddo"
  write(ilun,format)"           else"
  write(ilun,format)"              var_bicg(this,irad,6) = var_bicg(this,irad,4) * var_bicg(this,irad,i_s)"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     if(.not.bicg_to_cg)then"
  write(ilun,format)""
  write(ilun,format)"        ! Update boundaries"
  write(ilun,format)"        call make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"        do irad=1,nvar_bicg"
  write(ilun,format)"           call make_virtual_fine_dp(var_bicg(:,irad,6),ilevel)"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        !==============================================================="
  write(ilun,format)"        ! BiCGSTAB: Compute t = A z and store it into var_bicg(i,irad,8)"
  write(ilun,format)"        !==============================================================="
  write(ilun,format)"        call cmp_matrix_vector_product(ilevel,6)"
  write(ilun,format)""
  write(ilun,format)"        !====================================================================================="
  write(ilun,format)"        ! BiCGSTAB: Compute K^{-1} t to compute omega_bicg and store it in var_bicg(i,irad,10)"
  write(ilun,format)"        !====================================================================================="
  write(ilun,format)"        do irad=1,nvar_bicg"
  write(ilun,format)"           do i=1,nb_ind"
  write(ilun,format)"              this = liste_ind(i)"
  write(ilun,format)""
  write(ilun,format)"              if(block_diagonal_precond_bicg) then"
  write(ilun,format)"                 var_bicg(this,irad,10)=zero"
  write(ilun,format)"                 do jrad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(this,irad,10) = var_bicg(this,irad,10) + precond_bicg(this,irad,jrad) * var_bicg(this,jrad,8)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              else"
  write(ilun,format)"                 var_bicg(this,irad,10) = var_bicg(this,irad,4) * var_bicg(this,irad,8)"
  write(ilun,format)"              endif"
  write(ilun,format)"           end do"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        !============================================================================="
  write(ilun,format)"        ! BiCGSTAB: Compute omega_bicg = (K^{-1} t , K^{-1} s) / (K^{-1} t , K^{-1} t)"
  write(ilun,format)"        !============================================================================="
  write(ilun,format)"        call dot_product_tot(var_bicg(:,:,10),var_bicg(:,:, 6),r2,final_sum)"
  write(ilun,format)"        call dot_product_tot(var_bicg(:,:,10),var_bicg(:,:,10),r3,final_sum)"
  write(ilun,format)""
  write(ilun,format)"        if(r3.eq.zero) then"
  write(ilun,format)"           omega_bicg = zero"
  write(ilun,format)"        else"
  write(ilun,format)"           omega_bicg = r2 / r3"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"     else"
  write(ilun,format)""
  write(ilun,format)"        omega_bicg = zero"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)"     "
  write(ilun,format)"     !==========================="
  write(ilun,format)"     ! Compute maximum variations"
  write(ilun,format)"     !==========================="
  write(ilun,format)"     max_loc=zero"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           this = liste_ind(i)"
  write(ilun,format)"           if(uold(this,ind_bicg(irad)).ne.zero)then"
  write(ilun,format)"              max_loc=max(max_loc,abs((alpha_bicg*var_bicg(this,irad,i_y)+&"
  write(ilun,format)"                      omega_bicg*var_bicg(this,irad,6))/uold(this,ind_bicg(irad))))"
  write(ilun,format)"           endif"
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(max_loc,max_loc_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"     max_loc = max_loc_all"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     !======================================================="
  write(ilun,format)"     ! BiCGSTAB: Recurrence on x = x + alpha*y + omega_bicg*z"
  write(ilun,format)"     ! BiCG2CG : Recurrence on x = x + alpha*p"
  write(ilun,format)"     !======================================================="
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        call cX_plus_Y_to_Z (alpha_bicg,var_bicg(:,irad,i_y),unew(:,ind_bicg(irad)),unew(:,ind_bicg(irad)))"
  write(ilun,format)"        if(.not.bicg_to_cg) call cX_plus_Y_to_Z (omega_bicg,var_bicg(:,irad,6),unew(:,ind_bicg(irad)),unew(:,ind_bicg(irad)))"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     !============================================="
  write(ilun,format)"     ! BiCGSTAB: Recurrence on r = s - omega_bicg*t"
  write(ilun,format)"     !============================================="
  write(ilun,format)"     if(.not.bicg_to_cg)then"
  write(ilun,format)"        call cX_plus_Y_to_Z_tot (-omega_bicg,var_bicg(:,:,8),var_bicg(:,:,i_s),var_bicg(:,:,1))"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     !==================================="
  write(ilun,format)"     ! Update rho_bicg_old = rho_bicg_new"
  write(ilun,format)"     !==================================="
  write(ilun,format)"     rho_bicg_old = rho_bicg_new"
  write(ilun,format)""
  write(ilun,format)"     !==================================="
  write(ilun,format)"     ! Compute right-hand side norm"
  write(ilun,format)"     !==================================="
  write(ilun,format)"     call dot_product_tot(var_bicg(:,:,1),var_bicg(:,:,1),rhs_norm1,final_sum)"
  write(ilun,format)""
  write(ilun,format)"     error=SQRT(rhs_norm1)"
  write(ilun,format)""
  write(ilun,format)"     if(verbose) then"
  write(ilun,format)"        if (error_ini.ne.zero) then"
  write(ilun,format)"           write(*,112)iter,error,error/error_ini,max_loc,error_ini"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,112)iter,error"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End main iteration loop"
  write(ilun,format)""
  write(ilun,format)"  if(iter >= itermax)then"
  write(ilun,format)"     if(myid==1)write(*,*)'Radiative transfer failed to converge after ',iter,' iterations'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !===================================="
  write(ilun,format)"  ! Copie des flux"
  write(ilun,format)"  !===================================="
  write(ilun,format)"  call cmp_matrix_vector_product(ilevel,4)"
  write(ilun,format)""
  write(ilun,format)"  niter=niter+iter"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  !===================================="
  write(ilun,format)"  ! Update gas temperature"
  write(ilun,format)"  !===================================="
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)""
  write(ilun,format)"     rho = uold(liste_ind(i),1)               ! [-] = adimensioned"
  write(ilun,format)"     Told= uold(liste_ind(i),nvar) * Tr_floor ! [K]"
  write(ilun,format)"     Cv = unew(liste_ind(i),nvar+1)           ! [K^-1]"
  write(ilun,format)"     "
  write(ilun,format)"     rhs=zero"
  write(ilun,format)"     lhs=zero"
  write(ilun,format)"     do igrp=1,ngrp"
  write(ilun,format)"        Trold = cal_Teg(uold(liste_ind(i),firstindex_er+igrp)*scale_E0,igrp)"
  write(ilun,format)"        !do im1=1, 1000"
  write(ilun,format)"        !   temp = 10.0d0**(0.5+log10(im1*1.0d0))"
  write(ilun,format)"        !   if(myid==1)write(*,*) 'temp= , kp = ', temp, planck_ana(1.0d0,temp,tr,igrp)+planck_ana_scat(1.0d0,temp,tr,igrp)"
  write(ilun,format)"        !enddo"
  write(ilun,format)"        wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igrp)/scale_kappa"
  write(ilun,format)"        wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igrp)/scale_kappa"
  write(ilun,format)"        "
  write(ilun,format)"!!         rhs=rhs-P_cal*wdt*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0 &"
  write(ilun,format)"!!              & -unew(liste_ind(i),firstindex_er+igrp))"
  write(ilun,format)"        rhs=rhs-P_cal*wdtB*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0) &"
  write(ilun,format)"             & + P_cal*wdtE*unew(liste_ind(i),firstindex_er+igrp) ! [-]"
  write(ilun,format)""
  write(ilun,format)"        lhs=lhs+P_cal*wdtB*deriv_radiation_source(Told,igrp)/scale_E0 ! [K^-1]"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     protostellar_heating = 0.0d0"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(rt_protostar_m1 .and. rt_advect)then"
  write(ilun,format)"        do im1=1,ngroups"
  write(ilun,format)"           protostellar_heating = rtuold(liste_ind(i),iGroups(im1))*scale_Np*group_egy(im1)*ev_to_erg*kappaAbs(im1)*rho*scale_d*rt_c_cgs*z_ave / (scale_d*scale_v**2)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     protostellar_heating = protostellar_heating * dt_imp * scale_t ! ph [s-1] * t [s] ; same unit as cvTold, rhs"
  write(ilun,format)""
  write(ilun,format)"!     unew(liste_ind(i),nvar) = (cv*Told+rhs)/(cv+lhs) / Tr_floor !No M1 E injection or injection into Erad equation"
  write(ilun,format)"     unew(liste_ind(i),nvar) = (cv*Told+rhs+protostellar_heating)/(cv+lhs) / Tr_floor !M1 injection into internal energy"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(debug_energy)then"
  write(ilun,format)"  write(*,*) 'After iterations - uold(5-9)-unew(5-9)'"
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     write(*,'(12(ES15.6))') uold(this,5),uold(this,nvar),uold(this,9),uold(this,10),unew(this,5),unew(this,nvar),unew(this,9),unew(this,10)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  read(*,*)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1 .and. (mod(nstep,ncontrol)==0)) then"
  write(ilun,format)"     if(bicg_to_cg) then "
  write(ilun,format)"        if(error_ini.ne.zero) then"
  write(ilun,format)"           write(*,117)ilevel,iter,error/error_ini,max_loc"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)' CG :',iter, 'error_ini=',error_ini"
  write(ilun,format)"        endif"
  write(ilun,format)"     else"
  write(ilun,format)"        if(error_ini.ne.zero) then"
  write(ilun,format)"           write(*,118)ilevel,iter,error/error_ini,max_loc"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)' BiCGSTAB :',iter, 'error_ini=',error_ini"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     write(*,*)'niter tot=',niter"
  write(ilun,format)"     if(error_ini.ne.zero) then"
  write(ilun,format)"        write(*,115)ilevel,iter,error,error/error_ini"
  write(ilun,format)"     else"
  write(ilun,format)"        write(*,115)ilevel,iter,error"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  call make_boundary_diffusion_tot(ilevel)"
  write(ilun,format)"  !benoit"
  write(ilun,format)"end do"
  write(ilun,format)"!End loop over NR iteration"
  write(ilun,format)"  !benoit"
  write(ilun,format)""
  write(ilun,format)"  !===================="
  write(ilun,format)"  ! Update energy value"
  write(ilun,format)"  !===================="
  write(ilun,format)"  if(static) then"
  write(ilun,format)"     do i=1,nb_ind"
  write(ilun,format)"        do irad = 1,nvar_bicg"
  write(ilun,format)"           uold(liste_ind(i),ind_bicg(irad)) = unew(liste_ind(i),ind_bicg(irad))*norm_bicg(irad)"
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"  else"
  write(ilun,format)"     call cmp_energy(2)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(debug_energy)then"
  write(ilun,format)"  write(*,*) 'after cmp_energy 2'"
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     write(*,'(12(ES15.6))') uold(this,5),uold(this,nvar),uold(this,9),uold(this,10),unew(this,5),unew(this,nvar),unew(this,9),unew(this,10)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  read(*,*)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Update boundaries"
  write(ilun,format)"  do irad=1,nvar_trad"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,ind_trad(irad)),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  do irad=1,nvar_bicg"
  write(ilun,format)"     if(ilevel .gt. levelmin)call make_virtual_reverse_dp(rad_flux(1,irad),ilevel-1)"
  write(ilun,format)"     call make_virtual_reverse_dp(rad_flux(1,irad),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  call make_virtual_fine_dp(uold(1,5),ilevel)"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering diffusion_cg')"
  write(ilun,format)"112 format('   ==> Step=',i5,' Error=',2(1pe10.3,1x),e23.15,es18.5)"
  write(ilun,format)"115 format('   ==> Level=',i5,' Step=',i5,' Error=',2(1pe10.3,1x))"
  write(ilun,format)"117 format('   ==> Level=',i5,' Iteration CG=',i5,' Error L2=',(1pe10.3,1x),' Error Linf=',(1pe10.3,1x))"
  write(ilun,format)"118 format('   ==> Level=',i5,' Iteration BiCGSTAB=',i5,' Error L2=',(1pe10.3,1x),' Error Linf=',(1pe10.3,1x))"
  write(ilun,format)""
  write(ilun,format)"  deallocate(liste_ind)"
  write(ilun,format)""
  write(ilun,format)"contains"
  write(ilun,format)""
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  !###########################################################"
  write(ilun,format)""
  write(ilun,format)"  subroutine cX_plus_Y_to_Z (cste,vectX,vectY,vectZ) ! vectZ = cste*vectX+vectY"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax),intent(IN)::vectX,vectY"
  write(ilun,format)"    real(dp),intent(IN)::cste"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax),intent(OUT)::vectZ"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"    do i=1,nb_ind"
  write(ilun,format)"       vectZ(liste_ind(i)) = vectY(liste_ind(i)) + cste*vectX(liste_ind(i)) "
  write(ilun,format)"    end do"
  write(ilun,format)""
  write(ilun,format)"  end subroutine cX_plus_Y_to_Z"
  write(ilun,format)""
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  !###########################################################"
  write(ilun,format)""
  write(ilun,format)"  subroutine dot_product_tot(fact1,fact2,dot_pdt,local_sum) ! dot_pdt = sum(fact1*fact2)"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax,1:nvar_bicg),intent(IN)::fact1,fact2"
  write(ilun,format)"    real(dp),intent(OUT)::dot_pdt"
  write(ilun,format)"    complex*16,intent(OUT)::local_sum"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    real(dp)::dot_pdt_all"
  write(ilun,format)"#endif"
  write(ilun,format)"    complex*16 ::global_sum"
  write(ilun,format)"    integer::this"
  write(ilun,format)""
  write(ilun,format)"    dot_pdt=zero"
  write(ilun,format)"    local_sum = cmplx(zero,zero)"
  write(ilun,format)"    global_sum = cmplx(zero,zero)"
  write(ilun,format)""
  write(ilun,format)"    do irad=1,nvar_bicg"
  write(ilun,format)"       do i=1,nb_ind"
  write(ilun,format)"          this = liste_ind(i)"
  write(ilun,format)"          !call DDPDD (cmplx(fact1(this,irad)*fact2(this,irad), zero,dp), local_sum, 1, itype)"
  write(ilun,format)"          dot_pdt = dot_pdt + fact1(this,irad)*fact2(this,irad)"
  write(ilun,format)"       end do"
  write(ilun,format)"    enddo"
  write(ilun,format)""
  write(ilun,format)"    ! Compute global norms"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    call MPI_ALLREDUCE(dot_pdt,dot_pdt_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"    dot_pdt   = dot_pdt_all"
  write(ilun,format)"!!   	call MPI_ALLREDUCE(local_sum,global_sum,1,MPI_COMPLEX,MPI_SUMDD,MPI_COMM_WORLD,info)"
  write(ilun,format)"!! 	local_sum = global_sum"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  end subroutine dot_product_tot"
  write(ilun,format)""
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  !###########################################################"
  write(ilun,format)""
  write(ilun,format)"  subroutine cX_plus_Y_to_Z_tot (cste,vectX,vectY,vectZ) ! vectZ = cste*vectX+vectY"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax,1:nvar_bicg),intent(IN)::vectX,vectY"
  write(ilun,format)"    real(dp),intent(IN)::cste"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax,1:nvar_bicg),intent(OUT)::vectZ"
  write(ilun,format)""
  write(ilun,format)"    do irad=1,nvar_bicg"
  write(ilun,format)"       do i=1,nb_ind"
  write(ilun,format)"          vectZ(liste_ind(i),irad) = vectY(liste_ind(i),irad) + cste*vectX(liste_ind(i),irad) "
  write(ilun,format)"       end do"
  write(ilun,format)"    enddo"
  write(ilun,format)""
  write(ilun,format)"  end subroutine cX_plus_Y_to_Z_tot"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine diffusion_cg"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine cmp_matrix_and_vector_coeff_fld(ilevel)"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! This routine computes the matrix A and vector b"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons,only:active,ncoarse,nbor,son,myid"
  write(ilun,format)"  use amr_parameters, only : ndim"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::ilevel"
  write(ilun,format)"  integer :: igroup,irad"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"!!   real(dp),dimension(1:nvector  ,1:  nvar_bicg),save:: C_g,C_d"
  write(ilun,format)""
  write(ilun,format)"  integer :: i,idim,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)""
  write(ilun,format)"#if NGRP>1"
  write(ilun,format)"  ! variables used by the LAPACK inversion routines"
  write(ilun,format)"  integer, parameter                        :: nwork = 256"
  write(ilun,format)"  integer                                   :: info2"
  write(ilun,format)"  integer                                   :: lda,lwork"
  write(ilun,format)"  integer, dimension(      nvar_bicg)       :: ipiv"
  write(ilun,format)"  integer, dimension(nwork*nvar_bicg)       :: work"
  write(ilun,format)"  real(dp),dimension(1:nvar_bicg,1:nvar_bicg) ::inv"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(nvar_bicg,nvar_bicg)::coeff_left,coeff_right,mat_residual"
  write(ilun,format)"  real(dp),dimension(nvar_bicg          )::residual"
  write(ilun,format)"  "
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1               !direction of left nbor grid"
  write(ilun,format)"              supD = 0                          !direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"           else"
  write(ilun,format)"              supG = 0                          !direction of left nbor grid"
  write(ilun,format)"              supD = (idim-1)*2+2               !direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor index offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"              ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then ! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else                             ! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else                                ! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then ! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else                              ! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else                                 ! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        end do !ndim"
  write(ilun,format)"        "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"              call compute_residual_in_cell(ind_cell(i),vol_loc,residual,mat_residual)"
  write(ilun,format)""
  write(ilun,format)"              do igroup=1,ngrp"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    if(store_matrix) mat_residual_glob(ind_cell(i),igroup,igrp) = mat_residual(igroup,igrp)"
  write(ilun,format)"                    if(block_diagonal_precond_bicg.or.igroup==igrp) then"
  write(ilun,format)"                       precond_bicg(ind_cell(i),igroup,igrp) = mat_residual(igroup,igrp)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 if(store_matrix) residual_glob(ind_cell(i),igroup) = residual(igroup)"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        ! Compute off-diagonal terms"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 call compute_coeff_left_right_in_cell(ind_cell(i),idim,cell_left(i,idim),cell_right(i,idim),nbor_ilevel(i,1:2*ndim),dx_loc,coeff_left,coeff_right)"
  write(ilun,format)""
  write(ilun,format)"                 do igroup=1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                    if(store_matrix)then"
  write(ilun,format)"                       coeff_glob_left (ind_cell(i),igroup,igroup,idim)=coeff_left(igroup,igroup)"
  write(ilun,format)"                       coeff_glob_right(ind_cell(i),igroup,igroup,idim)=coeff_right(igroup,igroup)"
  write(ilun,format)"                    endif"
  write(ilun,format)""
  write(ilun,format)"                    precond_bicg(ind_cell(i),igroup,igroup) = precond_bicg(ind_cell(i),igroup,igroup) + (coeff_left(igroup,igroup) + coeff_right(igroup,igroup))*alpha_imp"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        enddo !ndim"
  write(ilun,format)""
  write(ilun,format)"        ! Compute preconditionning matrix                                                               "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"#if NGRP>1"
  write(ilun,format)"              if(block_diagonal_precond_bicg) then"
  write(ilun,format)"                 inv = precond_bicg(ind_cell(i),1:nvar_bicg,1:nvar_bicg)"
  write(ilun,format)"                 lda = nvar_bicg ; lwork = nwork*nvar_bicg"
  write(ilun,format)"                 "
  write(ilun,format)"                 ! Invert the (nvar_bicg x nvar_bicg) matrix using LAPACK routines                      "
  write(ilun,format)"                 !"
  write(ilun,format)"                 ! DGETRF computes an LU factorization of a general M-by-N matrix A                     "
  write(ilun,format)"                 ! using partial pivoting with row interchanges                                         "
  write(ilun,format)"                 call dgetrf(nvar_bicg,nvar_bicg,inv,lda,ipiv,info2)"
  write(ilun,format)"                 "
  write(ilun,format)"                 ! DGETRI computes the inverse of a matrix using the LU factorization                   "
  write(ilun,format)"                 ! computed by DGETRF                                                                   "
  write(ilun,format)"                 call dgetri(nvar_bicg,inv,lda,ipiv,work,lwork,info2)"
  write(ilun,format)"                 "
  write(ilun,format)"                 precond_bicg(ind_cell(i),1:nvar_bicg,1:nvar_bicg)=inv"
  write(ilun,format)"              else"
  write(ilun,format)"#endif"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(ind_cell(i),irad,4) = one/precond_bicg(ind_cell(i),irad,irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"#if NGRP>1"
  write(ilun,format)"              endif"
  write(ilun,format)"#endif"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do !ngrid"
  write(ilun,format)"        "
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do ! ncache"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_matrix_and_vector_coeff_fld"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine cmp_matrix_and_vector_coeff_m1(ilevel)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the matrix A to vect_in and create vect_out"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  use amr_commons,only:active,ncoarse,nbor,son,myid"
  write(ilun,format)"  use amr_parameters, only : ndim"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::ilevel"
  write(ilun,format)"  integer :: igroup,irad,jrad"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector  ,1:  nvar_bicg),save:: residu"
  write(ilun,format)"  real(dp),dimension(1:3,1:3,1:nvar_trad+1+nvar_bicg) :: var_rad_subset"
  write(ilun,format)"  real(dp),dimension(1:ngrp):: deriv"
  write(ilun,format)""
  write(ilun,format)"  ! M1 variables:"
  write(ilun,format)"  !"
  write(ilun,format)"  ! var_rad_subset(i,idim,irad)"
  write(ilun,format)"  !   - dimension 1 : 1 -> 3   : left neighbour, i, right neighbour"
  write(ilun,format)"  !   - dimension 2 : 1 -> ndim: direction of interest for flux computations"
  write(ilun,format)"  !   - dimension 3 : 1 -> nvar_trad + 1+nvar_bicg :       1                          is Told "
  write(ilun,format)"  !                                                        2 :  ngrp+1                is Er"
  write(ilun,format)"  !                                                    ngrp+2:2*ngrp+1                is Frx"
  write(ilun,format)"  !                                                  2*ngrp+2:3*ngrp+1                is Fry"
  write(ilun,format)"  !            IN 3D                                 3*ngrp+2:4*ngrp+1                is Frz"
  write(ilun,format)"  !                                               nvar_trad+1                         is rho"
  write(ilun,format)"  !                                               nvar_trad+2:nvar_trad+1+nvar_bicg   is rad_flux"
  write(ilun,format)"  real(dp), dimension(       3,  3       ) :: Dedd,Dedd_dE"
  write(ilun,format)"  real(dp), dimension(       3,  3,3     ) :: Dedd_dF"
  write(ilun,format)"  real(dp), dimension(     1:3,1:3,2,3   ) :: DeddP,DeddM"
  write(ilun,format)"  real(dp), dimension(             1:ngrp) :: flux_F_tot"
  write(ilun,format)"  real(dp), dimension(      1:ndim,1:ngrp) :: flux_P_tot"
  write(ilun,format)"  real(dp), dimension(           2,1:3   ) :: eps,lm,lp,lmp"
  write(ilun,format)"  real(dp), dimension(             2,ndim) :: ErayM, ErayP, dEray"
  write(ilun,format)"  real(dp), dimension(        ndim,2,ndim) :: FrayM, FrayP, dFray"
  write(ilun,format)"  real(dp), dimension(             2,ndim) :: ffM, ffP"
  write(ilun,format)"  real(dp), dimension(     1:3,1:3,2,ndim) :: PrayM,PrayP"
  write(ilun,format)"  real(dp), dimension(             2,ndim) :: ap,am"
  write(ilun,format)"  real(dp), dimension(         3,3       ) :: Dedd_temp,Dedd_dE_temp"
  write(ilun,format)"  real(dp), dimension(         3,3,3     ) :: Dedd_dF_temp"
  write(ilun,format)"  real(dp), dimension(             1:3   ) :: Fr_temp"
  write(ilun,format)"  real(dp), dimension(3,3,       2,1:ndim) :: Dedd_ndim,Dedd_dE_ndim"
  write(ilun,format)"  real(dp), dimension(3,3,3,     2,1:ndim) :: Dedd_dF_ndim"
  write(ilun,format)"  real(dp), dimension(3,3,       2,1:ndim) :: DeddM_dE, DeddP_dE"
  write(ilun,format)"  real(dp), dimension(3,3,3,     2,1:ndim) :: DeddM_dF, DeddP_dF"
  write(ilun,format)"  real(dp), dimension(           2,1:ndim) :: flux_F"
  write(ilun,format)"  real(dp), dimension(    1:ndim,2,1:ndim) :: flux_P"
  write(ilun,format)"  real(dp)                                 :: conv"
  write(ilun,format)"  real(dp), dimension(                  2) :: signe"
  write(ilun,format)"  real(dp)                                 :: xx,v1,v2,v3,v4,r,kappa_rhoM,kappa_rhoP"
  write(ilun,format)"  real(dp)                                 :: ff1,ff2,thetaM,thetaP,interpol_valp,fM,fP,pi"
  write(ilun,format)"  real(dp)                                 :: kp,kE,kF,ks,kFM,kFP,ksM,ksP,scattering_ana"
  write(ilun,format)"  integer                                  :: iface,idim,jdim,kdim,index_e"
  write(ilun,format)"  logical                                  :: cal_valp,chi_uniforme,derive_chi"
  write(ilun,format)""
  write(ilun,format)"  integer :: i,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(       1:ngrp) :: Erold"
  write(ilun,format)"  real(dp),dimension(1:ndim,1:ngrp) :: Frold"
  write(ilun,format)"  real(dp),dimension(1:nvar_bicg  ) :: radflux"
  write(ilun,format)"  real(dp)::rho,Told,Told_norm,radiation_source,deriv_radiation_source,cv"
  write(ilun,format)"  real(dp)::dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp):: rosseland_ana,planck_ana"
  write(ilun,format)""
  write(ilun,format)"  ! variables used by the LAPACK inversion routines"
  write(ilun,format)"  integer, parameter                        :: nwork = 256"
  write(ilun,format)"  integer                                   :: info2"
  write(ilun,format)"  integer                                   :: lda,lwork"
  write(ilun,format)"  integer, dimension(      nvar_bicg)       :: ipiv"
  write(ilun,format)"  integer, dimension(nwork*nvar_bicg)       :: work"
  write(ilun,format)"  real(dp),dimension(1:nvar_bicg,1:nvar_bicg) ::inv"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = zero"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1   		!direction of left nbor grid"
  write(ilun,format)"              supD = 0              		!direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"           else"
  write(ilun,format)"              supG = 0              		!direction of left nbor grid"
  write(ilun,format)"              supD = (idim-1)*2+2   		!direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor index offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"              ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then			! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else						! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then			! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else						! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        end do !ndim"
  write(ilun,format)"        "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"              do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"                 do irad=1,nvar_trad"
  write(ilun,format)"                    var_rad_subset(1,idim,irad) = uold(cell_left (i,idim),ind_trad(irad))"
  write(ilun,format)"                    var_rad_subset(2,idim,irad) = uold(ind_cell  (i     ),ind_trad(irad))"
  write(ilun,format)"                    var_rad_subset(3,idim,irad) = uold(cell_right(i,idim),ind_trad(irad))"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 var_rad_subset(1,idim,nvar_trad+1) = uold(cell_left (i,idim),1)"
  write(ilun,format)"                 var_rad_subset(2,idim,nvar_trad+1) = uold(ind_cell  (i     ),1)"
  write(ilun,format)"                 var_rad_subset(3,idim,nvar_trad+1) = uold(cell_right(i,idim),1)"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim-1))"
  write(ilun,format)"                 case (1,-1)"
  write(ilun,format)"                    do irad=1,nvar_trad"
  write(ilun,format)"                       var_rad_subset(1,idim,irad) = var_rad_subset(1,idim,irad)/norm_trad(irad)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end select"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim))"
  write(ilun,format)"                 case (1,-1)"
  write(ilun,format)"                    do irad=1,nvar_trad"
  write(ilun,format)"                       var_rad_subset(3,idim,irad) = var_rad_subset(3,idim,irad)/norm_trad(irad)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end select"
  write(ilun,format)""
  write(ilun,format)"                 do irad = 1,nvar_bicg"
  write(ilun,format)"                    !var_rad_subset(1,idim,nvar_trad+1+irad) = rad_flux(cell_left (i,idim),irad)"
  write(ilun,format)"                    var_rad_subset(2,idim,nvar_trad+1+irad) = rad_flux(ind_cell  (i     ),irad)"
  write(ilun,format)"                    !var_rad_subset(3,idim,nvar_trad+1+irad) = rad_flux(cell_right(i,idim),irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"              !=============================================================================="
  write(ilun,format)""
  write(ilun,format)"              rho       = var_rad_subset(2,1,nvar_trad+1)"
  write(ilun,format)"              Told_norm = var_rad_subset(2,1,1)"
  write(ilun,format)"              Told      = Told_norm * Tr_floor  "
  write(ilun,format)"              Cv        = unew(ind_cell(i),nvar+1)"
  write(ilun,format)""
  write(ilun,format)"              do igrp=1,ngrp"
  write(ilun,format)"                 Erold(igrp)=var_rad_subset(2,1,1+igrp)"
  write(ilun,format)"                 ! Store the deriv_radiation_source to save computational time"
  write(ilun,format)"                 deriv(igrp)=deriv_radiation_source(Told,igrp)"
  write(ilun,format)"              enddo"
  write(ilun,format)"              do irad = 1,nvar_bicg"
  write(ilun,format)"                 radflux(irad)=var_rad_subset(2,1,nvar_trad+1+irad)"
  write(ilun,format)"              enddo"
  write(ilun,format)"              "
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    Frold(idim,igrp)=var_rad_subset(2,1,igrp+ngrp*idim+1)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"              cal_valp=.true."
  write(ilun,format)"              chi_uniforme=.false."
  write(ilun,format)"              derive_chi=.false."
  write(ilun,format)""
  write(ilun,format)"              pi=acos(-one)"
  write(ilun,format)""
  write(ilun,format)"              coeff_glob_left  (ind_cell(i),:,:,:) = zero"
  write(ilun,format)"              coeff_glob_right (ind_cell(i),:,:,:) = zero"
  write(ilun,format)"              residual_glob    (ind_cell(i),:  ) = zero"
  write(ilun,format)"              mat_residual_glob(ind_cell(i),:,:) = zero"
  write(ilun,format)"              do irad = 1,nvar_bicg"
  write(ilun,format)"                 mat_residual_glob(ind_cell(i),irad,irad) = one"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"              conv = one / Cv *P_cal/Tr_floor"
  write(ilun,format)""
  write(ilun,format)"              residual_glob(ind_cell(i),1) = Told_norm"
  write(ilun,format)""
  write(ilun,format)"              do igroup=1,ngrp"
  write(ilun,format)""
  write(ilun,format)"                 ! Fill matrix and vector"
  write(ilun,format)"                 !******************************************************************"
  write(ilun,format)"                 index_e = 1 + igroup"
  write(ilun,format)"                 !index_f=index_e+idim*ngrp !to be done inside a idim loop"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                 ! pour flux rentrants ou sortants"
  write(ilun,format)"                 signe(1) = -one ; signe(2) = one"
  write(ilun,format)""
  write(ilun,format)"     "
  write(ilun,format)"                 PrayM = zero ; PrayP = zero"
  write(ilun,format)""
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)"                    do iface = 1,2"
  write(ilun,format)""
  write(ilun,format)"           "
  write(ilun,format)"                       ErayM(iface,idim) = var_rad_subset(iface  ,idim,index_e) !+ half*dx_loc*pvar_rad_subset(1,idim,idim,igroup)"
  write(ilun,format)"                       ErayP(iface,idim) = var_rad_subset(iface+1,idim,index_e) !- half*dx_loc*pvar_rad_subset(1,idim,idim,igroup)"
  write(ilun,format)"                       if(iface == 1)then"
  write(ilun,format)"                          dEray(iface,idim) = ErayP(iface,idim) - var_rad_subset(2,idim,index_e)"
  write(ilun,format)"                       else"
  write(ilun,format)"                          dEray(iface,idim) = ErayM(iface,idim) - var_rad_subset(2,idim,index_e)"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       fM = zero"
  write(ilun,format)"                       fP = zero"
  write(ilun,format)"                       do jdim = 1,ndim"
  write(ilun,format)"                          FrayM(jdim,iface,idim) = var_rad_subset(iface  ,idim,index_e+jdim*ngrp) !+ half*dx_loc*  !!!!pvar_rad_subset(1,idim,idim,igroup)"
  write(ilun,format)"                          FrayP(jdim,iface,idim) = var_rad_subset(iface+1,idim,index_e+jdim*ngrp) !- half*dx_loc*  !!!!pvar_rad_subset(1,idim,idim,igroup)"
  write(ilun,format)"                          fM = fM + (FrayM(jdim,iface,idim)/ErayM(iface,idim))**2"
  write(ilun,format)"                          fP = fP + (FrayP(jdim,iface,idim)/ErayP(iface,idim))**2"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                       fM = sqrt(fM)"
  write(ilun,format)"                       if(fM > one)then"
  write(ilun,format)"                          r = one / fM"
  write(ilun,format)"                          do jdim = 1,ndim"
  write(ilun,format)"                             FrayM(jdim,iface,idim) = FrayM(jdim,iface,idim) * r"
  write(ilun,format)"                          enddo"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       fP = sqrt(fP)"
  write(ilun,format)"                       if(fP > one)then"
  write(ilun,format)"                          r = one / fP"
  write(ilun,format)"                          do jdim = 1,ndim"
  write(ilun,format)"                             FrayP(jdim,iface,idim) = FrayP(jdim,iface,idim) * r"
  write(ilun,format)"                          enddo"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       ffM(iface,idim) = zero ; ffP(iface,idim) = zero"
  write(ilun,format)"                       do jdim = 1,ndim"
  write(ilun,format)"                          if(iface.eq.1) then"
  write(ilun,format)"                             dFray(jdim,iface,idim) = FrayP(jdim,iface,idim)- var_rad_subset(2,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                          else"
  write(ilun,format)"                             dFray(jdim,iface,idim) = FrayM(jdim,iface,idim)- var_rad_subset(2,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                          ffM(iface,idim) = ffM(iface,idim) + FrayM(jdim,iface,idim)**2"
  write(ilun,format)"                          ffP(iface,idim) = ffP(iface,idim) + FrayP(jdim,iface,idim)**2"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                       ffM(iface,idim) = sqrt(ffM(iface,idim))/ErayM(iface,idim)"
  write(ilun,format)"                       ffP(iface,idim) = sqrt(ffP(iface,idim))/ErayP(iface,idim)"
  write(ilun,format)""
  write(ilun,format)"                       ! Calculate theta incidence angle to interpolate eigenvalues"
  write(ilun,format)"                       ! theta needs to be calculated here before ffM is changed if it is greater than 1"
  write(ilun,format)"                       if(ffM(iface,idim).gt.1.0e-05_dp) then"
  write(ilun,format)"                          xx = FrayM(idim,iface,idim)/ErayM(iface,idim)/ffM(iface,idim)"
  write(ilun,format)"                          if(abs(xx).gt.one) then"
  write(ilun,format)"                             thetaM = half*pi*(one-sign(one,xx))"
  write(ilun,format)"                          else"
  write(ilun,format)"                             thetaM = acos(xx)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                       else"
  write(ilun,format)"                          thetaM = zero"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(ffP(iface,idim).gt.1.0e-05_dp) then"
  write(ilun,format)"                          xx = FrayP(idim,iface,idim)/ErayP(iface,idim)/ffP(iface,idim)"
  write(ilun,format)"                          if(abs(xx).gt.one) then"
  write(ilun,format)"                             thetaP = half*pi*(one-sign(one,xx))"
  write(ilun,format)"                          else"
  write(ilun,format)"                             thetaP = acos(xx)"
  write(ilun,format)"                          endif"
  write(ilun,format)"                       else"
  write(ilun,format)"                          thetaP = zero"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       ! If ffM > 1 then set it to 1 - WARNING: NOT VERY SATISFACTORY!!"
  write(ilun,format)"                       if (ffM(iface,idim).gt. one) ffM(iface,idim)= one"
  write(ilun,format)"                       if (ffP(iface,idim).gt. one) ffP(iface,idim)= one"
  write(ilun,format)""
  write(ilun,format)"                       ! Compute Eddington tensor and its derivatives at the cell centre and interfaces"
  write(ilun,format)"                       if (Chi_uniforme) then "
  write(ilun,format)"                          Fr_temp=zero"
  write(ilun,format)"                          do jdim = 1,ndim"
  write(ilun,format)"                             Fr_temp(jdim) = var_rad_subset(iface+1,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                          enddo"
  write(ilun,format)"                          call cal_Dedd(var_rad_subset(iface+1,idim,index_e),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                          DeddP   (:,:  ,iface,idim) = Dedd_temp"
  write(ilun,format)"                          DeddP_dE(:,:  ,iface,idim) = Dedd_dE_temp"
  write(ilun,format)"                          DeddP_dF(:,:,:,iface,idim) = Dedd_dF_temp"
  write(ilun,format)""
  write(ilun,format)"                          Fr_temp=zero"
  write(ilun,format)"                          do jdim = 1,ndim"
  write(ilun,format)"                             Fr_temp(jdim) = var_rad_subset(iface,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                          enddo"
  write(ilun,format)"                          call cal_Dedd(var_rad_subset(iface,idim,index_e),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                          DeddM   (:,:  ,iface,idim) = Dedd_temp"
  write(ilun,format)"                          DeddM_dE(:,:  ,iface,idim) = Dedd_dE_temp"
  write(ilun,format)"                          DeddM_dF(:,:,:,iface,idim) = Dedd_dF_temp"
  write(ilun,format)""
  write(ilun,format)"                       else"
  write(ilun,format)""
  write(ilun,format)"                          Fr_temp=zero"
  write(ilun,format)"                          Fr_temp(1:ndim) = FrayP(1:ndim,iface,idim)"
  write(ilun,format)"                          call cal_Dedd(ErayP(iface,idim),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                          DeddP   (:,:  ,iface,idim) = Dedd_temp"
  write(ilun,format)"                          DeddP_dE(:,:  ,iface,idim) = Dedd_dE_temp"
  write(ilun,format)"                          DeddP_dF(:,:,:,iface,idim) = Dedd_dF_temp"
  write(ilun,format)""
  write(ilun,format)"                          Fr_temp=zero"
  write(ilun,format)"                          Fr_temp(1:ndim) = FrayM(1:ndim,iface,idim)"
  write(ilun,format)"                          call cal_Dedd(ErayM(iface,idim),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                          DeddM   (:,:  ,iface,idim) = Dedd_temp"
  write(ilun,format)"                          DeddM_dE(:,:  ,iface,idim) = Dedd_dE_temp"
  write(ilun,format)"                          DeddM_dF(:,:,:,iface,idim) = Dedd_dF_temp"
  write(ilun,format)"                          "
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       do jdim = 1,ndim"
  write(ilun,format)"                          do kdim = 1,ndim"
  write(ilun,format)"                             PrayM(jdim,kdim,iface,idim) = DeddM(jdim,kdim,iface,idim)*ErayM(iface,idim)"
  write(ilun,format)"                             PrayP(jdim,kdim,iface,idim) = DeddP(jdim,kdim,iface,idim)*ErayP(iface,idim)"
  write(ilun,format)"                          enddo"
  write(ilun,format)"                       enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                       ! Compute epsilon for asymptotic preserving scheme"
  write(ilun,format)"                       if (verbose)  write(*,*) '     -- compute epsilon --'"
  write(ilun,format)""
  write(ilun,format)"                       ff1 = ffM(iface,idim)"
  write(ilun,format)"                       ff2 = ffP(iface,idim)"
  write(ilun,format)""
  write(ilun,format)"                       print*,'WARNING: M1 needs UPDATE in function scattering_ana, planck_ana,rosseland_ana for Tr '"
  write(ilun,format)"                       stop"
  write(ilun,format)""
  write(ilun,format)"                       kFM= rosseland_ana(var_rad_subset(iface  ,idim,nvar_trad+1)*scale_d,var_rad_subset(iface  ,idim,1)*Tr_floor,var_rad_subset(iface  ,idim,1)*Tr_floor,igroup)/scale_kappa"
  write(ilun,format)"                       kFP= rosseland_ana(var_rad_subset(iface+1,idim,nvar_trad+1)*scale_d,var_rad_subset(iface+1,idim,1)*Tr_floor,var_rad_subset(iface  ,idim,1)*Tr_floor,igroup)/scale_kappa"
  write(ilun,format)"                       ksM=scattering_ana(var_rad_subset(iface  ,idim,nvar_trad+1)*scale_d,var_rad_subset(iface  ,idim,1)*Tr_floor,var_rad_subset(iface  ,idim,1)*Tr_floor,igroup)/scale_kappa"
  write(ilun,format)"                       ksP=scattering_ana(var_rad_subset(iface+1,idim,nvar_trad+1)*scale_d,var_rad_subset(iface+1,idim,1)*Tr_floor,var_rad_subset(iface  ,idim,1)*Tr_floor,igroup)/scale_kappa"
  write(ilun,format)""
  write(ilun,format)"                       kappa_rhoM = (kFM+ksM)"
  write(ilun,format)"                       kappa_rhoP = (kFP+ksP)"
  write(ilun,format)""
  write(ilun,format)"                       if( (kappa_rhoM .ne.zero) .and. (kappa_rhoM .ne.zero) ) then"
  write(ilun,format)"                          eps(iface,idim) = max( one/(kappa_rhoM*dx_loc) , one/(kappa_rhoP*dx_loc) ) "
  write(ilun,format)"                          eps(iface,idim) = max(eps(iface,idim),two*abs(ff1),two*abs(ff2)) "
  write(ilun,format)"                          eps(iface,idim) = min(one,eps(iface,idim))"
  write(ilun,format)"                       else"
  write(ilun,format)"                          eps(iface,idim) = one"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                       ! Compute eigenvalues at the cell interfaces"
  write(ilun,format)"                       if (verbose)  write(*,*) '     -- compute eigenvalues --'"
  write(ilun,format)""
  write(ilun,format)"                       if (cal_valp) then"
  write(ilun,format)""
  write(ilun,format)"                          select case(irad_trans_model)"
  write(ilun,format)""
  write(ilun,format)"                          case(irad_trans_model_p1) ! 'P1'"
  write(ilun,format)""
  write(ilun,format)"                             am(iface,idim)=min(-valp_min,-one/sqrt(three))"
  write(ilun,format)"                             ap(iface,idim)=max(+valp_min, one/sqrt(three))"
  write(ilun,format)""
  write(ilun,format)"                          case(irad_trans_model_m1) ! 'M1'"
  write(ilun,format)""
  write(ilun,format)"                             am(iface,idim)=min(-valp_min,interpol_valp(ffM(iface,idim),thetaM,eps(iface,idim),1), &"
  write(ilun,format)"                                                          interpol_valp(ffP(iface,idim),thetaP,eps(iface,idim),1))"
  write(ilun,format)"                             ap(iface,idim)=max(+valp_min,interpol_valp(ffM(iface,idim),thetaM,eps(iface,idim),4), &"
  write(ilun,format)"                                                          interpol_valp(ffP(iface,idim),thetaP,eps(iface,idim),4))"
  write(ilun,format)""
  write(ilun,format)"                          end select"
  write(ilun,format)""
  write(ilun,format)"                       else"
  write(ilun,format)"                          am(iface,idim) = -one"
  write(ilun,format)"                          ap(iface,idim) =  one"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                       if(ap(iface,idim).ne.am(iface,idim)) then"
  write(ilun,format)"                          lm (iface,idim) = am(iface,idim)               /(ap(iface,idim)-am(iface,idim))"
  write(ilun,format)"                          lp (iface,idim) =                ap(iface,idim)/(ap(iface,idim)-am(iface,idim))"
  write(ilun,format)"                          lmp(iface,idim) = am(iface,idim)*ap(iface,idim)/(ap(iface,idim)-am(iface,idim))"
  write(ilun,format)"                       else ! then ap=am=0."
  write(ilun,format)"                          lm (iface,idim) = -half"
  write(ilun,format)"                          lp (iface,idim) =  half"
  write(ilun,format)"                          lmp(iface,idim) =  zero"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       "
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if (verbose)  write(*,*) '     -- compute Dedd --'"
  write(ilun,format)""
  write(ilun,format)"                 Fr_temp=zero"
  write(ilun,format)"                 do jdim = 1,ndim"
  write(ilun,format)"                    Fr_temp(jdim) = var_rad_subset(2,1,index_e+jdim*ngrp)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 call cal_Dedd(var_rad_subset(2,1,index_e),Fr_temp,Dedd,Dedd_dE,Dedd_dF)"
  write(ilun,format)""
  write(ilun,format)"                 flux_F = zero"
  write(ilun,format)"                 flux_P = zero"
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"                    v1 = dFray(idim,1,idim)"
  write(ilun,format)"                    v2 = dEray(     1,idim)"
  write(ilun,format)"                    v3 = dFray(idim,2,idim)"
  write(ilun,format)"                    v4 = dEray(     2,idim)"
  write(ilun,format)""
  write(ilun,format)"                    flux_F(1,idim) = (+       lp (1,idim)            *FrayM(idim,1,idim) &"
  write(ilun,format)"                                      -       lm (1,idim)            *v1                 &"
  write(ilun,format)"                                      -       lmp(1,idim)*eps(1,idim)*ErayM(     1,idim) &"
  write(ilun,format)"                                      +       lmp(1,idim)*eps(1,idim)*v2 )*surf_loc*C_cal"
  write(ilun,format)"                    flux_F(2,idim) = (-       lm (2,idim)            *FrayP(idim,2,idim) &"
  write(ilun,format)"                                      +       lp (2,idim)            *v3                 &"
  write(ilun,format)"                                      +       lmp(2,idim)*eps(2,idim)*ErayP(     2,idim) &"
  write(ilun,format)"                                      -       lmp(2,idim)*eps(2,idim)*v4 )*surf_loc*C_cal"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 do jdim = 1,ndim"
  write(ilun,format)"        "
  write(ilun,format)"       "
  write(ilun,format)"                    do idim=1,ndim"
  write(ilun,format)""
  write(ilun,format)"                       v1 = dFray(jdim     ,1,idim)"
  write(ilun,format)"                       v2 = PrayP(jdim,idim,1,idim) - Dedd(jdim,idim)*var_rad_subset(2,idim,index_e)"
  write(ilun,format)"                       v3 = dFray(jdim     ,2,idim)"
  write(ilun,format)"                       v4 = PrayM(jdim,idim,2,idim) - Dedd(jdim,idim)*var_rad_subset(2,idim,index_e)"
  write(ilun,format)""
  write(ilun,format)"                       flux_P(jdim,1,idim) = ( ( lp (1,idim)*eps(1,idim)**2+(one-eps(1,idim)**2)*half)* PrayM(jdim,idim,1,idim) &"
  write(ilun,format)"                                              -  lmp(1,idim)*eps(1,idim)                              * FrayM(jdim     ,1,idim) &"
  write(ilun,format)"                                              +  lmp(1,idim)*eps(1,idim)                              * v1                      &"
  write(ilun,format)"                                              +(-lm (1,idim)*eps(1,idim)**2+(one-eps(1,idim)**2)*half)* v2)                     &"
  write(ilun,format)"                                              *surf_loc*C_cal"
  write(ilun,format)""
  write(ilun,format)"                       flux_P(jdim,2,idim) = ( (-lm (2,idim)*eps(2,idim)**2+(one-eps(2,idim)**2)*half)* PrayP(jdim,idim,2,idim) &"
  write(ilun,format)"                                              +  lmp(2,idim)*eps(2,idim)                              * FrayP(jdim     ,2,idim) &"
  write(ilun,format)"                                              -  lmp(2,idim)*eps(2,idim)                              * v3                      &"
  write(ilun,format)"                                              +( lp (2,idim)*eps(2,idim)**2+(one-eps(2,idim)**2)*half)* v4)                     &"
  write(ilun,format)"                                              *surf_loc*C_cal"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if (verbose)  write(*,*) '     -- compute fluxtot --'"
  write(ilun,format)""
  write(ilun,format)"                 flux_F_tot(  igroup) = zero"
  write(ilun,format)"                 flux_P_tot(:,igroup) = zero"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    do iface=1,2"
  write(ilun,format)"                       flux_F_tot(igroup) = flux_F_tot(igroup) + signe(iface)*dt_imp*flux_F(iface,idim)"
  write(ilun,format)"                       do jdim=1,ndim"
  write(ilun,format)"                          flux_P_tot(jdim,igroup) = flux_P_tot(jdim,igroup) + signe(iface)*dt_imp*flux_P(jdim,iface,idim)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 flux_F_tot(igroup) = flux_F_tot(igroup)/vol_loc"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    flux_P_tot(idim,igroup) = flux_P_tot(idim,igroup)/vol_loc"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 ! Store flux_F and flux_P in var_rad_subset"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)""
  write(ilun,format)"                    var_rad_subset(1,idim,nrad+3) = zero"
  write(ilun,format)"                    var_rad_subset(3,idim,nrad+3) = zero"
  write(ilun,format)""
  write(ilun,format)"                    var_rad_subset(1,idim,nrad+3+igroup) = flux_F(1,idim) * dt_imp/vol_loc"
  write(ilun,format)"                    var_rad_subset(3,idim,nrad+3+igroup) = flux_F(2,idim) * dt_imp/vol_loc"
  write(ilun,format)""
  write(ilun,format)"                    do jdim=1,ndim"
  write(ilun,format)"                       var_rad_subset(1,idim,nrad+3+igroup+jdim*ngrp) = flux_P(jdim,1,idim) * dt_imp/vol_loc"
  write(ilun,format)"                       var_rad_subset(3,idim,nrad+3+igroup+jdim*ngrp) = flux_P(jdim,2,idim) * dt_imp/vol_loc"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 ! Compute Eddington tensors"
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)""
  write(ilun,format)"                    Fr_temp=zero"
  write(ilun,format)"                    do jdim = 1,ndim"
  write(ilun,format)"                       Fr_temp(jdim) = var_rad_subset(1,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                    call cal_Dedd(var_rad_subset(1,idim,index_e),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                    Dedd_ndim   (:,:  ,1,idim)=Dedd_temp"
  write(ilun,format)"                    Dedd_dE_ndim(:,:  ,1,idim)=Dedd_dE_temp"
  write(ilun,format)"                    Dedd_dF_ndim(:,:,:,1,idim)=Dedd_dF_temp"
  write(ilun,format)"                    "
  write(ilun,format)"                    Fr_temp=zero"
  write(ilun,format)"                    do jdim = 1,ndim"
  write(ilun,format)"                       Fr_temp(jdim) = var_rad_subset(3,idim,index_e+jdim*ngrp)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                    call cal_Dedd(var_rad_subset(3,idim,index_e),Fr_temp,Dedd_temp,Dedd_dE_temp,Dedd_dF_temp)"
  write(ilun,format)"                    Dedd_ndim   (:,:  ,2,idim)=Dedd_temp"
  write(ilun,format)"                    Dedd_dE_ndim(:,:  ,2,idim)=Dedd_dE_temp"
  write(ilun,format)"                    Dedd_dF_ndim(:,:,:,2,idim)=Dedd_dF_temp"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 ! Compute matrix index for radiative energy"
  write(ilun,format)"                 ! The matrix is stored in the following way: (for 2 groups)"
  write(ilun,format)"                 ! [T,E(1),E(2),Fx(1),Fx(2),Fy(1),Fy(2),Fz(1),Fz(2)]"
  write(ilun,format)""
  write(ilun,format)"                 if (verbose)  write(*,*) '     -- compute matrix --'"
  write(ilun,format)""
  write(ilun,format)"                 ! Fill matrix and vector"
  write(ilun,format)"                 !******************************************************************"
  write(ilun,format)""
  write(ilun,format)"                 ! Er equation without the source term"
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)"                    mat_residual_glob(ind_cell(i),index_e,index_e          ) = mat_residual_glob(ind_cell(i),index_e,index_e) - dt_imp/vol_loc*C_cal* &"
  write(ilun,format)"                                (lmp(1,idim)*eps(1,idim)*surf_loc+lmp(2,idim)*eps(2,idim)*surf_loc)"
  write(ilun,format)"                    mat_residual_glob(ind_cell(i),index_e,index_e+idim*ngrp) =                                                 dt_imp/vol_loc*C_cal * &"
  write(ilun,format)"                                (lm (1,idim)            *surf_loc+lp (2,idim)            *surf_loc)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 residual_glob(ind_cell(i),index_e) =  Erold(igroup) !- flux_F_tot(igroup)"
  write(ilun,format)"    "
  write(ilun,format)"                 ! Tgaz equation (using the coefficients from the Er equation without the source term)"
  write(ilun,format)"                 mat_residual_glob(ind_cell(i),1,index_e) = mat_residual_glob(ind_cell(i),index_e,index_e) * conv"
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)"                    mat_residual_glob(ind_cell(i),1,index_e+idim*ngrp) = mat_residual_glob(ind_cell(i),index_e,index_e+idim*ngrp)* conv"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 residual_glob(ind_cell(i),1) = residual_glob(ind_cell(i),1) + residual_glob(ind_cell(i),index_e)*conv"
  write(ilun,format)""
  write(ilun,format)"                 ! Finally include the energy source term: c (kp aT^4-kE E)"
  write(ilun,format)""
  write(ilun,format)"                 ! B(      Tn+1              )=B(Tn)+B'(Tn)*(      Tn+1-      Tn)=      B'(Tn)*Tn+1 + B(Tn)-      B'(Tn)*Tn"
  write(ilun,format)"                 ! B(alpha*Tn+1+(1-alpha)*Tn))=B(Tn)+B'(Tn)*(alpha*Tn+1-alpha*Tn)=alpha*B'(Tn)*Tn+1 + B(Tn)-alpha*B'(Tn)*Tn"
  write(ilun,format)""
  write(ilun,format)"                 kp=    planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"                 kE=    planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"                 kF= rosseland_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"                 ks=scattering_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)""
  write(ilun,format)"                 mat_residual_glob(ind_cell(i),index_e,1      ) =                                                - dt_imp*kp*C_cal &"
  write(ilun,format)"                                                                  *deriv(igroup)/scale_E0 *Tr_floor"
  write(ilun,format)"                 mat_residual_glob(ind_cell(i),index_e,index_e) = mat_residual_glob(ind_cell(i),index_e,index_e) + dt_imp*kE*C_cal"
  write(ilun,format)""
  write(ilun,format)"                 residual_glob    (ind_cell(i),index_e        ) = residual_glob    (ind_cell(i),index_e        ) + dt_imp*kp*C_cal &"
  write(ilun,format)"                                                                  *(radiation_source(Told,igroup)-deriv(igroup)*Told)/scale_E0"
  write(ilun,format)"                                      !- dt_imp*kE*C_cal*Erold(igroup)"
  write(ilun,format)"                                     "
  write(ilun,format)"                 ! Fr equation using only dtFr + c2(Div . Pr) = 0 terms"
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"                    do jdim = 1,ndim"
  write(ilun,format)"                       mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e          ) = mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e) &"
  write(ilun,format)"                            + C_cal*dt_imp/vol_loc*( ( lp(2,jdim)*eps(2,jdim)**2+(one-eps(2,jdim)**2)*half)*surf_loc &"
  write(ilun,format)"                                                   - (-lm(1,jdim)*eps(1,jdim)**2+(one-eps(1,jdim)**2)*half)*surf_loc ) * Dedd(idim,jdim)"
  write(ilun,format)"                       mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+idim*ngrp) = mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+idim*ngrp) &"
  write(ilun,format)"                            - C_cal*dt_imp/vol_loc*(  lmp(1,jdim)*eps(1,jdim)*surf_loc + lmp(2,jdim)*eps(2,jdim)*surf_loc )"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+idim*ngrp) = mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+idim*ngrp) + C_cal *dt_imp*(kF+ks)"
  write(ilun,format)""
  write(ilun,format)"                    residual_glob(ind_cell(i),index_e+idim*ngrp) = Frold(idim,igroup) !- flux_P_tot(idim,igroup)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if (verbose)  write(*,*) '     -- compute deriv matrix --'"
  write(ilun,format)""
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)"                    do jdim = 1,ndim"
  write(ilun,format)"                       ! The Dedd derivatives"
  write(ilun,format)"                       mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e     ) = mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e     ) &"
  write(ilun,format)"                            + C_cal*dt_imp/vol_loc*( ( lp(2,jdim)*eps(2,jdim)**2+(one-eps(2,jdim)**2)*half)*surf_loc &"
  write(ilun,format)"                                                   - (-lm(1,jdim)*eps(1,jdim)**2+(one-eps(1,jdim)**2)*half)*surf_loc ) * Dedd_dE(idim,jdim     )  ! d/dEray"
  write(ilun,format)"                       do kdim=1,ndim"
  write(ilun,format)"                          mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+kdim*ngrp) = mat_residual_glob(ind_cell(i),index_e+idim*ngrp,index_e+kdim*ngrp) &"
  write(ilun,format)"                               + C_cal*dt_imp/vol_loc*( ( lp(2,jdim)*eps(2,jdim)**2+(one-eps(2,jdim)**2)*half)*surf_loc &"
  write(ilun,format)"                                                      - (-lm(1,jdim)*eps(1,jdim)**2+(one-eps(1,jdim)**2)*half)*surf_loc ) * Dedd_dF(idim,jdim,kdim)  ! d/dFray"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 if (verbose)  write(*,*) '     -- compute left and right coefficients --'"
  write(ilun,format)""
  write(ilun,format)"                 ! non-diagonal terms"
  write(ilun,format)""
  write(ilun,format)"                 do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"                    ! Left coefficient ---"
  write(ilun,format)""
  write(ilun,format)"                    ! Radiative energy equation"
  write(ilun,format)"                    coeff_glob_left(ind_cell(i),index_e,index_e          ,idim) =  dt_imp/vol_loc*C_cal*lmp(1,idim)*eps(1,idim)*surf_loc"
  write(ilun,format)"                    coeff_glob_left(ind_cell(i),index_e,index_e+idim*ngrp,idim) = -dt_imp/vol_loc*C_cal* lp(1,idim)            *surf_loc"
  write(ilun,format)""
  write(ilun,format)"                    ! Temperature equation"
  write(ilun,format)"                    coeff_glob_left(ind_cell(i),1,index_e          ,idim) = coeff_glob_left(ind_cell(i),index_e,index_e          ,idim)*conv"
  write(ilun,format)"                    coeff_glob_left(ind_cell(i),1,index_e+idim*ngrp,idim) = coeff_glob_left(ind_cell(i),index_e,index_e+idim*ngrp,idim)*conv"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! Radiative flux equation"
  write(ilun,format)"                    do jdim=1,ndim"
  write(ilun,format)"                       coeff_glob_left(ind_cell(i),index_e+jdim*ngrp,index_e,idim) = -dt_imp/vol_loc*   C_cal*( lp(1,idim)*eps(1,idim)**2+(one-eps(1,idim)**2)*half ) * &"
  write(ilun,format)"                            (DeddM(jdim,idim,1,idim)+Dedd_dE_ndim(jdim,idim,1,idim))*surf_loc"
  write(ilun,format)"                       do kdim=1,ndim"
  write(ilun,format)"                          coeff_glob_left(ind_cell(i),index_e+jdim*ngrp,index_e+kdim*ngrp,idim) = -dt_imp/vol_loc* C_cal*( lp(1,idim)*eps(1,idim)**2+(one-eps(1,idim)**2)*half ) * &"
  write(ilun,format)"                               Dedd_dF_ndim(jdim,idim,kdim,1,idim)*surf_loc"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                       coeff_glob_left(ind_cell(i),index_e+jdim*ngrp,index_e+jdim*ngrp,idim) = coeff_glob_left(ind_cell(i),index_e+jdim*ngrp,index_e+jdim*ngrp,idim) + dt_imp/vol_loc*C_cal*lmp(1,idim)*eps(1,idim)*surf_loc"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                    ! Right coefficient ---"
  write(ilun,format)""
  write(ilun,format)"                    ! Radiative energy equation"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),index_e,index_e          ,idim) =  dt_imp/vol_loc*C_cal*lmp(2,idim)*eps(2,idim)*surf_loc"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),index_e,index_e+idim*ngrp,idim) = -dt_imp/vol_loc*C_cal* lm(2,idim)            *surf_loc"
  write(ilun,format)""
  write(ilun,format)"                    ! Temperature equation"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),1,index_e          ,idim) = coeff_glob_right(ind_cell(i),index_e,index_e          ,idim)*conv"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),1,index_e+idim*ngrp,idim) = coeff_glob_right(ind_cell(i),index_e,index_e+idim*ngrp,idim)*conv"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! Radiative flux equation"
  write(ilun,format)"                    do jdim=1,ndim"
  write(ilun,format)"                       coeff_glob_right(ind_cell(i),index_e+jdim*ngrp,index_e,idim) = dt_imp/vol_loc*   C_cal*(-lm(2,idim)*eps(2,idim)**2+(one-eps(2,idim)**2)*half ) * &"
  write(ilun,format)"                            (DeddP(jdim,idim,2,idim)+Dedd_dE_ndim(jdim,idim,2,idim))*surf_loc"
  write(ilun,format)"                       do kdim=1,ndim"
  write(ilun,format)"                          coeff_glob_right(ind_cell(i),index_e+jdim*ngrp,index_e+kdim*ngrp,idim) = dt_imp/vol_loc* C_cal*(-lm(2,idim)*eps(2,idim)**2+(one-eps(2,idim)**2)*half ) * &"
  write(ilun,format)"                               Dedd_dF_ndim(jdim,idim,kdim,2,idim)*surf_loc"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                       coeff_glob_right(ind_cell(i),index_e+jdim*ngrp,index_e+jdim*ngrp,idim) = coeff_glob_right(ind_cell(i),index_e+jdim*ngrp,index_e+jdim*ngrp,idim) + dt_imp/vol_loc*C_cal*lmp(2,idim)*eps(2,idim)*surf_loc"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                 enddo ! end idim loop"
  write(ilun,format)"                 "
  write(ilun,format)"              enddo ! end multigroup loop"
  write(ilun,format)"              "
  write(ilun,format)"              if(verbose) write(*,*) 'End of multigroup loop'"
  write(ilun,format)""
  write(ilun,format)"              !=============================================================================="
  write(ilun,format)""
  write(ilun,format)"              do irad=1,nvar_bicg"
  write(ilun,format)"                 do jrad=1,nvar_bicg"
  write(ilun,format)"                    if(block_diagonal_precond_bicg.or.irad==jrad) then"
  write(ilun,format)"                       precond_bicg(ind_cell(i),irad,jrad) = mat_residual_glob(ind_cell(i),irad,jrad)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    coeff_glob_left (ind_cell(i),irad,jrad,:) = -coeff_glob_left (ind_cell(i),irad,jrad,:)"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),irad,jrad,:) = -coeff_glob_right(ind_cell(i),irad,jrad,:)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        ! Compute preconditionning matrix                                                               "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"!#if NRAD>1 !warning NRAD changed in NGRP in Makefile"
  write(ilun,format)"              if(block_diagonal_precond_bicg) then"
  write(ilun,format)"                 inv = precond_bicg(ind_cell(i),1:nvar_bicg,1:nvar_bicg)"
  write(ilun,format)"                 lda = nvar_bicg ; lwork = nwork*nvar_bicg"
  write(ilun,format)"                 "
  write(ilun,format)"                 ! Invert the (nvar_bicg x nvar_bicg) matrix using LAPACK routines                      "
  write(ilun,format)"                 !                                                                                      "
  write(ilun,format)"                 ! DGETRF computes an LU factorization of a general M-by-N matrix A                     "
  write(ilun,format)"                 ! using partial pivoting with row interchanges                                         "
  write(ilun,format)"                 call dgetrf(nvar_bicg,nvar_bicg,inv,lda,ipiv,info2)"
  write(ilun,format)"                 "
  write(ilun,format)"                 ! DGETRI computes the inverse of a matrix using the LU factorization                   "
  write(ilun,format)"                 ! computed by DGETRF                                                                   "
  write(ilun,format)"                 call dgetri(nvar_bicg,inv,lda,ipiv,work,lwork,info2)"
  write(ilun,format)"                 "
  write(ilun,format)"                 precond_bicg(ind_cell(i),1:nvar_bicg,1:nvar_bicg)=inv"
  write(ilun,format)"              else"
  write(ilun,format)"!#endif"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(ind_cell(i),irad,4) = one/precond_bicg(ind_cell(i),irad,irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"!#if NRAD>1 !warning NRAD changed in NGRP in Makefile"
  write(ilun,format)"              endif"
  write(ilun,format)"!#endif"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do !ngrid"
  write(ilun,format)"        "
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do ! ncache"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_matrix_and_vector_coeff_m1"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine cmp_matrix_vector_product(ilevel,compute)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes "
  write(ilun,format)"  ! compute = 1 : residual           	  return B - Ax"
  write(ilun,format)"  ! compute = 2 : Product                 return  A.p"
  write(ilun,format)"  ! compute = 3 : Preconditionner         return diag(A) or block_diag(A)"
  write(ilun,format)"  ! compute = 4 : Compute flux in rad_flux"
  write(ilun,format)"  !"
  write(ilun,format)"  ! For BICG"
  write(ilun,format)"  ! compute = 6 : product                 return  A.p"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons,only:active,ncoarse,nbor,son,myid"
  write(ilun,format)"  use amr_parameters, only : ndim"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use hydro_parameters,only:nvar_bicg"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::compute,ilevel"
  write(ilun,format)"  integer :: irad,jrad"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector  ,1:  nvar_bicg),save:: residu"
  write(ilun,format)"  real(dp),dimension(1:nvector  ,1:  nvar_bicg),save:: phi_g,phi_c,phi_d,val_g,val_d"
  write(ilun,format)""
  write(ilun,format)"  integer :: i,idim,ind,igrid,ngrid,ncache,iskip,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)""
  write(ilun,format)"  integer :: ind_res"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=half**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = zero"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"  "
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1     !direction of left nbor grid"
  write(ilun,format)"              supD = 0                !direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1) !position of nbor in its own grid"
  write(ilun,format)"           else"
  write(ilun,format)"              supG = 0                !direction of left nbor grid"
  write(ilun,format)"              supD = (idim-1)*2+2     !direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1) !position of nbor in its own grid"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax !nbor index offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"              ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then ! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else                             ! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else                                ! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then ! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else                              ! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else                                 ! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        end do !ndim"
  write(ilun,format)"        "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"              if(.not.store_matrix)then"
  write(ilun,format)"                 call compute_residual_in_cell(ind_cell(i),vol_loc,residual_glob(1,:),mat_residual_glob(1,:,:))"
  write(ilun,format)"                 ind_res = 1"
  write(ilun,format)"              else"
  write(ilun,format)"                 ind_res = ind_cell(i)"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              select case (compute)"
  write(ilun,format)""
  write(ilun,format)"              case (1) ! residu = b - Ix"
  write(ilun,format)"                 "
  write(ilun,format)"                 do irad = 1,nvar_bicg"
  write(ilun,format)"                    residu(i,irad) = residual_glob(ind_res,irad)"
  write(ilun,format)"                    do jrad = 1,nvar_bicg"
  write(ilun,format)"                       residu(i,irad) = residu(i,irad) - mat_residual_glob(ind_res,irad,jrad)*uold(ind_cell(i),ind_bicg(jrad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"              case (2) ! residu = Ix"
  write(ilun,format)""
  write(ilun,format)"                 residu(i,1:nvar_bicg)=zero"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    do jrad=1,nvar_bicg"
  write(ilun,format)"                       residu(i,irad)=residu(i,irad)+mat_residual_glob(ind_res,irad,jrad)*var_bicg(ind_cell(i),jrad,i_y)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"              case (4) ! reinitialize rad_flux for this level"
  write(ilun,format)"                 rad_flux(ind_cell(i),:) = zero"
  write(ilun,format)""
  write(ilun,format)"!neil"
  write(ilun,format)"!!                  do idim=1,ndim"
  write(ilun,format)"!!                     do irad = 1,nvar_bicg"
  write(ilun,format)"!!                        var_bicg(ind_cell(i),irad,11+(idim-1)*2) = var_rad_subset(1,idim,nrad+2+irad)"
  write(ilun,format)"!!                        var_bicg(ind_cell(i),irad,12+(idim-1)*2) = var_rad_subset(3,idim,nrad+2+irad)"
  write(ilun,format)"!!                     enddo"
  write(ilun,format)"!!                  enddo"
  write(ilun,format)"!neil"
  write(ilun,format)""
  write(ilun,format)"              case (6) ! residu = Ix"
  write(ilun,format)""
  write(ilun,format)"                 residu(i,1:nvar_bicg)=zero"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    do jrad=1,nvar_bicg"
  write(ilun,format)"                       residu(i,irad)=residu(i,irad)+mat_residual_glob(ind_res,irad,jrad)*var_bicg(ind_cell(i),jrad,6)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"              end select"
  write(ilun,format)""
  write(ilun,format)"           endif"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           select case (compute)! Getting val_g and val_d"
  write(ilun,format)"           case(1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       val_g(i,irad) = uold(cell_left (i,idim),ind_bicg(irad))"
  write(ilun,format)"                       val_d(i,irad) = uold(cell_right(i,idim),ind_bicg(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           case(2)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       val_g(i,irad) = var_bicg(cell_left (i,idim),irad,i_y)"
  write(ilun,format)"                       val_d(i,irad) = var_bicg(cell_right(i,idim),irad,i_y)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           case(4)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       val_g(i,irad) = unew(cell_left (i,idim),ind_bicg(irad))"
  write(ilun,format)"                       val_d(i,irad) = unew(cell_right(i,idim),ind_bicg(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           case(6)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       val_g(i,irad) = var_bicg(cell_left (i,idim),irad,6)"
  write(ilun,format)"                       val_d(i,irad) = var_bicg(cell_right(i,idim),irad,6)"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           end select"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim-1)) ! Gather main characteristics of left neighbour"
  write(ilun,format)""
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       if (compute==2  .or. compute==6) then"
  write(ilun,format)"                          val_g(i,irad) = zero"
  write(ilun,format)"                       else"
  write(ilun,format)"                          val_g(i,irad) = uold(cell_left(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"                       endif"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       phi_g (i,irad) = uold(cell_left(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 case (0)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       phi_g (i,irad)       = uold(cell_left(i,idim),ind_bicg(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 case (-1)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       if (compute==2  .or. compute==6) then"
  write(ilun,format)"                          val_g(i,irad) = zero"
  write(ilun,format)"                       else"
  write(ilun,format)"                          val_g(i,irad) = uold(cell_left(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"                       endif"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       phi_g (i,irad) = uold(cell_left(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end select"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim)) ! Gather main characteristics of right neighbour"
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       if (compute==2  .or. compute==6) then"
  write(ilun,format)"                          val_d(i,irad) = zero"
  write(ilun,format)"                       else"
  write(ilun,format)"                          val_d(i,irad) = uold(cell_right(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"                       endif"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       phi_d (i,irad) = uold(cell_right(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 case (0)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       phi_d (i,irad)  = uold(cell_right(i,idim),ind_bicg(irad))"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 case (-1)"
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       if (compute==2  .or. compute==6) then"
  write(ilun,format)"                          val_d(i,irad) = zero"
  write(ilun,format)"                       else"
  write(ilun,format)"                          val_d(i,irad) = uold(cell_right(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"                       endif"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       phi_d (i,irad) = uold(cell_right(i,idim),ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           if (compute ==4)then ! Computing and saving flux to the coarser ilevel"
  write(ilun,format)""
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)""
  write(ilun,format)"                    if(.not.store_matrix)then"
  write(ilun,format)"                       call compute_coeff_left_right_in_cell(ind_cell(i),idim,cell_left(i,idim),cell_right(i,idim),nbor_ilevel(i,1:2*ndim),dx_loc,coeff_glob_left(1,:,:,idim),coeff_glob_right(1,:,:,idim))"
  write(ilun,format)"                       ind_res=1"
  write(ilun,format)"                    else"
  write(ilun,format)"                       ind_res=ind_cell(i)"
  write(ilun,format)"                    endif"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim-1) == -1)then"
  write(ilun,format)"                       do irad=1,nvar_bicg"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                          phi_c(i,irad) = uold(ind_cell(i),firstindex_er+irad)"
  write(ilun,format)"                          rad_flux(cell_left(i,idim),irad)  = rad_flux(cell_left(i,idim),irad)  + &"
  write(ilun,format)"                               & coeff_glob_left(ind_res,irad,irad,idim)*( alpha_imp * (unew(ind_cell(i),ind_bicg(irad)) - val_g(i,irad)) + (one-alpha_imp)*(phi_c(i,irad) - phi_g(i,irad))) "
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"                          !if M1, C_g(i,irad) is just 0.5 , 1.0 , 1.5"
  write(ilun,format)"!                          rad_flux(cell_left (i,idim),irad) =  rad_flux(cell_left(i,idim),irad)  + C_g(i,irad)*var_bicg(ind_cell(i),irad,10+(idim-1)*2)"
  write(ilun,format)"                          rad_flux(cell_left (i,idim),irad) = 0. ! rad_flux(cell_left(i,idim),irad)  + C_g(i,irad)*(- a1d_glob(ind_cell(i),irad,          jrad)*val_g(i,jrad)+precond_bicg(ind_cell(i),irad,jrad)*unew(ind_cell(i),ind_bicg(irad)))"
  write(ilun,format)"#endif"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim)   == -1 )then"
  write(ilun,format)"                       do irad=1,nvar_bicg"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                          phi_c(i,irad) = uold(ind_cell(i),firstindex_er+irad)"
  write(ilun,format)"                          rad_flux(cell_right(i,idim),irad) = rad_flux(cell_right(i,idim),irad) + &"
  write(ilun,format)"                               & coeff_glob_right(ind_res,irad,irad,idim)*( alpha_imp * (unew(ind_cell(i),ind_bicg(irad)) - val_d(i,irad)) + (one-alpha_imp)*(phi_c(i,irad) - phi_d(i,irad)))"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"                          !if M1, C_d(i,irad) is just 0.5 , 1.0 , 1.5"
  write(ilun,format)"!                          rad_flux(cell_right (i,idim),irad) =  rad_flux(cell_right(i,idim),irad)  + C_d(i,irad)*var_bicg(ind_cell(i),irad,11+(idim-1)*2)"
  write(ilun,format)"                          rad_flux(cell_left (i,idim),irad) = 0.! rad_flux(cell_left(i,idim),irad)  + C_d(i,irad)*(- a1d_glob(ind_cell(i),irad,nvar_bicg+jrad)*val_d(i,jrad)+precond_bicg(ind_cell(i),irad,jrad)*unew(ind_cell(i),ind_bicg(irad)))"
  write(ilun,format)"#endif"
  write(ilun,format)"                       enddo"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(.not.store_matrix)then"
  write(ilun,format)"                    call compute_coeff_left_right_in_cell(ind_cell(i),idim,cell_left(i,idim),cell_right(i,idim),nbor_ilevel(i,1:2*ndim),dx_loc,coeff_glob_left(1,:,:,idim),coeff_glob_right(1,:,:,idim))"
  write(ilun,format)"                    ind_res=1"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ind_res=ind_cell(i)"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 "
  write(ilun,format)"                 select case (compute)"
  write(ilun,format)"                    "
  write(ilun,format)"                 case (1) ! compute b-Ax from b-Ix by adding intern flux"
  write(ilun,format)""
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       do jrad=1,nvar_bicg"
  write(ilun,format)"                          residu(i,irad) = residu(i,irad) + coeff_glob_left(ind_res,irad,jrad,idim)*val_g(i,jrad) + coeff_glob_right(ind_res,irad,jrad,idim)*val_d(i,jrad)"
  write(ilun,format)"                       enddo"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       residu(i,irad) = residu(i,irad) - (coeff_glob_left(ind_res,irad,irad,idim)+coeff_glob_right(ind_res,irad,irad,idim))* uold(ind_cell(i),ind_bicg(irad))"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                 case (2) ! compute Ap from Ip by adding intern flux"
  write(ilun,format)""
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       do jrad=1,nvar_bicg"
  write(ilun,format)"                          residu(i,irad) = residu(i,irad) - (coeff_glob_left(ind_res,irad,jrad,idim)*val_g(i,jrad) + coeff_glob_right(ind_res,irad,jrad,idim)*val_d(i,jrad))*alpha_imp"
  write(ilun,format)"                       enddo"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       residu(i,irad) = residu(i,irad) + (coeff_glob_left(ind_res,irad,irad,idim)+coeff_glob_right(ind_res,irad,irad,idim))* var_bicg(ind_cell(i),irad,i_y)*alpha_imp"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                 case (6) ! compute Ap* from Ip by adding intern flux"
  write(ilun,format)""
  write(ilun,format)"                    do irad=1,nvar_bicg"
  write(ilun,format)"                       do jrad=1,nvar_bicg"
  write(ilun,format)"                          residu(i,irad) = residu(i,irad) - (coeff_glob_left(ind_res,irad,jrad,idim)*val_g(i,jrad) + coeff_glob_right(ind_res,irad,jrad,idim)*val_d(i,jrad))*alpha_imp"
  write(ilun,format)"                       enddo"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"                       residu(i,irad) = residu(i,irad) + (coeff_glob_left(ind_res,irad,irad,idim)+coeff_glob_right(ind_res,irad,irad,idim))* var_bicg(ind_cell(i),irad,6)*alpha_imp"
  write(ilun,format)"#endif"
  write(ilun,format)"                    enddo"
  write(ilun,format)""
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        select case (compute)"
  write(ilun,format)"           ! get the result out"
  write(ilun,format)""
  write(ilun,format)"        case (1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(ind_cell(i),irad,1) = residu(i,irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (2)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(ind_cell(i),irad,3) = residu(i,irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (6)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 do irad=1,nvar_bicg"
  write(ilun,format)"                    var_bicg(ind_cell(i),irad,8) = residu(i,irad)"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        end select"
  write(ilun,format)""
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do ! ncache"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_matrix_vector_product"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)""
  write(ilun,format)"function lambda_fld(R)"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::R,lambda_fld"
  write(ilun,format)""
  write(ilun,format)"  lambda_fld = one/three"
  write(ilun,format)"  if(i_fld_limiter==i_fld_limiter_levermore) lambda_fld =(2.0d0+r)/(6.0d0+2.0d0*R+R**2)! (one/tanh(R)-one/R) / R"
  write(ilun,format)"  if(i_fld_limiter==i_fld_limiter_minerbo) then "
  write(ilun,format)"     if(R .le. three/two) then"
  write(ilun,format)"        lambda_fld = two/(three+sqrt(nine+12.0_dp*R*R))"
  write(ilun,format)"     else"
  write(ilun,format)"        lambda_fld = one/(one + R + sqrt(one+two*R))"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"  return "
  write(ilun,format)"end function lambda_fld"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine cmp_energy(Etype)"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in) :: Etype ! Etype=1 : beginning ; Etype=2 : end"
  write(ilun,format)"  integer ::i,idim,this,ivar,igroup,irad"
  write(ilun,format)"  real(dp)::usquare,Cv,eps,ekin,emag,rho,erad_loc"
  write(ilun,format)"  real(dp)::tp_loc,cmp_temp"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     rho   = uold(this,1)"
  write(ilun,format)""
  write(ilun,format)"     ! Compute total kinetic energy"
  write(ilun,format)"     usquare=zero"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        usquare=usquare+(uold(this,idim+1)/uold(this,1))**2"
  write(ilun,format)"     end do"
  write(ilun,format)"     ekin  = rho*usquare*half"
  write(ilun,format)""
  write(ilun,format)"     ! Compute total magnetic energy"
  write(ilun,format)"     emag = zero"
  write(ilun,format)"     do ivar=1,3"
  write(ilun,format)"        emag = emag + ((uold(this,5+ivar)+uold(this,nvar+ivar))**2)/eight"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     if(Etype==1)then"
  write(ilun,format)"        ! Compute total non-thermal+radiative energy"
  write(ilun,format)"        erad_loc = zero"
  write(ilun,format)"        do igroup=1,nener"
  write(ilun,format)"           erad_loc = erad_loc + uold(this,8+igroup)"
  write(ilun,format)"        enddo"
  write(ilun,format)"        "
  write(ilun,format)"        eps = uold(this,5)-ekin-emag-erad_loc"
  write(ilun,format)"        if(energy_fix)eps = uold(this,nvar) ! use energy fix for collapse"
  write(ilun,format)"        "
  write(ilun,format)"        Tp_loc = cmp_temp(this)"
  write(ilun,format)"        Cv = eps/Tp_loc"
  write(ilun,format)""
  write(ilun,format)"        unew(this,nvar+1) = Cv"
  write(ilun,format)"        uold(this,nvar  ) = Tp_loc"
  write(ilun,format)""
  write(ilun,format)"        do irad=1,nvar_trad"
  write(ilun,format)"           uold(this,ind_trad(irad))=uold(this,ind_trad(irad))/norm_trad(irad)"
  write(ilun,format)"           if(is_radiative_energy(irad)) uold(this,ind_trad(irad)) = max(uold(this,ind_trad(irad)),eray_min/scale_E0)"
  write(ilun,format)"           unew(this,ind_trad(irad))=uold(this,ind_trad(irad))"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"     elseif(Etype==2)then"
  write(ilun,format)""
  write(ilun,format)"        unew(this,nvar)=unew(this,nvar)*unew(this,nvar+1)"
  write(ilun,format)""
  write(ilun,format)"        do irad=1,nvar_trad"
  write(ilun,format)"           if(is_radiative_energy(irad)) unew(this,ind_trad(irad)) = max(unew(this,ind_trad(irad)),eray_min/scale_E0)"
  write(ilun,format)"           unew(this,ind_trad(irad))=unew(this,ind_trad(irad))*norm_trad(irad)"
  write(ilun,format)" !          unew(this,ind_trad(irad))=uold(this,ind_trad(irad))*norm_trad(irad)"
  write(ilun,format)"           uold(this,ind_trad(irad))=unew(this,ind_trad(irad))"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"        eps = unew(this,nvar)"
  write(ilun,format)"        uold(this,5) = eps + ekin + emag"
  write(ilun,format)"        do igroup=1,nener"
  write(ilun,format)"           uold(this,5) = uold(this,5) + uold(this,8+igroup)"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_energy"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"function cmp_temp(this)"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in) ::this"
  write(ilun,format)"  integer ::idim,ivar,igrp,ht"
  write(ilun,format)"  real(dp)::usquare,eps,ekin,emag,rho,erad_loc"
  write(ilun,format)"  real(dp)::cmp_temp"
  write(ilun,format)""
  write(ilun,format)"  rho   = uold(this,1)"
  write(ilun,format)"!!   Cv    = rho*kB/(mu_gas*mH*(gamma-one))/scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total kinetic energy"
  write(ilun,format)"  usquare=zero"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     usquare=usquare+(uold(this,idim+1)/uold(this,1))**2"
  write(ilun,format)"  end do"
  write(ilun,format)"  ekin  = rho*usquare*half"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total magnetic energy"
  write(ilun,format)"  emag = zero"
  write(ilun,format)"  do ivar=1,3"
  write(ilun,format)"     emag = emag + ((uold(this,5+ivar)+uold(this,nvar+ivar))**2)/eight"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total non-thermal+radiative energy"
  write(ilun,format)"  erad_loc  = zero"
  write(ilun,format)"  do igrp=1,nener"
  write(ilun,format)"     erad_loc = erad_loc + uold(this,8+igrp) "
  write(ilun,format)"  enddo"
  write(ilun,format)"  eps = uold(this,5)-ekin-emag-erad_loc"
  write(ilun,format)"  if(energy_fix)eps = uold(this,nvar) ! use energy fix for collapse"
  write(ilun,format)""
  write(ilun,format)"  call temperature_eos(rho,eps,cmp_temp,ht)"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end function cmp_temp"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"function nu_surf(Er1,Er2,ind1,ind2,dx)"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ind1,ind2"
  write(ilun,format)"  real(dp),INTENT(IN)::Er2,Er1,dx"
  write(ilun,format)"  real(dp)::nu_surf,nu_harmo,nu_ari"
  write(ilun,format)""
  write(ilun,format)"  nu_ari=(Er2+Er1)*half"
  write(ilun,format)""
  write(ilun,format)"  nu_harmo=max(Er2*Er1/nu_ari,four/(three*dx))"
  write(ilun,format)"  nu_surf = nu_ari"
  write(ilun,format)""
  write(ilun,format)"  nu_surf=min(nu_harmo,nu_ari)"
  write(ilun,format)""
  write(ilun,format)"  return "
  write(ilun,format)"end function nu_surf"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine compute_residual_in_cell(i,vol_loc,residual,mat_residual)"
  write(ilun,format)"  use hydro_parameters,only:nvar"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use rt_cooling_module"
  write(ilun,format)"  use cloud_module, only : rt_protostar_m1"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use const"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in)::i"
  write(ilun,format)"  real(dp),intent(in)::vol_loc"
  write(ilun,format)"  real(dp),dimension(nvar_bicg,nvar_bicg),intent(out)::mat_residual"
  write(ilun,format)"  real(dp),dimension(nvar_bicg          ),intent(out)::residual"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::rho,Told_norm,Told,cv,lhs,rhs,planck_ana,radiation_source,deriv_radiation_source,cal_Teg,Trold"
  write(ilun,format)"  integer::igrp,igroup,im1"
  write(ilun,format)"  real(dp),dimension(ngrp)::wdtB,wdtE,source,deriv"
  write(ilun,format)"  real(dp)::ambi_heating,ohm_heating,nimhd_heating,protostellar_heating"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  real(dp)::bcell2,bx,by,bz,jsquare,jx,jy,jz,etaohmdiss,betaad,ionisrate"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  real(dp)::scale_Np,scale_Fp"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  call rt_units(scale_Np,scale_Fp)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  rho       = uold(i,1          )"
  write(ilun,format)"  Told_norm = uold(i,ind_trad(1))"
  write(ilun,format)"  Told      = Told_norm * Tr_floor"
  write(ilun,format)"  Cv        = unew(i,nvar+1)"
  write(ilun,format)""
  write(ilun,format)"  ambi_heating=zero"
  write(ilun,format)"  ohm_heating=zero"
  write(ilun,format)"  nimhd_heating=zero"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  if(radiative_nimhdheating)then"
  write(ilun,format)"     bx=0.5d0*(uold(i,6)+uold(i,nvar+1))"
  write(ilun,format)"     by=0.5d0*(uold(i,7)+uold(i,nvar+2))"
  write(ilun,format)"     bz=0.5d0*(uold(i,8)+uold(i,nvar+3))"
  write(ilun,format)"     bcell2=(bx**2+by**2+bz**2)"
  write(ilun,format)"     jx=uold(i,nvar-3)"
  write(ilun,format)"     jy=uold(i,nvar-2)"
  write(ilun,format)"     jz=uold(i,nvar-1)"
  write(ilun,format)"     jsquare=(jx**2+jy**2+jz**2)"
  write(ilun,format)"     ionisrate=default_ionisrate"
  write(ilun,format)""
  write(ilun,format)"     if(nmagdiffu .eq. 1 .or. nmagdiffu2 .eq. 1 )ohm_heating=jsquare*etaohmdiss(rho,bcell2,Told,ionisrate)*dt_imp*vol_loc"
  write(ilun,format)"     "
  write(ilun,format)"     if(nambipolar .eq. 1 .or. nambipolar2 .eq.1 )then"
  write(ilun,format)"        ambi_heating = (jy*bz-jz*by)**2+(jz*bx-jx*bz)**2+(jx*by-jy*bx)**2"
  write(ilun,format)"        ambi_heating = ambi_heating * betaad(rho,bcell2,Told,ionisrate)*dt_imp*vol_loc"
  write(ilun,format)"     endif"
  write(ilun,format)"     nimhd_heating=ambi_heating+ohm_heating"
  write(ilun,format)"  end if"
  write(ilun,format)"#endif  "
  write(ilun,format)""
  write(ilun,format)"  lhs=zero"
  write(ilun,format)"  rhs=zero"
  write(ilun,format)"  do igrp=1,ngrp"
  write(ilun,format)"     ! Store radiation_source, deriv_radiation_source and planck opacity to save cpu time"
  write(ilun,format)"     Trold=cal_Teg(uold(i,firstindex_er+igrp)*scale_E0,igrp)"
  write(ilun,format)"     source(igrp)=radiation_source(Told,igrp)                                      ! [erg.cm-3] aT^4 if grey"
  write(ilun,format)"     deriv(igrp)=deriv_radiation_source(Told,igrp)                                 ! [erg.cm-3.K-1] 3aT^3 if grey"
  write(ilun,format)"     wdtB(igrp) = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igrp)/scale_kappa ! [-]"
  write(ilun,format)"     wdtE(igrp) = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igrp)/scale_kappa ! [-]"
  write(ilun,format)"     "
  write(ilun,format)"     lhs=lhs+P_cal*wdtB(igrp)*deriv(igrp)/scale_E0"
  write(ilun,format)"     rhs=rhs-P_cal*wdtB(igrp)*(source(igrp)/scale_E0-Told*deriv(igrp)/scale_E0)"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  mat_residual(:,:) = zero"
  write(ilun,format)"  residual    (:  ) = zero"
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     mat_residual(igroup,igroup) =  (one+wdtE(igroup))*vol_loc"
  write(ilun,format)""
  write(ilun,format)"     ! Terms of coupling radiative groups"
  write(ilun,format)"     do igrp=1,ngrp"
  write(ilun,format)"        mat_residual(igroup,igrp) = mat_residual(igroup,igrp) - wdtB(igroup)*(deriv(igroup)*P_cal*wdtE(igrp)/scale_E0/(cv+lhs))*vol_loc"
  write(ilun,format)"     enddo"
  write(ilun,format)"     protostellar_heating = 0.0d0"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"     if(rt_protostar_m1 .and. rt_advect)then"
  write(ilun,format)"        do im1=1,ngroups"
  write(ilun,format)"           protostellar_heating = rtuold(i,iGroups(im1))*scale_Np*group_egy(im1)*ev_to_erg*kappaAbs(im1)*rho*scale_d*rt_c_cgs*z_ave / (scale_d*scale_v**2)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     residual(igroup) = uold(i,firstindex_er+igroup)*vol_loc  &"
  write(ilun,format)"          & + vol_loc*wdtB(igroup)*(source(igroup)/scale_E0-Told*deriv(igroup)/scale_E0) &"
  write(ilun,format)"!          & + protostellar_heating*vol_loc* (scale_d*scale_v**2)*dt_imp*scale_t/scale_E0 & !M1 injection into the radiative energy eq"
  write(ilun,format)"          & + vol_loc*wdtB(igroup)*deriv(igroup)/scale_E0*protostellar_heating*dt_imp*scale_t/(cv+lhs) & !M1 injection into CvT"
  write(ilun,format)"          & + vol_loc*wdtB(igroup)*deriv(igroup)/scale_E0*(cv*Told+rhs+nimhd_heating)/(cv+lhs) "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_residual_in_cell"
  write(ilun,format)""
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine compute_coeff_left_right_in_cell(i,idim,cell_left,cell_right,nbor_ilevel,dx_loc,coeff_left,coeff_right)"
  write(ilun,format)""
  write(ilun,format)"  use hydro_parameters,only:nvar"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use const"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in)::i,idim,cell_left,cell_right"
  write(ilun,format)"  integer,dimension(2*ndim),intent(in)::nbor_ilevel"
  write(ilun,format)"  real(dp),intent(in)::dx_loc"
  write(ilun,format)"  real(dp),dimension(nvar_bicg,nvar_bicg),intent(out)::coeff_left,coeff_right"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::rho,Told,Trold,cal_Teg,cmp_temp,rosseland_ana,lambda,lambda_fld,R,nu_surf,surf_loc"
  write(ilun,format)"  integer::igroup,irad"
  write(ilun,format)"  real(dp),dimension(nvar_bicg)::C_g,C_d,phi_g,phi_c,phi_d,nu_g,nu_c,nu_d"
  write(ilun,format)""
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)""
  write(ilun,format)"  select case (nbor_ilevel(2*idim-1)) ! Gather main characteristics of left neighbour"
  write(ilun,format)""
  write(ilun,format)"  case (1)"
  write(ilun,format)""
  write(ilun,format)"     if (robin  > zero) then"
  write(ilun,format)"        C_g(:) = one/robin"
  write(ilun,format)"     else"
  write(ilun,format)"        C_g(:) = zero"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_g (irad) = uold(cell_left,ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     Told = cmp_temp(cell_left)"
  write(ilun,format)"     rho  = scale_d * max(uold(cell_left,1),smallr)"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        Trold = cal_Teg(uold(cell_left,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"        nu_g(igroup) = rosseland_ana(rho,Told,Trold,igroup) / scale_kappa"
  write(ilun,format)"        if(nu_g(igroup)*dx_loc .lt. min_optical_depth) nu_g(igroup)=min_optical_depth/dx_loc"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  case (0)"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_g (irad)       = uold(cell_left,ind_bicg(irad))"
  write(ilun,format)"        C_g   (irad)       = one"
  write(ilun,format)"     enddo"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        nu_g  (igroup)       = kappaR_bicg(cell_left,igroup)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  case (-1)"
  write(ilun,format)""
  write(ilun,format)"     C_g(:) = 1.5_dp"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_g (irad) = uold(cell_left,ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     Told = cmp_temp(cell_left)"
  write(ilun,format)"     rho  = scale_d * max(uold(cell_left,1),smallr)"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        Trold = cal_Teg(uold(cell_left,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"        nu_g  (igroup) = rosseland_ana(rho,Told,Trold,igroup) / scale_kappa"
  write(ilun,format)"        if(nu_g(igroup)*2.0d0*dx_loc .lt. min_optical_depth) nu_g(igroup)=min_optical_depth/(2.0d0*dx_loc)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  end select"
  write(ilun,format)""
  write(ilun,format)"  select case (nbor_ilevel(2*idim)) ! Gather main characteristics of right neighbour"
  write(ilun,format)""
  write(ilun,format)"  case (1)"
  write(ilun,format)""
  write(ilun,format)"     if (robin  > zero) then"
  write(ilun,format)"        C_d(:) = one/robin"
  write(ilun,format)"     else"
  write(ilun,format)"        C_d(:) = zero"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_d (irad) = uold(cell_right,ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     Told = cmp_temp(cell_right)"
  write(ilun,format)"     rho  = scale_d * max(uold(cell_right,1),smallr)"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        Trold = cal_Teg(uold(cell_right,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"        nu_d  (igroup) = rosseland_ana(rho,Told,Trold,igroup) / scale_kappa"
  write(ilun,format)"        if(nu_d(igroup)*dx_loc .lt. min_optical_depth) nu_d(igroup)=min_optical_depth/dx_loc"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  case (0)"
  write(ilun,format)""
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_d (irad)  = uold(cell_right,ind_bicg(irad))"
  write(ilun,format)"        C_d   (irad)  = one"
  write(ilun,format)"     enddo"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        nu_d  (igroup)  = kappaR_bicg(cell_right,igroup)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  case (-1)"
  write(ilun,format)""
  write(ilun,format)"     C_d(:) = 1.5_dp"
  write(ilun,format)"     do irad=1,nvar_bicg"
  write(ilun,format)"        phi_d (irad) = uold(cell_right,ind_bicg(irad))/norm_bicg(irad)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"     Told = cmp_temp(cell_right)"
  write(ilun,format)"     rho  = scale_d * max(uold(cell_right,1),smallr)"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        Trold = cal_Teg(uold(cell_right,firstindex_er+igroup)*scale_d*scale_v**2,igroup)"
  write(ilun,format)"        nu_d  (igroup) = rosseland_ana(rho,Told,Trold,igroup) / scale_kappa"
  write(ilun,format)"        if(nu_d(igroup)*2.0d0*dx_loc .lt. min_optical_depth) nu_d(igroup)=min_optical_depth/(2.0d0*dx_loc)"
  write(ilun,format)"     enddo"
  write(ilun,format)""
  write(ilun,format)"  end select"
  write(ilun,format)""
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     nu_c (igroup) = kappaR_bicg(i,igroup)"
  write(ilun,format)"     C_g(igroup) = C_g(igroup) * nu_surf(nu_g(igroup),nu_c(igroup), cell_left ,i,dx_loc)"
  write(ilun,format)"     C_d(igroup) = C_d(igroup) * nu_surf(nu_d(igroup),nu_c(igroup), cell_right,i,dx_loc)"
  write(ilun,format)""
  write(ilun,format)"     phi_c(igroup) = uold(i,firstindex_er+igroup)"
  write(ilun,format)""
  write(ilun,format)"     if(C_g(igroup) > zero)then"
  write(ilun,format)"        R = max(1.0e-10_dp,abs (phi_c(igroup)-phi_g(igroup)) /(half*(phi_c(igroup)+phi_g(igroup))))"
  write(ilun,format)"        R = R / ( C_g(igroup) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"        lambda=lambda_fld(R)"
  write(ilun,format)"        C_g(igroup) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_g(igroup))"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     if(C_d(igroup) > zero)then"
  write(ilun,format)"        R = max(1.0e-10_dp,abs (phi_c(igroup)-phi_d(igroup)) /(half*(phi_c(igroup)+phi_d(igroup))))"
  write(ilun,format)"        R = R / ( C_d(igroup) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"        lambda=lambda_fld(R)"
  write(ilun,format)"        C_d(igroup) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_d(igroup))"
  write(ilun,format)""
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     coeff_left (igroup,igroup)=C_g(igroup)"
  write(ilun,format)"     coeff_right(igroup,igroup)=C_d(igroup)"
  write(ilun,format)""
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_coeff_left_right_in_cell"
  write(ilun,format)"../patch/irradiation/test_pascucci/radiative_transfer_cg.f90"
  write(ilun,format)"subroutine diffusion_cg (ilevel,Nsub)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !==========================================================================="
  write(ilun,format)"  ! Iterative solver with Conjugate Gradient method and Newton Raphson"
  write(ilun,format)"  ! to solve A x = b"
  write(ilun,format)"  !   r1      : stored in unew(i,1)"
  write(ilun,format)"  !   p1      : stored in unew(i,2)"
  write(ilun,format)"  !   Diag(A) : stored in unew(i,4)"
  write(ilun,format)"  !   Ap1     : stored in unew(i,3)"
  write(ilun,format)"  !  x1(i)    : stored in uold(i,irad)(i.e. new radiative energy at time n+1)"
  write(ilun,format)"  !  b1(n)    : stored in unew(i,irad)(i.e. radiative energy at time n)"
  write(ilun,format)"  ! x1(i-1)   : stored in unew(i,7)"
  write(ilun,format)"  !  Tg(i)    : stored in unew(i,nvar+3)"
  write(ilun,format)"  !  Tg(n)    : stored in unew(i,5)"
  write(ilun,format)"  !==========================================================================="
  write(ilun,format)"  integer,intent(IN)::ilevel,Nsub"
  write(ilun,format)"  complex*16 :: final_sum"
  write(ilun,format)"  real(dp)::error,error_ini,epsilon,error_nr,error_nrm1,error_nrm2,error_nrm3"
  write(ilun,format)"  real(dp)::error_nr_loc,error_nr_all,error_cg_loc,error_cg_all"
  write(ilun,format)"  real(dp)::alpha_cg,beta_cg,Cv,told,tnew,wdt,rho,dt_exp,wdtB,wdtE,Tr,Trold"
  write(ilun,format)"  real(dp)::r2_old,r2,pAp,rhs_norm1"
  write(ilun,format)"  real(dp)::density,planck_ana,rosseland_ana,norm_Er,temp,cal_Teg"
  write(ilun,format)"  integer :: i,info,ind,iter,iskip,itermax,icpu,igroup,igrp"
  write(ilun,format)"  integer :: this,iter_nr,nx_loc,nsub_imp,isub,nleaf_all,nleaf_tot"
  write(ilun,format)"  real(dp)::radiation_source,deriv_radiation_source,rhs,lhs"
  write(ilun,format)"  real(dp)::dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp)::min_ener,min_ener_all,max_ener,max_ener_all"
  write(ilun,format)"  real(dp),dimension(1:ngrp)::dener"
  write(ilun,format)"  logical::exist_leaf_cell=.true."
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,111)"
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  allocate(liste_ind (1:twotondim*active(ilevel)%ngrid))"
  write(ilun,format)""
  write(ilun,format)"  nb_ind = 0"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"     do i=1,active(ilevel)%ngrid"
  write(ilun,format)"        if(son(active(ilevel)%igrid(i)+iskip) == 0)then"
  write(ilun,format)"           nb_ind = nb_ind+1 "
  write(ilun,format)"           liste_ind(nb_ind) = active(ilevel)%igrid(i)+iskip"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do icpu=1,ncpu"
  write(ilun,format)"           do i=1,reception(icpu,ilevel)%ngrid"
  write(ilun,format)"              rad_flux(reception(icpu,ilevel)%igrid(i)+iskip,igroup)=0.0d0"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,reception(icpu,ilevel-1)%ngrid"
  write(ilun,format)"              rad_flux(reception(icpu,ilevel-1)%igrid(i)+iskip,igroup)=0.0d0"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)"  if (nb_ind == 0)then"
  write(ilun,format)"!!      print*,'No leaf-cell - myid=',myid"
  write(ilun,format)"     exist_leaf_cell=.false."
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  nleaf_tot=nb_ind"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(nb_ind,nleaf_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  nleaf_tot=nleaf_all"
  write(ilun,format)"#endif"
  write(ilun,format)"     "
  write(ilun,format)"  if(nleaf_tot .eq. 0)then"
  write(ilun,format)"     write(*,*)'No leaf cells at level',ilevel,'. Exiting CG'"
  write(ilun,format)"     deallocate(liste_ind)"
  write(ilun,format)"     return"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     unew(this,1:firstindex_er+ngrp)=0.0d0"
  write(ilun,format)"!     urad(this,1:ngrp)=0.0d0"
  write(ilun,format)"     unew(this,nvar+1)=0.d0"
  write(ilun,format)" !    unew(this,nvar+2)=0.d0"
  write(ilun,format)"     unew(this,nvar+3)=0.0d0"
  write(ilun,format)"     unew(this,2)=0.0d0"
  write(ilun,format)"     unew(this,3)=0.0d0"
  write(ilun,format)"     divu(this)=0.0d0"
  write(ilun,format)"     enew(this)=0.0d0"
  write(ilun,format)"     mat_residual_glob(this,1:ngrp,1:ngrp)=0.0d0"
  write(ilun,format)"     coeff_glob_left(this,1:ngrp,1:ngrp,1:ndim)=0.0d0"
  write(ilun,format)"     coeff_glob_right(this,1:ngrp,1:ngrp,1:ndim)=0.0d0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Set constants"
  write(ilun,format)"  epsilon = epsilon_diff"
  write(ilun,format)""
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  ! Compute gas temperature stored in unew(i,nvar+3) and in unew(i,5)"
  write(ilun,format)"  ! Compute Cv_eos stored in unew(i,nvar+1)"
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  call cmp_energy(1)"
  write(ilun,format)""
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  ! Begin of subcycles...."
  write(ilun,format)"  !==================================================================="
  write(ilun,format)"  dt_exp = dtnew(ilevel)"
  write(ilun,format)"  dt_imp = dtnew(ilevel)"
  write(ilun,format)""
  write(ilun,format)"  dener=0.0d0"
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     max_ener=0.0d0"
  write(ilun,format)"     min_ener=1.0d30"
  write(ilun,format)"     do i=1,nb_ind"
  write(ilun,format)"        this = liste_ind(i)"
  write(ilun,format)"        max_ener=max(max_ener, uold(liste_ind(i),firstindex_er+igroup))"
  write(ilun,format)"        min_ener=min(min_ener, uold(liste_ind(i),firstindex_er+igroup))"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute maximum error"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(max_ener,max_ener_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"     max_ener=max_ener_all"
  write(ilun,format)"     call MPI_ALLREDUCE(min_ener,min_ener_all,1,MPI_DOUBLE_PRECISION,MPI_MIN,MPI_COMM_WORLD,info)"
  write(ilun,format)"     min_ener=min_ener_all"
  write(ilun,format)"#endif"
  write(ilun,format)"     dener(igroup)=max_ener/min_ener"
  write(ilun,format)"  enddo"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  nsub_imp=1"
  write(ilun,format)"!!   if(ngrp .gt. 1 .and. maxval(dener) .gt. 1.d4)then"
  write(ilun,format)"!!      nsub_imp=int(maxval(dener)**0.25)"
  write(ilun,format)"!!      dt_imp=dt_imp/real(nsub_imp)"
  write(ilun,format)"!!   endif"
  write(ilun,format)"  if(ngrp .gt. 1 .and. maxval(dener) .gt. 1.d4)then"
  write(ilun,format)"     nsub_imp=10"
  write(ilun,format)"     dt_imp=dt_imp/real(nsub_imp)"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        print*,'ilevel',ilevel,'igroup',igroup,'MAXIMUM OF DENER=',dener(igroup),'NSUB_IMP=',nsub_imp"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do isub=1,nsub_imp"
  write(ilun,format)""
  write(ilun,format)"     ! DO Newton-Raphson"
  write(ilun,format)"     error_nr=1.0d0"
  write(ilun,format)"     error_nrm1=1.0d-10"
  write(ilun,format)"     error_nrm2=1.0d-10"
  write(ilun,format)"     error_nrm3=1.0d-10"
  write(ilun,format)"     error_cg_loc=1.0d0"
  write(ilun,format)""
  write(ilun,format)"     iter_nr=0"
  write(ilun,format)""
  write(ilun,format)"     "
  write(ilun,format)"!     do while((error_nr .gt. 1.0d-3) .and. (abs((error_nr-error_nrm1)/error_nrm1) .gt. epsilon_diff) .and. (iter_nr .lt. 1000) .and. (abs(error_nr-error_nrm2) .gt. 1.0d-3) .or. iter_nr .lt. ngrp)"
  write(ilun,format)"        iter_nr=iter_nr+1"
  write(ilun,format)"        !Initialize NR error"
  write(ilun,format)"        error_nr_loc=0.0d0"
  write(ilun,format)""
  write(ilun,format)"        error_nrm3=error_nrm2"
  write(ilun,format)"        error_nrm2=error_nrm1"
  write(ilun,format)"        error_nrm1=error_nr"
  write(ilun,format)""
  write(ilun,format)"!!         do i=1,nb_ind"
  write(ilun,format)"!!            this = liste_ind(i)"
  write(ilun,format)"!!            do igroup=1,ngrp"
  write(ilun,format)"!!               urad(this,igroup)=unew(this,firstindex_er+igroup)"
  write(ilun,format)"!!            enddo"
  write(ilun,format)"!!         end do"
  write(ilun,format)""
  write(ilun,format)"        do igroup=1,ngrp"
  write(ilun,format)""
  write(ilun,format)"           !==================================================="
  write(ilun,format)"           ! Compute thermal coefficient :"
  write(ilun,format)"           ! Rosseland opacity : stored in divu(indcell(i))"
  write(ilun,format)"           ! Planck opacity    : stored in enew(indcell(i)) "
  write(ilun,format)"           !==================================================="
  write(ilun,format)"           do i=1,nb_ind"
  write(ilun,format)"              this = liste_ind(i)"
  write(ilun,format)"              density = scale_d * max(uold(this,1),smallr)"
  write(ilun,format)"              temp = unew(this,5)"
  write(ilun,format)"              ! Compute Rosseland opacity (Compute kappa*rho)"
  write(ilun,format)"              divu(this)= rosseland_ana(density,temp,temp,igroup) / scale_kappa       "
  write(ilun,format)"              if(divu(this)*dx_loc .lt. min_optical_depth) divu(this)=min_optical_depth/dx_loc"
  write(ilun,format)"              ! Store radiative energy"
  write(ilun,format)"              enew(this)= unew(this,firstindex_er+igroup)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           ! compute prdivu-nuprdivu ansd store it unew(i,nvar+2) if implicit integration"
  write(ilun,format)"!           call cmp_Prdivu(ilevel,igroup)"
  write(ilun,format)""
  write(ilun,format)"           ! Update boundaries"
  write(ilun,format)"           call make_virtual_fine_dp(enew(1),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,2),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,3),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,1),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,4),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(divu(1),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,5),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,nvar+3),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,nvar+1),ilevel)"
  write(ilun,format)"!           call make_virtual_fine_dp(unew(1,nvar+2),ilevel)"
  write(ilun,format)"           do igrp=1,ngrp"
  write(ilun,format)"              call make_virtual_fine_dp(uold(1,firstindex_er+igrp),ilevel)"
  write(ilun,format)"              call make_virtual_fine_dp(unew(1,firstindex_er+igrp),ilevel)"
  write(ilun,format)"!              call make_virtual_fine_dp(urad(1,igrp),ilevel)"
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"           call make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"           call cmp_matrix_coeff(ilevel,igroup)"
  write(ilun,format)"           !==================================================="
  write(ilun,format)"           ! Compute r1 = b1 - A1x1 and store it into unew(i,1)"
  write(ilun,format)"           ! Also set p1 = r1 and store it into unew(i,2)"
  write(ilun,format)"           !==================================================="
  write(ilun,format)"!ben           call cmp_matrixA (ilevel, 1,igroup)"
  write(ilun,format)"           call cmp_matrixA2 (ilevel, 1,igroup)"
  write(ilun,format)""
  write(ilun,format)"           !        call make_virtual_reverse_dp(unew(1,1),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,1),ilevel)"
  write(ilun,format)""
  write(ilun,format)"           !        call make_virtual_reverse_dp(unew(1,2),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,2),ilevel)"
  write(ilun,format)""
  write(ilun,format)"           !==================================="
  write(ilun,format)"           ! Compute right-hand side norm (max)"
  write(ilun,format)"           !==================================="
  write(ilun,format)"           call dot_product(unew(:,1),unew(:,1),rhs_norm1,final_sum)"
  write(ilun,format)"!! ben           call dot_product(unew(:,firstindex_er+igroup),unew(:,firstindex_er+igroup),norm_er,final_sum) ! compute radiative energy norm"
  write(ilun,format)""
  write(ilun,format)"           !==================================================="
  write(ilun,format)"           ! Compute Preconditionner M=1/diag(A) and store it in unew(i,4)"
  write(ilun,format)"           !==================================================="
  write(ilun,format)"           !ben"
  write(ilun,format)"           call make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"!ben           call cmp_matrixA (ilevel 3,igroup)"
  write(ilun,format)"           call cmp_matrixA2 (ilevel, 3,igroup)"
  write(ilun,format)""
  write(ilun,format)"           !        call make_virtual_reverse_dp(unew(1,4),ilevel)"
  write(ilun,format)"           call make_virtual_fine_dp(unew(1,4),ilevel)"
  write(ilun,format)""
  write(ilun,format)"           !===================================="
  write(ilun,format)"           ! MAIN ITERATION LOOP"
  write(ilun,format)"           !====================================     "
  write(ilun,format)""
  write(ilun,format)"           iter=0; itermax=200000!50000"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"           error_ini=sqrt(rhs_norm1)"
  write(ilun,format)"!! ben           norm_er=sqrt(norm_er)!*vol_loc"
  write(ilun,format)"           !     error_ini=sqrt(real(final_sum))"
  write(ilun,format)"           error=error_ini"
  write(ilun,format)"           error_cg_loc=1.0d0"
  write(ilun,format)""
  write(ilun,format)"           !more restrictive condition: and => or. May not cvg. Raph. Back to non restrictive condition of Benoit"
  write(ilun,format)"           do while((error/error_ini>epsilon .or. error_cg_loc> epsilon) .and. error_ini .gt. 0.0d0) !to remove after checking if it's responsible for diff in E, L btw _ok and _modif"
  write(ilun,format)"!           do while(error/error_ini>epsilon .and. error_cg_loc> epsilon)!error_ini/norm_er .gt. 1.0d-15)                                                 "
  write(ilun,format)"              iter=iter+1"
  write(ilun,format)"              if(iter>itermax)exit"
  write(ilun,format)"             !less restrictive than the restrictive condition"
  write(ilun,format)"             !if(error/error_ini < epsilon .and. error_cg_loc < 1.0e4*epsilon) exit"
  write(ilun,format)"             !if(error/error_ini < 1.0e4*epsilon .and. error_cg_loc < epsilon) exit"
  write(ilun,format)""
  write(ilun,format)"              !============================================"
  write(ilun,format)"              ! Compute z = Mr and store it into unew(i,3)"
  write(ilun,format)"              !============================================"
  write(ilun,format)""
  write(ilun,format)"              do i=1,nb_ind"
  write(ilun,format)"                 this = liste_ind(i)"
  write(ilun,format)"                 unew(this,3) = unew(this,1) * unew(this,4)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Compute scalar r.z"
  write(ilun,format)"              !===================================="
  write(ilun,format)""
  write(ilun,format)"              call dot_product(unew(:,1),unew(:,3),r2,final_sum)"
  write(ilun,format)"              r2=r2!real(final_sum)"
  write(ilun,format)"              !        r2=real(final_sum)"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Compute beta factor"
  write(ilun,format)"              !===================================="
  write(ilun,format)""
  write(ilun,format)"              if(iter==1)then"
  write(ilun,format)"                 beta_cg = 0.0d0"
  write(ilun,format)"              else"
  write(ilun,format)"                 beta_cg = r2/r2_old"
  write(ilun,format)"              end if"
  write(ilun,format)"              r2_old=r2"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Recurrence on p = z + beta*p"
  write(ilun,format)"              !===================================="
  write(ilun,format)"              call cX_plus_Y_to_Z (beta_cg,unew(:,2),unew(:,3),unew(:,2))"
  write(ilun,format)"              ! Update boundaries"
  write(ilun,format)"              call make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"              call make_virtual_fine_dp(unew(1,2),ilevel)"
  write(ilun,format)""
  write(ilun,format)"              !=============================================="
  write(ilun,format)"              ! Compute q1 = Ap1 and store it into unew(i,3)"
  write(ilun,format)"              !=============================================="
  write(ilun,format)"!ben              call cmp_matrixA (ilevel, 2,igroup)"
  write(ilun,format)"              call cmp_matrixA2 (ilevel, 2,igroup)"
  write(ilun,format)""
  write(ilun,format)"              !        call make_virtual_reverse_dp(unew(1,3),ilevel)"
  write(ilun,format)"              call make_virtual_fine_dp(unew(1,3),ilevel)"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Compute p.Ap scalar product"
  write(ilun,format)"              !===================================="
  write(ilun,format)""
  write(ilun,format)"              call dot_product(unew(:,2),unew(:,3),pAp,final_sum)"
  write(ilun,format)"              pap = pap!real(final_sum) !DDP"
  write(ilun,format)"              !        pap = real(final_sum) !DDP"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Compute alpha factor"
  write(ilun,format)"              !===================================="
  write(ilun,format)"              alpha_cg = r2/pAp"
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Recurrence on x = x + alpha*p"
  write(ilun,format)"              !===================================="
  write(ilun,format)"              error_cg_loc=0.0d0"
  write(ilun,format)"              do i=1,nb_ind"
  write(ilun,format)"                 this = liste_ind(i)"
  write(ilun,format)"                 !        unew(liste_ind(i),firstindex_er+igroup) = max(unew(liste_ind(i),firstindex_er+igroup),eray_min/scale_E0)"
  write(ilun,format)"                 error_cg_loc=max(error_cg_loc, abs((alpha_cg*unew(liste_ind(i),2))/enew(this)))"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Compute maximum error"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"              call MPI_ALLREDUCE(error_cg_loc,error_cg_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"              error_cg_loc=error_cg_all"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"              call cX_plus_Y_to_Z (alpha_cg,unew(:,2),unew(:,firstindex_er+igroup),unew(:,firstindex_er+igroup))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"              !===================================="
  write(ilun,format)"              ! Recurrence on r (unew(i,1))"
  write(ilun,format)"              !===================================="
  write(ilun,format)""
  write(ilun,format)"              call cX_plus_Y_to_Z (- alpha_cg ,unew(:,3),unew(:,1),unew(:,1))"
  write(ilun,format)""
  write(ilun,format)"              !==================================="
  write(ilun,format)"              ! Compute right-hand side norm (max)"
  write(ilun,format)"              !==================================="
  write(ilun,format)"              call dot_product(unew(:,1),unew(:,1),rhs_norm1,final_sum)"
  write(ilun,format)""
  write(ilun,format)"              error=SQRT(rhs_norm1)"
  write(ilun,format)"              !        error=SQRT(real(final_sum))"
  write(ilun,format)"              !        error = error_cg_loc"
  write(ilun,format)""
  write(ilun,format)"              if(verbose) write(*,112)iter,error,error/error_ini,error_cg_loc,error_ini"
  write(ilun,format)""
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End main iteration loop"
  write(ilun,format)""
  write(ilun,format)"           if(iter >= itermax)then"
  write(ilun,format)"              if(myid==1)write(*,*)'Diffusion fail to converge...'"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           !===================================="
  write(ilun,format)"           ! Copie des flux"
  write(ilun,format)"           !===================================="
  write(ilun,format)"!           call cmp_matrixA (ilevel, 4,igroup)"
  write(ilun,format)"           call cmp_matrixA2 (ilevel, 4,igroup)"
  write(ilun,format)""
  write(ilun,format)"           if(myid==1) write(*,117)ilevel,igroup,iter,error/error_ini,error_cg_loc"
  write(ilun,format)"!!            if(myid==1) write(*,*)'igroup: ',igroup,' CG :',iter, 'error L2=',error/error_ini,error_ini,norm_er,'error Linf='error_cg_loc"
  write(ilun,format)"           niter=niter+iter"
  write(ilun,format)""
  write(ilun,format)"           do i=1,nb_ind"
  write(ilun,format)"              this = liste_ind(i)"
  write(ilun,format)"              unew(liste_ind(i),firstindex_er+igroup) = max(unew(liste_ind(i),firstindex_er+igroup),eray_min/scale_E0)"
  write(ilun,format)"              error_nr_loc=max(error_nr_loc, abs((enew(this)-unew(liste_ind(i),firstindex_er+igroup))/enew(this)))"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Compute maximum error"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"           call MPI_ALLREDUCE(error_nr_loc,error_nr_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"           error_nr_loc=error_nr_all"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over groups"
  write(ilun,format)""
  write(ilun,format)"!!         !===================================="
  write(ilun,format)"!!         ! Update gas temperature"
  write(ilun,format)"!!         !===================================="
  write(ilun,format)"!!         do i=1,nb_ind"
  write(ilun,format)"!! "
  write(ilun,format)"!!            rho = uold(liste_ind(i),1)"
  write(ilun,format)"!!            Cv = unew(liste_ind(i),nvar+1)"
  write(ilun,format)"!!            Told= unew(liste_ind(i),5)"
  write(ilun,format)"!! "
  write(ilun,format)"!!            rhs=0.d0"
  write(ilun,format)"!!            lhs=0.d0"
  write(ilun,format)"!!            do igrp=1,ngrp"
  write(ilun,format)"!!               wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,igrp)/scale_kappa"
  write(ilun,format)"!!               rhs=rhs-P_cal*wdt*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0 &"
  write(ilun,format)"!!                    & -unew(liste_ind(i),firstindex_er+igrp))"
  write(ilun,format)"!! "
  write(ilun,format)"!!               lhs=lhs+P_cal*wdt*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"!!            enddo"
  write(ilun,format)"!! "
  write(ilun,format)"!!            Tnew = (cv*unew(liste_ind(i),nvar+3)+rhs)/(cv+lhs)"
  write(ilun,format)"!! "
  write(ilun,format)"!!            error_nr_loc=max(error_nr_loc, abs((Told-Tnew)/Tnew))"
  write(ilun,format)"!! "
  write(ilun,format)"!!            unew(liste_ind(i),5)=Tnew"
  write(ilun,format)"!! "
  write(ilun,format)"!!         end do"
  write(ilun,format)"!!         ! Compute global norms"
  write(ilun,format)"!! #ifndef WITHOUTMPI"
  write(ilun,format)"!!         call MPI_ALLREDUCE(error_nr_loc,error_nr_all,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"!!         error_nr_loc=error_nr_all"
  write(ilun,format)"!! #endif"
  write(ilun,format)""
  write(ilun,format)"        error_nr=error_nr_loc"
  write(ilun,format)"!!      error_nr=1.d-10"
  write(ilun,format)"        if(ngrp ==1)error_nr=1.0d-10 ! No NR iterations for 1 group"
  write(ilun,format)"        do igroup=1,ngrp"
  write(ilun,format)"           call make_boundary_diffusion(ilevel,igroup)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"!!         if(myid==1)write(*,115)ilevel,iter,error,error/error_ini"
  write(ilun,format)""
  write(ilun,format)"        if(myid==1)write(*,116)ilevel,iter_nr,error_nr"
  write(ilun,format)""
  write(ilun,format)"     end do"
  write(ilun,format)"     !End loop over NR iteration"
  write(ilun,format)""
  write(ilun,format)"        !===================================="
  write(ilun,format)"        ! Update gas temperature"
  write(ilun,format)"        !===================================="
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)""
  write(ilun,format)"           rho = uold(liste_ind(i),1)"
  write(ilun,format)"           Cv = unew(liste_ind(i),nvar+1)"
  write(ilun,format)"           Told= unew(liste_ind(i),5)"
  write(ilun,format)""
  write(ilun,format)"           rhs=0.d0"
  write(ilun,format)"           lhs=0.d0"
  write(ilun,format)"           do igrp=1,ngrp"
  write(ilun,format)"              Trold = cal_Teg(uold(liste_ind(i),firstindex_er+igrp)*scale_E0,igrp)"
  write(ilun,format)""
  write(ilun,format)"              wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igrp)/scale_kappa"
  write(ilun,format)"              wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"!!               wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igrp)/scale_kappa"
  write(ilun,format)""
  write(ilun,format)"              rhs=rhs-P_cal*wdtB*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0) &"
  write(ilun,format)"                   & + P_cal*wdtE*unew(liste_ind(i),firstindex_er+igrp)"
  write(ilun,format)"              "
  write(ilun,format)"              lhs=lhs+P_cal*wdtB*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"           enddo"
  write(ilun,format)""
  write(ilun,format)"           Tnew = (cv*unew(liste_ind(i),nvar+3)+rhs)/(cv+lhs)"
  write(ilun,format)""
  write(ilun,format)"           error_nr_loc=max(error_nr_loc, abs((Told-Tnew)/Tnew))"
  write(ilun,format)""
  write(ilun,format)"           unew(liste_ind(i),5)=Tnew"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"     !update radiative energy and temperature"
  write(ilun,format)"     do i=1,nb_ind"
  write(ilun,format)"        do igrp=1,ngrp"
  write(ilun,format)"           uold(liste_ind(i),firstindex_er+igrp)=unew(liste_ind(i),firstindex_er+igrp)"
  write(ilun,format)"        end do"
  write(ilun,format)"        unew(liste_ind(i),nvar+3)=unew(liste_ind(i),5)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!  end do"
  write(ilun,format)"  !ENd loop over subcycles"
  write(ilun,format)""
  write(ilun,format)"  if(myid == 1)      print*,'niter tot=',niter"
  write(ilun,format)""
  write(ilun,format)"  !============================="
  write(ilun,format)"  ! Update energy value"
  write(ilun,format)"  !============================="
  write(ilun,format)"  if(static) then"
  write(ilun,format)"     do igroup=1,ngrp"
  write(ilun,format)"        do i=1,nb_ind"
  write(ilun,format)"           uold(liste_ind(i),firstindex_er+igroup) = unew(liste_ind(i),firstindex_er+igroup)*P_cal"
  write(ilun,format)"        end do"
  write(ilun,format)"     enddo"
  write(ilun,format)"  else"
  write(ilun,format)"     call cmp_energy(2)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Update boundaries"
  write(ilun,format)"  do igroup=1,ngrp"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,firstindex_er+igroup),ilevel)"
  write(ilun,format)"     if(ilevel .gt. levelmin)call make_virtual_reverse_dp(rad_flux(1,igroup),ilevel-1)"
  write(ilun,format)"     !  if(ilevel .gt. levelmin)call make_virtual_fine_dp(rad_flux(1,igroup),ilevel-1)"
  write(ilun,format)"     call make_virtual_reverse_dp(rad_flux(1,igroup),ilevel)"
  write(ilun,format)"     !  call make_virtual_fine_dp(rad_flux(1,igroup),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  call make_virtual_fine_dp(uold(1,5),ilevel)"
  write(ilun,format)"  call make_virtual_fine_dp(uold(1,nvar),ilevel)"
  write(ilun,format)"!  call upload_fine(ilevel)"
  write(ilun,format)"!  call upload_fine(ilevel-1)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering diffusion_cg')"
  write(ilun,format)"112 format('   ==> Step=',i5,' Error=',2(1pe10.3,1x),e23.15,es18.5)"
  write(ilun,format)"115 format('   ==> Level=',i5,' Step=',i5,' Error=',2(1pe10.3,1x))"
  write(ilun,format)"116 format('   ==> Level=',i5,' Step NR =',i5,' Error=',(1pe10.3,1x))"
  write(ilun,format)"117 format('   ==> Level=',i5,' igroup=',i3,' Iteration CG=',i5,' Error L2=',(1pe10.3,1x),' Error Linf=',(1pe10.3,1x))"
  write(ilun,format)""
  write(ilun,format)"  deallocate(liste_ind)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"contains"
  write(ilun,format)""
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  !###########################################################"
  write(ilun,format)""
  write(ilun,format)"  subroutine dot_product(fact1,fact2,pdtvect,local_sum) !                pdtvect = sum(fact1*fact2)"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax),intent(IN)::fact1,fact2"
  write(ilun,format)"    real(dp),intent(OUT)::pdtvect"
  write(ilun,format)"    complex*16,intent(OUT)::local_sum"
  write(ilun,format)""
  write(ilun,format)"    real(dp)::pdtvect_all"
  write(ilun,format)"    complex*16 ::global_sum"
  write(ilun,format)"    integer::this"
  write(ilun,format)""
  write(ilun,format)"    pdtvect=0.0d0"
  write(ilun,format)"    local_sum = cmplx(0.0d0,0.0d0)"
  write(ilun,format)"    global_sum = cmplx(0.0d0,0.0d0)"
  write(ilun,format)""
  write(ilun,format)"    do i=1,nb_ind"
  write(ilun,format)"       this = liste_ind(i)"
  write(ilun,format)"       !call DDPDD (cmplx(fact1(this)*fact2(this), 0.0,dp), local_sum, 1, itype)"
  write(ilun,format)"       pdtvect = pdtvect + fact1(this)*fact2(this)"
  write(ilun,format)"    end do"
  write(ilun,format)""
  write(ilun,format)"    ! Compute global norms"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"    call MPI_ALLREDUCE(pdtvect,pdtvect_all,1,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"    pdtvect   = pdtvect_all"
  write(ilun,format)"    !call MPI_ALLREDUCE(local_sum,global_sum,1,MPI_COMPLEX,MPI_SUMDD,MPI_COMM_WORLD,info)"
  write(ilun,format)"    !local_sum = global_sum"
  write(ilun,format)"    local_sum = pdtvect"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  end subroutine dot_product"
  write(ilun,format)"  "
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  !###########################################################"
  write(ilun,format)"  subroutine cX_plus_Y_to_Z (cste,vectX,vectY,vectZ)! vectZ = cste*vectX+vectY"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax),intent(IN)::vectX,vectY"
  write(ilun,format)"    real(dp),intent(IN)::cste"
  write(ilun,format)"    real(dp),dimension(1:ncoarse+twotondim*ngridmax),intent(OUT)::vectZ"
  write(ilun,format)"    "
  write(ilun,format)"    "
  write(ilun,format)"    do i=1,nb_ind"
  write(ilun,format)"       vectZ(liste_ind(i)) = vectY(liste_ind(i)) + cste*vectX(liste_ind(i)) "
  write(ilun,format)"    end do"
  write(ilun,format)""
  write(ilun,format)"  end subroutine cX_plus_Y_to_Z"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine diffusion_cg"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine cmp_matrixA (ilevel,compute,igroup)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the matrix A to vect_in and create vect_out"
  write(ilun,format)"  ! compute = 1 : residu           	return B - Ax"
  write(ilun,format)"  ! compute = 2 : Produit                 return  A.p"
  write(ilun,format)"  ! compute = 3 : Preconditionner         return diag(A)"
  write(ilun,format)"  ! compute = 4 : Compute flux in rad_flux"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use const"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::compute,ilevel,igroup"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: residu,C_g,C_d,nu_g,nu_c,nu_d"
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: phi_g,phi_c,phi_d,val_g,val_d"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  integer :: i,idim,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: radiation_source,deriv_radiation_source,rhs,lhs,cal_Teg"
  write(ilun,format)"  real(dp):: dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp):: nu_surf,Cv,rho,wdtB,wdtE,Told,Trold,lambda,lambda_fld,R"
  write(ilun,format)"  real(dp):: cmp_temp,rosseland_ana,planck_ana,Prdivu"
  write(ilun,format)"  real(dp)::ambi_heating,ohm_heating,nimhd_heating,bcell2,bx,by,bz,jsquare,jx,jy,jz,etaohmdiss,betaad"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        select case (compute)"
  write(ilun,format)""
  write(ilun,format)"        case (1)"
  write(ilun,format)"           ! residu = b - Ax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 rho   = uold (ind_cell(i),1)"
  write(ilun,format)"                 Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"                 Prdivu = 0.0d0!unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"                 Told  =  unew(ind_cell(i),5)"
  write(ilun,format)""
  write(ilun,format)"                 ambi_heating=zero"
  write(ilun,format)"                 ohm_heating=zero"
  write(ilun,format)"                 nimhd_heating=zero"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"                 bx=0.5d0*(uold(ind_cell(i),6)+uold(ind_cell(i),nvar+1))"
  write(ilun,format)"                 by=0.5d0*(uold(ind_cell(i),7)+uold(ind_cell(i),nvar+2))"
  write(ilun,format)"                 bz=0.5d0*(uold(ind_cell(i),8)+uold(ind_cell(i),nvar+3))"
  write(ilun,format)"                 bcell2=(bx**2+by**2+bz**2)"
  write(ilun,format)"                 jx=uold(ind_cell(i),nvar-3)"
  write(ilun,format)"                 jy=uold(ind_cell(i),nvar-2)"
  write(ilun,format)"                 jz=uold(ind_cell(i),nvar-1)"
  write(ilun,format)"                 jsquare=(jx**2+jy**2+jz**2) "
  write(ilun,format)"                 ionisrate=default_ionisrate"
  write(ilun,format)"                 "
  write(ilun,format)"                 if((nmagdiffu .eq. 1 .or. nambipolar .eq.1 .or. nmagdiffu2 .eq. 1 .or. nambipolar2 .eq.1) .and. radiative_nimhdheating)then"
  write(ilun,format)"                    "
  write(ilun,format)"                    if(nmagdiffu .eq. 1 )ohm_heating=jsquare*etaohmdiss(rho,bcell2,Told,ionisrate)*dt_imp*vol_loc"
  write(ilun,format)"                    "
  write(ilun,format)"                    if(nambipolar .eq. 1 )then"
  write(ilun,format)"                       ambi_heating = (jy*bz-jz*by)**2+(jz*bx-jx*bz)**2+(jx*by-jy*bx)**2"
  write(ilun,format)"                       ambi_heating = ambi_heating * betaad(rho,bcell2,Told,ionisrate)*dt_imp*vol_loc"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    nimhd_heating=nimhd_heating+ohm_heating"
  write(ilun,format)"                 end if"
  write(ilun,format)"#endif  "
  write(ilun,format)"                 "
  write(ilun,format)"                 rhs=0.0d0"
  write(ilun,format)"                 lhs=0.0d0"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    Trold=cal_Teg(uold(ind_cell(i),firstindex_er+igrp)*scale_E0,igrp)"
  write(ilun,format)"                    wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igrp)/scale_kappa"
  write(ilun,format)"                    wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"!!                     wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igrp)/scale_kappa"
  write(ilun,format)"                    "
  write(ilun,format)"                    lhs=lhs+P_cal*wdtB*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"                    rhs=rhs-P_cal*wdtB*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0)"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igroup)/scale_kappa"
  write(ilun,format)"                 residu(i) = uold(ind_cell(i),firstindex_er+igroup)*vol_loc  &"
  write(ilun,format)"                      & + vol_loc*wdtB*(radiation_source(Told,igroup)/scale_E0-Told*deriv_radiation_source(Told,igroup)/scale_E0) &"
  write(ilun,format)"                      & + vol_loc*wdtB*deriv_radiation_source(Told,igroup)/scale_E0*(cv*unew(ind_cell(i),nvar+3)+rhs+nimhd_heating)/(cv+lhs)"
  write(ilun,format)""
  write(ilun,format)"                 ! Terms of coupling radiative groups"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    if(igrp .ne. igroup) then"
  write(ilun,format)"                       Trold=cal_Teg(uold(ind_cell(i),firstindex_er+igrp)*scale_E0,igrp)"
  write(ilun,format)"                       wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"!!                        wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igrp)/scale_kappa"
  write(ilun,format)"                       residu(i) = residu(i) + vol_loc*wdtB*deriv_radiation_source(Told,igroup)/scale_E0/(cv+lhs) * P_cal*wdtE*unew(ind_cell(i),firstindex_er+igrp)"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"!!                  residu(i) = residu(i) &"
  write(ilun,format)"!!                       &       - (1.0d0+Prdivu+wdt*(1.0d0-deriv_radiation_source(Told,igroup)*P_cal*wdt/scale_E0/(cv+lhs))) *unew(ind_cell(i),firstindex_er+igroup) *vol_loc"
  write(ilun,format)"                 Trold=cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_E0,igroup)"
  write(ilun,format)"                 wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"!!                  wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igroup)/scale_kappa"
  write(ilun,format)"                 residu(i) = residu(i) &"
  write(ilun,format)"                      &       - (1.0d0+Prdivu+wdtE-wdtB*deriv_radiation_source(Told,igroup)*P_cal*wdtE/scale_E0/(cv+lhs)) *unew(ind_cell(i),firstindex_er+igroup) *vol_loc"
  write(ilun,format)""
  write(ilun,format)"                 !compute b"
  write(ilun,format)"                 residu(i) = residu(i)+(1.0d0-robin)*rad_flux(ind_cell(i),igroup)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        case (2)"
  write(ilun,format)"           ! residu = Ix"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 rho  = uold(ind_cell(i),1)"
  write(ilun,format)"                 Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"                 Told = unew(ind_cell(i),5)"
  write(ilun,format)""
  write(ilun,format)"                 lhs=0.0d0"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"                    lhs=lhs+P_cal*wdtB*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 Trold=cal_Teg(uold(ind_cell(i),firstindex_er+igroup)*scale_E0,igroup)"
  write(ilun,format)"                 wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igroup)/scale_kappa"
  write(ilun,format)"                 wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"!!                  wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igroup)/scale_kappa"
  write(ilun,format)"                 Prdivu = 0.0d0!unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"                 residu(i) =  (1.0d0+Prdivu+wdtE-wdtB*deriv_radiation_source(Told,igroup)*P_cal*wdtE/scale_E0/(cv+lhs)) *unew(ind_cell(i),2) *vol_loc"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (3)"
  write(ilun,format)"           ! residu = I"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 rho  = uold(ind_cell(i),1)"
  write(ilun,format)"                 Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"                 Told = unew(ind_cell(i),5)"
  write(ilun,format)""
  write(ilun,format)"                 lhs=0.0d0"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"                    lhs=lhs+P_cal*wdtB*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 wdtB = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told ,igroup)/scale_kappa"
  write(ilun,format)"                 wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"!!                  wdtE = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Trold,igroup)/scale_kappa"
  write(ilun,format)"                 Prdivu = 0.0d0!unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"                 residu(i) =  (1.0d0+Prdivu+wdtE-wdtB*deriv_radiation_source(Told,igroup)*P_cal*wdtE/scale_E0/(cv+lhs)) *vol_loc"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (4)"
  write(ilun,format)"           ! reinitialize rad_flux for this level"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 rad_flux(ind_cell(i),igroup) = 0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end select"
  write(ilun,format)"        "
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1               !direction of left nbor grid"
  write(ilun,format)"	      supD = 0              		!direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"	   else"
  write(ilun,format)" 	      supG = 0              		!direction of left nbor grid"
  write(ilun,format)"	      supD = (idim-1)*2+2   		!direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"	   end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor indice offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"       ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then			! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else						! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then			! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else						! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           select case (compute)! Getting val_g and val_d"
  write(ilun,format)"	   case(1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = enew(cell_left (i,idim))"
  write(ilun,format)"                    val_d	(i)       = enew(cell_right(i,idim))"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case(2)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = unew(cell_left (i,idim),2)"
  write(ilun,format)"                    val_d	(i)       = unew(cell_right(i,idim),2)	"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case(4)"
  write(ilun,format)""
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = unew(cell_left (i,idim),firstindex_er+igroup)"
  write(ilun,format)"                    val_d	(i)       = unew(cell_right(i,idim),firstindex_er+igroup)"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           end select"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid			! Gather main characteristics of left neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim-1))"
  write(ilun,format)""
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_g (i)       = max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_g	(i)       = 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_g	(i)       = phi_g(i)!uold(cell_left(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)"                    nu_g	(i)       = divu(ind_cell(i))"
  write(ilun,format)"                    if (robin > 0.0d0)		C_g	(i)       = 1.0d0/robin"
  write(ilun,format)"                    if (robin == 0.0d0)		  C_g	(i)       = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"                    Told      	= cmp_temp(cell_left(i,idim))"
  write(ilun,format)"                    rho      	= scale_d * max(uold(cell_left(i,idim),1),smallr)"
  write(ilun,format)"                    nu_g  (i)	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_g(i)*dx_loc .lt. min_optical_depth) nu_g(i)=min_optical_depth/dx_loc"
  write(ilun,format)""
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i)       = enew(cell_left(i,idim))"
  write(ilun,format)"                    val_g	(i)       = val_g (i)"
  write(ilun,format)"                    nu_g	(i)       = divu(cell_left(i,idim))"
  write(ilun,format)"                    C_g	(i)       = 1.0d0"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i) 	= max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    Told      	= cmp_temp(cell_left(i,idim))"
  write(ilun,format)"                    rho      	= scale_d * max(uold(cell_left(i,idim),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"                    if (compute==2)		  val_g (i) 	= 0.0d0"
  write(ilun,format)"                    if (compute/=2) 	  val_g (i)     = phi_g(i)"
  write(ilun,format)"                    nu_g  (i)	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_g(i)*2.0d0*dx_loc .lt. min_optical_depth) nu_g(i)=min_optical_depth/(2.0d0*dx_loc)         "
  write(ilun,format)"                    C_g	(i) 	= 1.5d0"
  write(ilun,format)""
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid				! Gather main characteristics of right neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim))"
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_d (i)       = max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_d	(i)       = 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_d	(i)       = phi_d(i)!uold(cell_right(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)"                    nu_d	(i)       = divu(ind_cell(i))"
  write(ilun,format)"                    if (robin > 0.0d0)		C_d	(i)       = 1.0d0/robin"
  write(ilun,format)"                    if (robin == 0.0d0)		  C_d	(i)       = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"                    Told 		= cmp_temp(cell_right(i,idim))"
  write(ilun,format)"                    rho 		= scale_d * max(uold(cell_right(i,idim),1),smallr)"
  write(ilun,format)"                    nu_d  (i) 	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_d(i)*1.0d0*dx_loc .lt. min_optical_depth) nu_d(i)=min_optical_depth/(1.0d0*dx_loc)"
  write(ilun,format)""
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)       = enew(cell_right(i,idim))"
  write(ilun,format)"                    val_d	(i)       = val_d (i)"
  write(ilun,format)"                    nu_d  (i)       = divu(cell_right(i,idim))"
  write(ilun,format)"                    C_d   (i)       = 1.0d0"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)	= max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    Told 		= cmp_temp(cell_right(i,idim))"
  write(ilun,format)"                    rho 		= scale_d * max(uold(cell_right(i,idim),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"                    if (compute==2)		  val_d (i) 	= 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_d (i)     = phi_d(i)"
  write(ilun,format)"                    nu_d  (i) 	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    C_d   (i)	= 1.5d0"
  write(ilun,format)"                    if(nu_d(i)*2.0d0*dx_loc .lt. min_optical_depth) nu_d(i)=min_optical_depth/(2.0d0*dx_loc)"
  write(ilun,format)"           "
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then ! getting nu_surface"
  write(ilun,format)"                 nu_c (i) = divu(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)"                 C_g(i)           = C_g(i) * nu_surf(nu_g(i),nu_c(i), cell_left(i,idim) ,ind_cell(i),dx_loc)"
  write(ilun,format)"                 C_d(i)           = C_d(i) * nu_surf(nu_d(i),nu_c(i), cell_right(i,idim),ind_cell(i),dx_loc)"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 phi_c(i) = enew(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                 if(C_g(i) > 0.0d0)then"
  write(ilun,format)""
  write(ilun,format)"                    R = max(1.0d-10,abs (phi_c(i)-phi_g(i)) /(0.5d0*(phi_c(i)+phi_g(i))))"
  write(ilun,format)"                    R = R / ( C_g(i) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"                    lambda=lambda_fld(R)"
  write(ilun,format)"                    C_g(i) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_g(i))"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"                 if(C_d(i) > 0.0d0)then"
  write(ilun,format)"                    R = max(1.0d-10,abs (phi_c(i)-phi_d(i)) /(0.5d0*(phi_c(i)+phi_d(i))))"
  write(ilun,format)"                    R = R / ( C_d(i) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"                    lambda=lambda_fld(R)"
  write(ilun,format)"                    C_d(i) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_d(i))"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"           if (compute ==4)then		! Computing and saving flux to the coarser ilevel"
  write(ilun,format)""
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim-1) == -1)then"
  write(ilun,format)""
  write(ilun,format)"                       rad_flux(cell_left(i,idim),igroup)  = rad_flux(cell_left(i,idim),igroup)  + &"
  write(ilun,format)"                            & C_g(i) *( alpha_imp * (unew(ind_cell(i),firstindex_er+igroup) - val_g(i)) + (1.0d0-alpha_imp)*(phi_c(i) - phi_g(i))) "
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim)   == -1 )then"
  write(ilun,format)""
  write(ilun,format)"                       rad_flux(cell_right(i,idim),igroup) = rad_flux(cell_right(i,idim),igroup) + &"
  write(ilun,format)"                            & C_d(i) *( alpha_imp * (unew(ind_cell(i),firstindex_er+igroup) - val_d(i)) + (1.0d0-alpha_imp)*(phi_c(i) - phi_d(i)))"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   select case (compute)"
  write(ilun,format)""
  write(ilun,format)"	   case (1)		 ! compute b-Ax from b-Ix by adding intern flux"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) - ((C_g(i)+C_d(i))* enew(ind_cell(i)) - C_g(i)*val_g(i) - C_d(i)*val_d(i))"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case (2)		! compute Ap from Ip by adding intern flux"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) + ((C_g(i)+C_d(i))* unew(ind_cell(i),2) - C_g(i)*val_g(i) - C_d(i)*val_d(i))*alpha_imp"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case (3)		! compute Diag(A) for preconditionner"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) + (C_g(i) + C_d(i))*alpha_imp"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   end select"
  write(ilun,format)""
  write(ilun,format)"	end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	select case (compute)"
  write(ilun,format)"    ! get the result out"
  write(ilun,format)""
  write(ilun,format)"	case (1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),1) = residu(i)"
  write(ilun,format)"                 unew(ind_cell(i),2) = residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	case (2)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),3) = residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	case (3)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),4) = 1.0d0/residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	end select"
  write(ilun,format)""
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do	  ! ncache"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_matrixA"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"function lambda_fld(R)"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::R,lambda_fld"
  write(ilun,format)""
  write(ilun,format)"    lambda_fld = one/three"
  write(ilun,format)"  if(i_fld_limiter==i_fld_limiter_levermore) lambda_fld =(2.0d0+r)/(6.0d0+2.0d0*R+R**2)! (one/tanh(R)-one/R) / R"
  write(ilun,format)"  if(i_fld_limiter==i_fld_limiter_minerbo) then "
  write(ilun,format)"     if(R .le. three/two) then"
  write(ilun,format)"        lambda_fld = two/(three+sqrt(nine+12.0_dp*R*R))"
  write(ilun,format)"     else"
  write(ilun,format)"        lambda_fld = one/(one + R + sqrt(one+two*R))"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"  return "
  write(ilun,format)"end function lambda_fld"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine cmp_energy(Etype)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in) :: Etype ! Etype=1 : beginning ; Etype=2 : end"
  write(ilun,format)"  integer ::i,idim,this,mvar,igroup"
  write(ilun,format)"  real(dp)::usquare,Cv,eps,ekin,emag,rho,erad_loc"
  write(ilun,format)"  real(dp)::Tp_loc"
  write(ilun,format)""
  write(ilun,format)"  ! EOS"
  write(ilun,format)"  real(dp) :: dd,ee,cmp_temp"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nb_ind"
  write(ilun,format)"     this = liste_ind(i)"
  write(ilun,format)"     rho   = uold(this,1)"
  write(ilun,format)""
  write(ilun,format)"     ! Compute total kinetic energy"
  write(ilun,format)"     usquare=0.0d0"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        usquare=usquare+(uold(this,idim+1)/uold(this,1))**2"
  write(ilun,format)"     end do"
  write(ilun,format)"     ekin  = rho*usquare/2.0d0"
  write(ilun,format)""
  write(ilun,format)"     ! Compute total magnetic energy"
  write(ilun,format)"     emag = 0.0d0"
  write(ilun,format)"     do mvar=1,3"
  write(ilun,format)"        emag = emag + 0.125d0*(uold(this,5+mvar)+uold(this,nvar+mvar))**2"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     if(Etype==1)then"
  write(ilun,format)""
  write(ilun,format)"        ! Compute total radiative energy"
  write(ilun,format)"        erad_loc = 0.0d0"
  write(ilun,format)"        do igroup=1,nener"
  write(ilun,format)"           erad_loc = erad_loc + uold(this,8+igroup)"
  write(ilun,format)"        enddo"
  write(ilun,format)"        "
  write(ilun,format)"        dd=rho*scale_d"
  write(ilun,format)""
  write(ilun,format)"        eps = (uold(this,5)-ekin-emag-erad_loc)"
  write(ilun,format)"        if(energy_fix)eps = (uold(this,nvar)) !neil : comment this for radiative shock"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        Tp_loc = cmp_temp(this)"
  write(ilun,format)"        "
  write(ilun,format)"        Cv = eps/Tp_loc"
  write(ilun,format)"        "
  write(ilun,format)"        unew(this,nvar+3) = Tp_loc"
  write(ilun,format)"        unew(this,5)      = unew(this,nvar+3)"
  write(ilun,format)"        unew(this,nvar+1) = Cv"
  write(ilun,format)""
  write(ilun,format)"        do igroup=1,ngrp"
  write(ilun,format)"           uold(this,firstindex_er+igroup)   = uold(this,firstindex_er+igroup)/P_cal "
  write(ilun,format)"           uold(this,firstindex_er+igroup) = max(uold(this,firstindex_er+igroup),eray_min/scale_E0)"
  write(ilun,format)"           unew(this,firstindex_er+igroup)   = uold(this,firstindex_er+igroup)"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"     elseif(Etype==2)then"
  write(ilun,format)"        Cv = unew(this,nvar+1) "
  write(ilun,format)"        eps = Cv * unew(this,5)"
  write(ilun,format)""
  write(ilun,format)"        uold(this,5)    = eps + ekin + emag"
  write(ilun,format)"        uold(this,nvar) = eps"
  write(ilun,format)""
  write(ilun,format)"        do igroup=1,ngrp"
  write(ilun,format)"           unew(this,firstindex_er+igroup) = max(unew(this,firstindex_er+igroup),eray_min/scale_E0)"
  write(ilun,format)"           uold(this,firstindex_er+igroup) = unew(this,firstindex_er+igroup)*P_cal"
  write(ilun,format)"        end do"
  write(ilun,format)"        do igroup=1,nener"
  write(ilun,format)"           uold(this,5)    =  uold(this,5) + uold(this,8+igroup)"
  write(ilun,format)"        enddo"
  write(ilun,format)""
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_energy"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"function cmp_temp(this)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(in) ::this"
  write(ilun,format)"  integer ::idim,mvar,igrp"
  write(ilun,format)"  real(dp)::usquare,Cv,eps,ekin,emag,rho,erad_loc"
  write(ilun,format)"  real(dp)::cmp_temp"
  write(ilun,format)""
  write(ilun,format)"  ! EOS"
  write(ilun,format)"  real(dp) :: dd,ee"
  write(ilun,format)"  integer  :: ht"
  write(ilun,format)""
  write(ilun,format)"  rho   = uold(this,1)"
  write(ilun,format)"!!   Cv    = rho*kB/(mu_gas*mH*(gamma-1.0d0))/scale_v**2"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total kinetic energy"
  write(ilun,format)"  usquare=0.0d0"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     usquare=usquare+(uold(this,idim+1)/uold(this,1))**2"
  write(ilun,format)"  end do"
  write(ilun,format)"  ekin  = rho*usquare/2.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total magnetic energy"
  write(ilun,format)"  emag = 0.0d0"
  write(ilun,format)"  do mvar=1,3"
  write(ilun,format)"     emag = emag + 0.125d0*(uold(this,5+mvar)+uold(this,nvar+mvar))**2"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute total radiative energy"
  write(ilun,format)"  erad_loc  = 0.0d0"
  write(ilun,format)"  do igrp=1,nener"
  write(ilun,format)"     erad_loc = erad_loc + uold(this,8+igrp)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  eps = (uold(this,5)-ekin-emag-erad_loc)"
  write(ilun,format)"  if(energy_fix)eps = (uold(this,nvar)) !neil : comment this for radiative shock"
  write(ilun,format)""
  write(ilun,format)"!!   if(eos)then"
  write(ilun,format)"     call temperature_eos(rho,eps,cmp_temp,ht)"
  write(ilun,format)"!!   else"
  write(ilun,format)"!!      cmp_temp = eps/Cv"
  write(ilun,format)"!!   endif"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)""
  write(ilun,format)"end function cmp_temp"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"function nu_surf(Er1,Er2,ind1,ind2,dx)"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use const"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::ind1,ind2"
  write(ilun,format)"  real(dp),INTENT(IN)::Er2,Er1,dx"
  write(ilun,format)"  real(dp)::nu_surf,nu_harmo,nu_ari,dl,dr"
  write(ilun,format)""
  write(ilun,format)"  nu_ari=(Er2+Er1)*half"
  write(ilun,format)""
  write(ilun,format)"  nu_harmo = Er2*Er1/nu_ari"
  write(ilun,format)"  if(nu_harmo < four/three*dx) nu_harmo = four/three*dx  "
  write(ilun,format)"  nu_harmo=max(Er2*Er1/nu_ari,four/(three*dx))"
  write(ilun,format)"  nu_surf = nu_ari"
  write(ilun,format)""
  write(ilun,format)"  nu_surf=min(nu_harmo,nu_ari)"
  write(ilun,format)""
  write(ilun,format)"  return "
  write(ilun,format)"end function nu_surf"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)""
  write(ilun,format)"subroutine ind_bound(b_type,inbor,ind_ref)"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer,intent(IN)::b_type"
  write(ilun,format)"  integer,intent(OUT)::inbor"
  write(ilun,format)"  integer,dimension(1:8),intent(OUT)::ind_ref"
  write(ilun,format)"  integer::D,num,sens,dir"
  write(ilun,format)""
  write(ilun,format)"  dir = modulo(b_type,10)"
  write(ilun,format)"  D = (dir+1)/2"
  write(ilun,format)"  sens = modulo(dir,2)"
  write(ilun,format)"  ! Compute direction of reference neighbors"
  write(ilun,format)"  inbor = dir + 2*sens - 1"
  write(ilun,format)"  ! Compute index of reference cells"
  write(ilun,format)"  do num = 1,8"
  write(ilun,format)"     if (modulo((num-1)/2**(D-1),2)==0)then "
  write(ilun,format)"        if(b_type>10)then"
  write(ilun,format)"           ind_ref(num) = num + (1-sens) * 2**(D-1)"
  write(ilun,format)"        else"
  write(ilun,format)"           ind_ref(num) = num + 2**(D-1)"
  write(ilun,format)"        end if"
  write(ilun,format)"     else"
  write(ilun,format)"        if(b_type>10) then"
  write(ilun,format)"           ind_ref(num) = num - 2**(D-1) + (1-sens) * 2**(D-1)"
  write(ilun,format)"        else"
  write(ilun,format)"           ind_ref(num) = num - 2**(D-1) "
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine ind_bound"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine cmp_Prdivu(ilevel,igroup)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the radiative pressure work and store it in unew(nvar+2)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::ilevel,igroup"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: residu,nu_c"
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: phi_c"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ndim),save:: vel_g,vel_d"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:ngrp),save:: Er_g,Er_d"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save:: dx_g,dx_d"
  write(ilun,format)""
  write(ilun,format)"  integer :: i,j,k,idim,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: d_loc,Tp_loc,dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp):: rosseland_ana"
  write(ilun,format)"  real(dp):: kappa_R,gradEr_norm,gradEr_norm2,R,lambda,lambda_fld,chi"
  write(ilun,format)""
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ngrp)::gradEr"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ndim)::divu_loc"
  write(ilun,format)"  real(dp) ,dimension(1:ndim,1:ndim,1:ngrp)::Pg"
  write(ilun,format)"  real(dp) :: nuPrDivu,nuPr,nuPl,Pr_nu,Pgdivu"
  write(ilun,format)"  real(dp), dimension(1:5) :: Pr_temp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1   		!direction of left nbor grid"
  write(ilun,format)"              supD = 0              		!direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"           else"
  write(ilun,format)"              supG = 0              		!direction of left nbor grid"
  write(ilun,format)"              supD = (idim-1)*2+2   		!direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor indice offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"              ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then			! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else						! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 else							! Left nbor less refined than me"
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then			! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else						! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 else							! Right nbor less refined than me"
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	do idim = 1,ndim"
  write(ilun,format)"	   do i=1,ngrid			! Gather main characteristics of left neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    select case (nbor_ilevel(i,2*idim-1))"
  write(ilun,format)"                    case (1)"
  write(ilun,format)"                       Er_g (i,idim,igrp) = max(uold(cell_left(i,idim),firstindex_er+igrp)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                       dx_g (i,idim) = dx_loc"
  write(ilun,format)"                    case (0)"
  write(ilun,format)"                       Er_g (i,idim,igrp) = unew(cell_left(i,idim),firstindex_er+igrp)"
  write(ilun,format)"!!                        Er_g (i,idim,igrp) = urad(cell_left(i,idim),igrp)"
  write(ilun,format)"                       dx_g (i,idim) = dx_loc"
  write(ilun,format)"                    case (-1)"
  write(ilun,format)"                       Er_g (i,idim,igrp) = max(uold(cell_left(i,idim),firstindex_er+igrp)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                       dx_g (i,idim) = 1.5d0*dx_loc"
  write(ilun,format)"                    end select"
  write(ilun,format)"                    "
  write(ilun,format)"                    select case (nbor_ilevel(i,2*idim))"
  write(ilun,format)"                    case (1)"
  write(ilun,format)"                       Er_d (i,idim,igrp) = max(uold(cell_right(i,idim),firstindex_er+igrp)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                       dx_d (i,idim) = dx_loc"
  write(ilun,format)"                    case (0)"
  write(ilun,format)"                       Er_d (i,idim,igrp) = unew(cell_right(i,idim),firstindex_er+igrp)"
  write(ilun,format)"!!                        Er_d (i,idim,igrp) = urad(cell_right(i,idim),igrp)"
  write(ilun,format)"                       dx_d (i,idim) = dx_loc"
  write(ilun,format)"                    case (-1)"
  write(ilun,format)"                       "
  write(ilun,format)"                       Er_d (i,idim,igrp) = max(uold(cell_right(i,idim),firstindex_er+igrp)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                       dx_g (i,idim) = 1.5d0*dx_loc"
  write(ilun,format)"                    end select"
  write(ilun,format)"                 end do"
  write(ilun,format)"              "
  write(ilun,format)"                 vel_g(i,idim,1:ndim)=uold(cell_left(i,idim),2:ndim+1)/uold(cell_left(i,idim),1)"
  write(ilun,format)"                 vel_d(i,idim,1:ndim)=uold(cell_right(i,idim),2:ndim+1)/uold(cell_right(i,idim),1)"
  write(ilun,format)"              end if"
  write(ilun,format)"              end do"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"              phi_c(i) = enew(ind_cell(i))"
  write(ilun,format)"              nu_c (i) = divu(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)"              !compute divu"
  write(ilun,format)"              do j=1,ndim"
  write(ilun,format)"                 do k=1,ndim"
  write(ilun,format)"                    divu_loc(j,k) = (vel_d(i,j,k)-vel_g(i,j,k))/(dx_g(i,j)+dx_d(i,j))"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    gradEr(j,igrp) = (Er_d(i,j,igrp)-Er_g(i,j,igrp))/(dx_g(i,j)+dx_d(i,j))"
  write(ilun,format)"                 enddo"
  write(ilun,format)"              enddo"
  write(ilun,format)""
  write(ilun,format)"              do igrp=1,ngrp"
  write(ilun,format)"                 Tp_loc = unew(ind_cell(i),5)"
  write(ilun,format)"                 d_loc  = uold(ind_cell(i),1)*scale_d"
  write(ilun,format)""
  write(ilun,format)"                 gradEr_norm2 = (sum(gradEr(1:ndim,igrp)**2))"
  write(ilun,format)"                 gradEr_norm  = (gradEr_norm2)**0.5"
  write(ilun,format)"                 kappa_R=rosseland_ana(d_loc,Tp_loc,Tp_loc,igrp)/scale_kappa"
  write(ilun,format)"                 R =  gradEr_norm/(unew(ind_cell(i),firstindex_er+igrp)*kappa_R)"
  write(ilun,format)"!!                  R =  gradEr_norm/(urad(ind_cell(i),igrp)*kappa_R)"
  write(ilun,format)"                 lambda = lambda_fld(R)"
  write(ilun,format)"                 chi = lambda + (lambda*R)**2"
  write(ilun,format)"                 "
  write(ilun,format)"                 do j=1,ndim"
  write(ilun,format)"                    do k=1,ndim"
  write(ilun,format)"                       Pg(j,k,igrp)=0.0d0"
  write(ilun,format)"                       if(j .eq. k) Pg(j,k,igrp) = (1.0d0-chi)/2.0d0"
  write(ilun,format)"                       if(R .gt. 1.d-8)Pg(j,k,igrp) = Pg(j,k,igrp) &"
  write(ilun,format)"                            & + (3.0d0*chi-1.0d0)/2.0d0*gradEr(j,igrp)*gradEr(k,igrp)/gradEr_norm2"
  write(ilun,format)"                    enddo"
  write(ilun,format)"                 enddo"
  write(ilun,format)"                 Pg(1:ndim,1:ndim,igrp)=Pg(1:ndim,1:ndim,igrp)*unew(ind_cell(i),firstindex_er+igrp)"
  write(ilun,format)"!!                  Pg(1:ndim,1:ndim,igrp)=Pg(1:ndim,1:ndim,igrp)*urad(ind_cell(i),igrp)"
  write(ilun,format)"                 "
  write(ilun,format)"              end do"
  write(ilun,format)"                 "
  write(ilun,format)"              Pgdivu     = 0.0d0"
  write(ilun,format)"              nuPrDivu   = 0.0d0 ! multig: this is the Doppler shift term"
  write(ilun,format)"              "
  write(ilun,format)"              do j=1,ndim"
  write(ilun,format)"                 do k=1,ndim"
  write(ilun,format)"                    "
  write(ilun,format)"                    ! compure Pr:divU term"
  write(ilun,format)"                    Pgdivu    = Pgdivu    + Pg(j,k,igroup)*divu_loc(j,k)"
  write(ilun,format)""
  write(ilun,format)"                    ! fill in Pr_temp array for Doppler shift terms"
  write(ilun,format)"                    Pr_temp(3) = Pg(j,k,igroup)"
  write(ilun,format)"                    if(igroup >    1  )then"
  write(ilun,format)"                       Pr_temp(2) = Pg(j,k,igroup-1)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       Pr_temp(2) = Pg(j,k,igroup)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    if(igroup >    2  )then"
  write(ilun,format)"                       Pr_temp(1) = Pg(j,k,igroup-2)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       Pr_temp(1) = Pr_temp(2)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    if(igroup < ngrp  )then"
  write(ilun,format)"                       Pr_temp(4) = Pg(j,k,igroup+1)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       Pr_temp(4) = Pg(j,k,igroup)"
  write(ilun,format)"                    endif"
  write(ilun,format)"                    if(igroup < ngrp-1)then"
  write(ilun,format)"                       Pr_temp(5) = Pg(j,k,igroup+2)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       Pr_temp(5) = Pr_temp(4)"
  write(ilun,format)"                    endif"
  write(ilun,format)""
  write(ilun,format)"                    ! compute -[nu P]*Div(u) term"
  write(ilun,format)"                    if(divu_loc(j,k) > 0.0d0)then"
  write(ilun,format)""
  write(ilun,format)"                       if(igroup == ngrp)then"
  write(ilun,format)"                          nuPr = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPr = nu_max_hz(igroup)*Pr_nu(Pr_temp,igroup+1,4,nu_max_hz(igroup))"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(igroup == 1)then"
  write(ilun,format)"                          nuPl = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPl = nu_min_hz(igroup)*Pr_nu(Pr_temp,igroup,3,nu_min_hz(igroup))"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    else"
  write(ilun,format)""
  write(ilun,format)"                       if(igroup == ngrp)then"
  write(ilun,format)"                          nuPr = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPr = nu_max_hz(igroup)*Pr_nu(Pr_temp,igroup,3,nu_max_hz(igroup))"
  write(ilun,format)"                       endif"
  write(ilun,format)"                       if(igroup == 1)then"
  write(ilun,format)"                          nuPl = 0.0d0"
  write(ilun,format)"                       else"
  write(ilun,format)"                          nuPl = nu_min_hz(igroup)*Pr_nu(Pr_temp,igroup-1,2,nu_min_hz(igroup))"
  write(ilun,format)"                       endif"
  write(ilun,format)""
  write(ilun,format)"                    endif"
  write(ilun,format)""
  write(ilun,format)"                    nuPrDivu = nuPrDivu - (nuPr - nuPl)*divu_loc(j,k)"
  write(ilun,format)""
  write(ilun,format)"                 enddo"
  write(ilun,format)"              end do"
  write(ilun,format)"              unew(ind_cell(i),nvar+2) = 0.0d0!(Pgdivu+nuPrDivu)/urad(ind_cell(i),igroup)"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do	  ! ncache"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_Prdivu"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine cmp_matrix_coeff(ilevel,igroup)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the matrix A to vect_in and create vect_out"
  write(ilun,format)"  ! compute = 1 : residu           	return B - Ax"
  write(ilun,format)"  ! compute = 2 : Produit                 return  A.p"
  write(ilun,format)"  ! compute = 3 : Preconditionner         return diag(A)"
  write(ilun,format)"  ! compute = 4 : Compute flux in rad_flux"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::ilevel,igroup"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: residu,C_g,C_d,nu_g,nu_c,nu_d"
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: phi_g,phi_c,phi_d,val_g,val_d"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  integer :: i,idim,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: radiation_source,deriv_radiation_source,rhs,lhs"
  write(ilun,format)"  real(dp):: dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp):: nu_surf,Cv,rho,wdt,wdt_igrp,Told,lambda,lambda_fld,R"
  write(ilun,format)"  real(dp):: cmp_temp,rosseland_ana,planck_ana,Prdivu"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! residu = I"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"              "
  write(ilun,format)"              rho  = uold(ind_cell(i),1)"
  write(ilun,format)"              Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"              Told = unew(ind_cell(i),5)"
  write(ilun,format)"              "
  write(ilun,format)"              lhs=0.0d0"
  write(ilun,format)"              do igrp=1,ngrp"
  write(ilun,format)"                 wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"                 lhs=lhs+P_cal*wdt*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"              enddo"
  write(ilun,format)"              "
  write(ilun,format)"              wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"              Prdivu = 0.0d0!unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"              mat_residual_glob(ind_cell(i),igroup,igroup) =  (1.0d0+Prdivu+wdt*(1.0d0-deriv_radiation_source(Told,igroup)*P_cal*wdt/scale_E0/(cv+lhs))) *vol_loc"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1               !direction of left nbor grid"
  write(ilun,format)"	      supD = 0              		!direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"           else"
  write(ilun,format)"              supG = 0              		!direction of left nbor grid"
  write(ilun,format)"	      supD = (idim-1)*2+2   		!direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"           end if"
  write(ilun,format)"    "
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor indice offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then			! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else						! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then			! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else						! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)" end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"!!            do i=1,ngrid"
  write(ilun,format)"!!               if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"!!                  "
  write(ilun,format)"!!                  val_g	(i)       = enew(cell_left (i,idim))"
  write(ilun,format)"!!                  val_d	(i)       = enew(cell_right(i,idim))"
  write(ilun,format)"!! "
  write(ilun,format)"!!               end if"
  write(ilun,format)"!!            end do"
  write(ilun,format)"              "
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid			! Gather main characteristics of left neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim-1))"
  write(ilun,format)""
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_g (i)       = max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"!!                     if (compute==2)		  val_g	(i)       = 0.0d0"
  write(ilun,format)"!!                     if (compute/=2)		  val_g	(i)       = phi_g(i)!uold(cell_left(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)"                    nu_g	(i)       = divu(ind_cell(i))"
  write(ilun,format)"                    if (robin > 0.0d0)		C_g	(i)       = 1.0d0/robin"
  write(ilun,format)"                    if (robin == 0.0d0)		  C_g	(i)       = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"                    Told      	= cmp_temp(cell_left(i,idim))"
  write(ilun,format)"                    rho      	= scale_d * max(uold(cell_left(i,idim),1),smallr)"
  write(ilun,format)"                    nu_g  (i)	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_g(i)*dx_loc .lt. min_optical_depth) nu_g(i)=min_optical_depth/dx_loc"
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i)       = enew(cell_left(i,idim))"
  write(ilun,format)"!!                     val_g	(i)       = val_g (i)"
  write(ilun,format)"                    nu_g	(i)       = divu(cell_left(i,idim))"
  write(ilun,format)"                    C_g	(i)       = 1.0d0"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i) 	= max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    Told      	= cmp_temp(cell_left(i,idim))"
  write(ilun,format)"                    rho      	= scale_d * max(uold(cell_left(i,idim),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"!!                     if (compute==2)		  val_g (i) 	= 0.0d0"
  write(ilun,format)"!!                     if (compute/=2) 	  val_g (i)     = phi_g(i)"
  write(ilun,format)"                    nu_g  (i)	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_g(i)*2.0d0*dx_loc .lt. min_optical_depth) nu_g(i)=min_optical_depth/(2.0d0*dx_loc)         "
  write(ilun,format)"                    C_g	(i) 	= 1.5d0"
  write(ilun,format)""
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid				! Gather main characteristics of right neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim))"
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_d (i)       = max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"!!                     if (compute==2)		  val_d	(i)       = 0.0d0"
  write(ilun,format)"!!                     if (compute/=2)		  val_d	(i)       = phi_d(i)!uold(cell_right(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)"                    nu_d	(i)       = divu(ind_cell(i))"
  write(ilun,format)"                    if (robin > 0.0d0)		C_d	(i)       = 1.0d0/robin"
  write(ilun,format)"                    if (robin == 0.0d0)		  C_d	(i)       = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"                    Told 		= cmp_temp(cell_right(i,idim))"
  write(ilun,format)"                    rho 		= scale_d * max(uold(cell_right(i,idim),1),smallr)"
  write(ilun,format)"                    nu_d  (i) 	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    if(nu_d(i)*1.0d0*dx_loc .lt. min_optical_depth) nu_d(i)=min_optical_depth/(1.0d0*dx_loc)"
  write(ilun,format)""
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)       = enew(cell_right(i,idim))"
  write(ilun,format)"!!                     val_d	(i)       = val_d (i)"
  write(ilun,format)"                    nu_d  (i)       = divu(cell_right(i,idim))"
  write(ilun,format)"                    C_d   (i)       = 1.0d0"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)	= max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    Told 		= cmp_temp(cell_right(i,idim))"
  write(ilun,format)"                    rho 		= scale_d * max(uold(cell_right(i,idim),1),smallr)"
  write(ilun,format)""
  write(ilun,format)"!!                     if (compute==2)		  val_d (i) 	= 0.0d0"
  write(ilun,format)"!!                     if (compute/=2)		  val_d (i)     = phi_d(i)"
  write(ilun,format)"                    nu_d  (i) 	= rosseland_ana(rho,Told,Told,igroup) / scale_kappa"
  write(ilun,format)"                    C_d   (i)	= 1.5d0"
  write(ilun,format)"                    if(nu_d(i)*2.0d0*dx_loc .lt. min_optical_depth) nu_d(i)=min_optical_depth/(2.0d0*dx_loc)"
  write(ilun,format)"           "
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then ! getting nu_surface"
  write(ilun,format)"                 nu_c (i) = divu(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)"                 C_g(i)           = C_g(i) * nu_surf(nu_g(i),nu_c(i), cell_left(i,idim) ,ind_cell(i),dx_loc)"
  write(ilun,format)"                 C_d(i)           = C_d(i) * nu_surf(nu_d(i),nu_c(i), cell_right(i,idim),ind_cell(i),dx_loc)"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 phi_c(i) = enew(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)"                 coeff_glob_left(ind_cell(i),igroup,igroup,idim)=0.0d0"
  write(ilun,format)"                 if(C_g(i) > 0.0d0)then"
  write(ilun,format)""
  write(ilun,format)"                    R = max(1.0d-10,abs (phi_c(i)-phi_g(i)) /(0.5d0*(phi_c(i)+phi_g(i))))"
  write(ilun,format)"                    R = R / ( C_g(i) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"                    lambda=lambda_fld(R)"
  write(ilun,format)"                    C_g(i) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_g(i))"
  write(ilun,format)""
  write(ilun,format)"                    coeff_glob_left(ind_cell(i),igroup,igroup,idim)=C_g(i)"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"                 coeff_glob_right(ind_cell(i),igroup,igroup,idim)=0.0d0"
  write(ilun,format)"                 if(C_d(i) > 0.0d0)then"
  write(ilun,format)""
  write(ilun,format)"                    R = max(1.0d-10,abs (phi_c(i)-phi_d(i)) /(0.5d0*(phi_c(i)+phi_d(i))))"
  write(ilun,format)"                    R = R / ( C_d(i) * dx_loc )"
  write(ilun,format)""
  write(ilun,format)"                    lambda=lambda_fld(R)"
  write(ilun,format)"                    C_d(i) = C_cal*lambda *dt_imp*surf_loc/(dx_loc*C_d(i))"
  write(ilun,format)"                    coeff_glob_right(ind_cell(i),igroup,igroup,idim)=C_d(i)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"       end do !ndim"
  write(ilun,format)" "
  write(ilun,format)""
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do	  ! ncache"
  write(ilun,format)"end subroutine cmp_matrix_coeff"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine cmp_matrixA2 (ilevel,compute,igroup)"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the matrix A to vect_in and create vect_out"
  write(ilun,format)"  ! compute = 1 : residu           	return B - Ax"
  write(ilun,format)"  ! compute = 2 : Produit                 return  A.p"
  write(ilun,format)"  ! compute = 3 : Preconditionner         return diag(A)"
  write(ilun,format)"  ! compute = 4 : Compute flux in rad_flux"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  integer,intent(IN)::compute,ilevel,igroup"
  write(ilun,format)""
  write(ilun,format)"  integer , dimension(1:nvector,1:2*ndim),save:: nbor_ilevel"
  write(ilun,format)"  integer , dimension(1:nvector,1:ndim),save::   cell_left , cell_right , big_left, big_right"
  write(ilun,format)"  integer ,dimension(1:nvector,0:2*ndim),save::  igridn"
  write(ilun,format)"  integer ,dimension(1:nvector),save ::          ind_cell , ind_grid"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: residu,C_g,C_d,nu_g,nu_c,nu_d"
  write(ilun,format)"  real(dp),dimension(1:nvector),save:: phi_g,phi_c,phi_d,val_g,val_d"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  integer :: i,idim,ind,igrid,ngrid,ncache,iskip,igrp,nx_loc"
  write(ilun,format)"  integer :: supG,sub,supD"
  write(ilun,format)""
  write(ilun,format)"  real(dp):: radiation_source,deriv_radiation_source,rhs,lhs"
  write(ilun,format)"  real(dp):: dx,dx_loc,surf_loc,vol_loc,scale"
  write(ilun,format)"  real(dp):: nu_surf,Cv,rho,wdt,wdt_igrp,Told,lambda,lambda_fld,R"
  write(ilun,format)"  real(dp):: cmp_temp,rosseland_ana,planck_ana,Prdivu"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Rescaling factors"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  surf_loc = dx_loc**(ndim-1)"
  write(ilun,format)"  vol_loc  = dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! **************************** LOOP OVER CELLS ********************************** !"
  write(ilun,format)""
  write(ilun,format)"  residu = 0.0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over myid grids by vector sweeps"
  write(ilun,format)"  ncache = active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Gather nvector grids"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i) = active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        igridn(i,0) = ind_grid(i)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     do idim=1,ndim"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           big_left (i,idim)  = nbor(ind_grid(i),2*idim-1)"
  write(ilun,format)"           big_right(i,idim)  = nbor(ind_grid(i),2*idim  )"
  write(ilun,format)"           igridn(i,2*idim-1) = son(big_left (i,idim))"
  write(ilun,format)"           igridn(i,2*idim  ) = son(big_right(i,idim))"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        select case (compute)"
  write(ilun,format)""
  write(ilun,format)"        case (1)"
  write(ilun,format)"           ! residu = b - Ax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 rho   = uold (ind_cell(i),1)"
  write(ilun,format)"                 Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"                 Prdivu = 0.0d0!unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"                 Told  =  unew(ind_cell(i),5)"
  write(ilun,format)""
  write(ilun,format)"                 rhs=0.0d0"
  write(ilun,format)"                 lhs=0.0d0"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"                    rhs=rhs-P_cal*wdt*(radiation_source(Told,igrp)/scale_E0-Told*deriv_radiation_source(Told,igrp)/scale_E0)"
  write(ilun,format)"                    lhs=lhs+P_cal*wdt*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igroup)/scale_kappa"
  write(ilun,format)"                 residu(i) = uold(ind_cell(i),firstindex_er+igroup)*vol_loc  &"
  write(ilun,format)"                      & + vol_loc*wdt*(radiation_source(Told,igroup)/scale_E0-Told*deriv_radiation_source(Told,igroup)/scale_E0) &"
  write(ilun,format)"                      & + vol_loc*wdt*deriv_radiation_source(Told,igroup)/scale_E0*(cv*unew(ind_cell(i),nvar+3)+rhs)/(cv+lhs)"
  write(ilun,format)""
  write(ilun,format)"                 ! Terms of coupling radiative groups"
  write(ilun,format)"                 do igrp=1,ngrp"
  write(ilun,format)"                    if(igrp .ne. igroup) then"
  write(ilun,format)"                       wdt_igrp = C_cal*dt_imp*planck_ana(rho*scale_d,Told,Told,igrp)/scale_kappa"
  write(ilun,format)"                       residu(i) = residu(i) + vol_loc*wdt*deriv_radiation_source(Told,igroup)/scale_E0/(cv+lhs) * P_cal*wdt_igrp*unew(ind_cell(i),firstindex_er+igrp)"
  write(ilun,format)"!!                        residu(i) = residu(i) + vol_loc*wdt*deriv_radiation_source(Told,igroup)/scale_E0/(cv+lhs) * P_cal*wdt_igrp*urad(ind_cell(i),igrp)"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 enddo"
  write(ilun,format)""
  write(ilun,format)"                 residu(i) = residu(i) &"
  write(ilun,format)"                      &       - (1.0d0+Prdivu+wdt*(1.0d0-deriv_radiation_source(Told,igroup)*P_cal*wdt/scale_E0/(cv+lhs))) *unew(ind_cell(i),firstindex_er+igroup) *vol_loc"
  write(ilun,format)""
  write(ilun,format)"                 !compute b"
  write(ilun,format)"                 residu(i) = residu(i)+(1.0d0-robin)*rad_flux(ind_cell(i),igroup)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        case (2)"
  write(ilun,format)"           ! residu = Ix"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"!!                  rho  = uold(ind_cell(i),1)"
  write(ilun,format)"!!                  Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"!!                  Told = unew(ind_cell(i),5)"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  lhs=0.0d0"
  write(ilun,format)"!!                  do igrp=1,ngrp"
  write(ilun,format)"!!                     wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,igrp)/scale_kappa"
  write(ilun,format)"!!                     lhs=lhs+P_cal*wdt*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"!!                  enddo"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,igroup)/scale_kappa"
  write(ilun,format)"!!                  Prdivu = 0.0d0 !unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"                 residu(i) =  mat_residual_glob(ind_Cell(i),igroup,igroup)*unew(ind_cell(i),2)!(1.0d0+Prdivu+wdt*(1.0d0-deriv_radiation_source(Told,igroup)*P_cal*wdt/scale_E0/(cv+lhs))) *unew(ind_cell(i),2) *vol_loc"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (3)"
  write(ilun,format)"           ! residu = I"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  rho  = uold(ind_cell(i),1)"
  write(ilun,format)"!!                  Cv = unew(ind_cell(i),nvar+1)"
  write(ilun,format)"!!                  Told = unew(ind_cell(i),5)"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  lhs=0.0d0"
  write(ilun,format)"!!                  do igrp=1,ngrp"
  write(ilun,format)"!!                     wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,igrp)/scale_kappa"
  write(ilun,format)"!!                     lhs=lhs+P_cal*wdt*deriv_radiation_source(Told,igrp)/scale_E0"
  write(ilun,format)"!!                  enddo"
  write(ilun,format)"!! "
  write(ilun,format)"!!                  wdt = C_cal*dt_imp*planck_ana(rho*scale_d,Told,igroup)/scale_kappa"
  write(ilun,format)"!!                  Prdivu = unew(ind_cell(i),nvar+2)*dt_imp"
  write(ilun,format)"!!                  residu(i) =  (1.0d0+Prdivu+wdt*(1.0d0-deriv_radiation_source(Told,igroup)*P_cal*wdt/scale_E0/(cv+lhs))) *vol_loc"
  write(ilun,format)"                 residu(i) =  mat_residual_glob(ind_Cell(i),igroup,igroup)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"        case (4)"
  write(ilun,format)"           ! reinitialize rad_flux for this level"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 rad_flux(ind_cell(i),igroup) = 0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end select"
  write(ilun,format)"        "
  write(ilun,format)"        ! Determine the two2ndim and the direction of the grid of neighboors (-1,0,1)"
  write(ilun,format)"        do idim = 1,ndim"
  write(ilun,format)"           if (modulo((ind-1)/2**(idim-1),2)==0)then"
  write(ilun,format)"              supG = (idim-1)*2+1               !direction of left nbor grid"
  write(ilun,format)"	      supD = 0              		!direction of right nbor grid"
  write(ilun,format)"              sub = ind + 2**(idim-1)           ! position of nbor in its own grid"
  write(ilun,format)"	   else"
  write(ilun,format)" 	      supG = 0              		!direction of left nbor grid"
  write(ilun,format)"	      supD = (idim-1)*2+2   		!direction of right nbor grid"
  write(ilun,format)"              sub = ind - 2**(idim-1)           !position of nbor in its own grid"
  write(ilun,format)"	   end if"
  write(ilun,format)""
  write(ilun,format)"           sub = ncoarse + (sub-1)*ngridmax     !nbor indice offset from its own grid"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)""
  write(ilun,format)"       ! Getting neighboors relative level (-1,0,1)"
  write(ilun,format)""
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supG)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_left(i,idim) = igridn(i,supG)+ sub"
  write(ilun,format)"                    if(son(cell_left(i,idim))>0)then			! Left nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 1"
  write(ilun,format)"                    else						! Left nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim-1) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Left nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim-1) = -1"
  write(ilun,format)"                    cell_left(i,idim)    = big_left(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 if(igridn(i,supD)>0)then"
  write(ilun,format)""
  write(ilun,format)"                    cell_right(i,idim) = igridn(i,supD)+ sub"
  write(ilun,format)"                    if(son(cell_right(i,idim))>0)then			! Right nbor more refined than me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 1"
  write(ilun,format)"                    else						! Right nbor as refined as me"
  write(ilun,format)"                       nbor_ilevel(i,2*idim) = 0"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 else							! Right nbor less refined than me"
  write(ilun,format)""
  write(ilun,format)"                    nbor_ilevel(i,2*idim) = -1"
  write(ilun,format)"                    cell_right(i,idim) = big_right(i,idim)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"	end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	do idim = 1,ndim"
  write(ilun,format)""
  write(ilun,format)"           select case (compute)! Getting val_g and val_d"
  write(ilun,format)"	   case(1)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = enew(cell_left (i,idim))"
  write(ilun,format)"                    val_d	(i)       = enew(cell_right(i,idim))"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case(2)"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = unew(cell_left (i,idim),2)"
  write(ilun,format)"                    val_d	(i)       = unew(cell_right(i,idim),2)	"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case(4)"
  write(ilun,format)""
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"                    val_g	(i)       = unew(cell_left (i,idim),firstindex_er+igroup)"
  write(ilun,format)"                    val_d	(i)       = unew(cell_right(i,idim),firstindex_er+igroup)"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"           end select"
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid			! Gather main characteristics of left neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim-1))"
  write(ilun,format)""
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_g (i)       = max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_g	(i)       = 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_g	(i)       = phi_g(i)!uold(cell_left(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)""
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i)       = enew(cell_left(i,idim))"
  write(ilun,format)"                    val_g	(i)       = val_g (i)"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_g (i) 	= max(uold(cell_left(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_g (i) 	= 0.0d0"
  write(ilun,format)"                    if (compute/=2) 	  val_g (i)     = phi_g(i)"
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   do i=1,ngrid				! Gather main characteristics of right neighboor"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)""
  write(ilun,format)"                 select case (nbor_ilevel(i,2*idim))"
  write(ilun,format)"                 case (1)"
  write(ilun,format)"                    phi_d (i)       = max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_d	(i)       = 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_d	(i)       = phi_d(i)!uold(cell_right(i,idim),firstindex_er+igroup) / P_cal"
  write(ilun,format)"         "
  write(ilun,format)"                 case (0)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)       = enew(cell_right(i,idim))"
  write(ilun,format)"                    val_d	(i)       = val_d (i)"
  write(ilun,format)""
  write(ilun,format)"                 case (-1)"
  write(ilun,format)""
  write(ilun,format)"                    phi_d (i)	= max(uold(cell_right(i,idim),firstindex_er+igroup)/P_cal,eray_min/scale_E0)"
  write(ilun,format)"                    if (compute==2)		  val_d (i) 	= 0.0d0"
  write(ilun,format)"                    if (compute/=2)		  val_d (i)     = phi_d(i)"
  write(ilun,format)""
  write(ilun,format)"                 end select"
  write(ilun,format)"              end if"
  write(ilun,format)"	   end do"
  write(ilun,format)""
  write(ilun,format)"           if (compute ==4)then		! Computing and saving flux to the coarser ilevel"
  write(ilun,format)""
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0)then"
  write(ilun,format)""
  write(ilun,format)"                    phi_c(i) = enew(ind_cell(i))"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim-1) == -1)then"
  write(ilun,format)""
  write(ilun,format)"                       rad_flux(cell_left(i,idim),igroup)  = rad_flux(cell_left(i,idim),igroup)  + &"
  write(ilun,format)"                            & coeff_glob_left(ind_cell(i),igroup,igroup,idim)*( alpha_imp * (unew(ind_cell(i),firstindex_er+igroup) - val_g(i)) + (1.0d0-alpha_imp)*(phi_c(i) - phi_g(i))) "
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                    if( nbor_ilevel(i,2*idim)   == -1 )then"
  write(ilun,format)""
  write(ilun,format)"                       rad_flux(cell_right(i,idim),igroup) = rad_flux(cell_right(i,idim),igroup) + &"
  write(ilun,format)"                            & coeff_glob_right(ind_cell(i),igroup,igroup,idim)*( alpha_imp * (unew(ind_cell(i),firstindex_er+igroup) - val_d(i)) + (1.0d0-alpha_imp)*(phi_c(i) - phi_d(i)))"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	   select case (compute)"
  write(ilun,format)""
  write(ilun,format)"	   case (1)		 ! compute b-Ax from b-Ix by adding intern flux"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) &"
  write(ilun,format)"                         & - ((coeff_glob_left(ind_cell(i),igroup,igroup,idim)+coeff_glob_right(ind_cell(i),igroup,igroup,idim))* enew(ind_cell(i)) &"
  write(ilun,format)"                         & - coeff_glob_left(ind_cell(i),igroup,igroup,idim)*val_g(i) &"
  write(ilun,format)"                         & - coeff_glob_right(ind_cell(i),igroup,igroup,idim)*val_d(i))"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case (2)		! compute Ap from Ip by adding intern flux"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) &"
  write(ilun,format)"                         & + ((coeff_glob_left(ind_cell(i),igroup,igroup,idim)+coeff_glob_right(ind_cell(i),igroup,igroup,idim))*unew(ind_cell(i),2) &"
  write(ilun,format)"                         & - coeff_glob_left(ind_cell(i),igroup,igroup,idim)*val_g(i) &"
  write(ilun,format)"                         & - coeff_glob_right(ind_cell(i),igroup,igroup,idim)*val_d(i))*alpha_imp"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   case (3)		! compute Diag(A) for preconditionner"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                    residu(i) = residu(i) &"
  write(ilun,format)"                         & + (coeff_glob_left(ind_cell(i),igroup,igroup,idim)+coeff_glob_right(ind_cell(i),igroup,igroup,idim))*alpha_imp"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"	   end select"
  write(ilun,format)""
  write(ilun,format)"	end do !ndim"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"	select case (compute)"
  write(ilun,format)"    ! get the result out"
  write(ilun,format)""
  write(ilun,format)"	case (1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),1) = residu(i)"
  write(ilun,format)"                 unew(ind_cell(i),2) = residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	case (2)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),3) = residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	case (3)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(son(ind_cell(i)) == 0 )then"
  write(ilun,format)"                 unew(ind_cell(i),4) = 1.0d0/residu(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"	end select"
  write(ilun,format)""
  write(ilun,format)"     end do ! twotodim"
  write(ilun,format)"  end do	  ! ncache"
  write(ilun,format)""
  write(ilun,format)"end subroutine cmp_matrixA2"
  write(ilun,format)"../patch/irradiation/test_pascucci/read_hydro_params.f90"
  write(ilun,format)"subroutine read_hydro_params(nml_ok)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use cooling_module,ONLY:kB,mH,clight"
  write(ilun,format)"  use const"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"  use mod_opacities"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  use variables_X,ONLY:nvarchimie,nchimie,tchimie,&"
  write(ilun,format)"      &nminchimie,tminchimie,dnchimie,dtchimie,&"
  write(ilun,format)"      &xichimie,ximinchimie,dxichimie,&"
  write(ilun,format)"      nislin,tislin,xiislin"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical::nml_ok"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Local variables  "
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  integer::i,j,idim,irad,nboundary_true=0,ht"
  write(ilun,format)"  integer ,dimension(1:MAXBOUND)::bound_type"
  write(ilun,format)"  real(dp)::ek_bound,em_bound,er_bound"
  write(ilun,format)"  real(dp)::radiation_source"
  write(ilun,format)"  character(len=2):: rad_trans_model='m1'"
  write(ilun,format)""
  write(ilun,format)"  integer::ii,jj,kk,ee,hh,gg,ie,ir,k,it"
  write(ilun,format)"  real(dp)::dummy,compute_db,d0"
  write(ilun,format)"  real(dp)::xx,yy,vv,ww,zz"
  write(ilun,format)"  real(dp)::dtemp1,Temp_new2,epsilon_n,eint_old,T0,temp_new,d_loc,eint_new,pi"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Namelist definitions"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  namelist/init_params/filetype,initfile,multiple,nregion,region_type &"
  write(ilun,format)"       & ,x_center,y_center,z_center,aexp_ini &"
  write(ilun,format)"       & ,length_x,length_y,length_z,exp_region &"
  write(ilun,format)"       & ,d_region,u_region,v_region,w_region,p_region &"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"       & ,prad_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"       & ,E_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>8+NENER"
  write(ilun,format)"       & ,var_region &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,A_region,B_region,C_region &"
  write(ilun,format)"       & ,alpha_dense_core,beta_dense_core,crit,delta_rho,mass_c,rap,cont &"
  write(ilun,format)"       & ,ff_sct,ff_rt,ff_act,ff_vct,theta_mag,bb_test &"
  write(ilun,format)"       & ,contrast,Mach,uniform_bmag"
  write(ilun,format)"  namelist/hydro_params/gamma,courant_factor,smallr,smallc &"
  write(ilun,format)"       & ,niter_riemann,slope_type,slope_mag_type,switch_solv,switch_solv_dens &"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"       & ,gamma_rad &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,pressure_fix,beta_fix,scheme,riemann,riemann2d &"
  write(ilun,format)"       & ,positivity_type"
  write(ilun,format)"  namelist/refine_params/x_refine,y_refine,z_refine,r_refine &"
  write(ilun,format)"       & ,a_refine,b_refine,exp_refine,jeans_refine,mass_cut_refine &"
  write(ilun,format)"       & ,iso_jeans,Tp_jeans &"
  write(ilun,format)"       & ,m_refine,mass_sph,err_grad_d,err_grad_p,err_grad_u &"
  write(ilun,format)"       & ,err_grad_A,err_grad_B,err_grad_C,err_grad_B2,err_grad_E &"
  write(ilun,format)"       & ,floor_d,floor_u,floor_p,ivar_refine,var_cut_refine &"
  write(ilun,format)"       & ,floor_A,floor_B,floor_C,floor_B2,floor_E &"
  write(ilun,format)"       & ,interpol_var,interpol_type,sink_refine,interpol_mag_type"
  write(ilun,format)"  namelist/boundary_params/nboundary,bound_type &"
  write(ilun,format)"       & ,ibound_min,ibound_max,jbound_min,jbound_max &"
  write(ilun,format)"       & ,kbound_min,kbound_max &"
  write(ilun,format)"       & ,d_bound,u_bound,v_bound,w_bound,p_bound &"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"       & ,prad_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"       & ,E_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NVAR>8+NENER"
  write(ilun,format)"       & ,var_bound &"
  write(ilun,format)"#endif"
  write(ilun,format)"       & ,A_bound,B_bound,C_bound,T_bound ,no_inflow"
  write(ilun,format)"  namelist/physics_params/cooling,haardt_madau,metal,isothermal,barotrop,eos &"
  write(ilun,format)"       & ,m_star,t_star,n_star,T2_star,g_star,del_star,eps_star,jeans_ncells &"
  write(ilun,format)"       & ,eta_sn,yield,rbubble,f_ek,ndebris,f_w,mass_gmc,kappa_IR &"
  write(ilun,format)"       & ,J21,a_spec,z_ave,z_reion,eta_mag,delayed_cooling,T2max &"
  write(ilun,format)"       & ,self_shielding,smbh,agn,B_ave,t_diss &"
  write(ilun,format)"!       & ,rsink_max,msink_max,merge_stars &"
  write(ilun,format)"       & ,units_density,units_time,units_length,neq_chem,ir_feedback,ir_eff &"
  write(ilun,format)"       & ,larson_lifetime,flux_accretion,t_diss &"
  write(ilun,format)"       & ,mu_gas,analytical_barotrop"
  write(ilun,format)"  namelist/radiation_params/grey_rad_transfer,dtdiff_params,dt_control &"
  write(ilun,format)"       & ,rosseland_params,planck_params,epsilon_diff,fld_limiter &"
  write(ilun,format)"       & ,freqs_in_Hz,read_groups,split_groups_log,extra_end_group  &"
  write(ilun,format)"       & ,numin,numax,Tr_floor,robin,rad_trans_model,min_optical_depth,rt_feedback &"
  write(ilun,format)"       & ,PMS_evol,Hosokawa_track,energy_fix,facc_star,facc_star_lum,valp_min,store_matrix,external_radiation_field &"
  write(ilun,format)"       & ,opacity_type,rad_trans_model,min_optical_depth &"
  write(ilun,format)"       & ,rt_feedback,PMS_evol,Hosokawa_track,energy_fix &"
  write(ilun,format)"       & ,facc_star,facc_star_lum,store_matrix &"
  write(ilun,format)"       & ,external_radiation_field,stellar_photon &"
  write(ilun,format)"       & ,Tstar,rstar,test &"
  write(ilun,format)"       & ,rho_disk0, Rin, rt_protostar_fld, isoscat"
  write(ilun,format)""
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  namelist/nonidealmhd_params/nambipolar,gammaAD &"
  write(ilun,format)"       & ,nmagdiffu,etaMD,nhall,rHall,ntestDADM &"
  write(ilun,format)"       & ,coefad, nminitimestep, coefalfven,nmagdiffu2,nambipolar2,nu_sts,coefdtohm &"
  write(ilun,format)"       & ,rho_threshold,use_x1d,use_x2d,use_x3d,use_res,default_ionisrate"
  write(ilun,format)"  namelist/pseudovisco_params/nvisco,visco"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=init_params,END=101)"
  write(ilun,format)"  goto 102"
  write(ilun,format)"101 write(*,*)' You need to set up namelist &INIT_PARAMS in parameter file'"
  write(ilun,format)"  call clean_stop"
  write(ilun,format)"102 rewind(1)"
  write(ilun,format)"  if(nlevelmax>levelmin)read(1,NML=refine_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  if(hydro)read(1,NML=hydro_params)"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"  if(FLD)read(1,NML=radiation_params)"
  write(ilun,format)"#endif"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=boundary_params,END=103)"
  write(ilun,format)"  simple_boundary=.true."
  write(ilun,format)"  goto 104"
  write(ilun,format)"103 simple_boundary=.false."
  write(ilun,format)"104 if(nboundary>MAXBOUND)then"
  write(ilun,format)"    write(*,*) 'Error: nboundary>MAXBOUND'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=physics_params,END=105)"
  write(ilun,format)"105 continue"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units (to be done after read physics_params with units_density...)"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  if(barotrop)fld=.false."
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set ischeme"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (scheme)"
  write(ilun,format)"  CASE ('muscl')"
  write(ilun,format)"    ischeme = 0"
  write(ilun,format)"  CASE ('induction')"
  write(ilun,format)"    ischeme = 1"
  write(ilun,format)""
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown scheme'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set iriemann"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (riemann)"
  write(ilun,format)"  CASE ('llf')"
  write(ilun,format)"    iriemann = 0"
  write(ilun,format)"  CASE ('roe')"
  write(ilun,format)"    iriemann = 1"
  write(ilun,format)"  CASE ('hll')"
  write(ilun,format)"    iriemann = 2"
  write(ilun,format)"  CASE ('hlld')"
  write(ilun,format)"    iriemann = 3"
  write(ilun,format)"  CASE ('upwind')"
  write(ilun,format)"    iriemann = 4"
  write(ilun,format)"  CASE ('hydro')"
  write(ilun,format)"    iriemann = 5"
  write(ilun,format)""
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown riemann solver'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! set iriemann"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  SELECT CASE (riemann2d)"
  write(ilun,format)"  CASE ('llf')"
  write(ilun,format)"    iriemann2d = 0"
  write(ilun,format)"  CASE ('roe')"
  write(ilun,format)"    iriemann2d = 1"
  write(ilun,format)"  CASE ('upwind')"
  write(ilun,format)"    iriemann2d = 2"
  write(ilun,format)"  CASE ('hll')"
  write(ilun,format)"    iriemann2d = 3"
  write(ilun,format)"  CASE ('hlla')"
  write(ilun,format)"    iriemann2d = 4"
  write(ilun,format)"  CASE ('hlld')"
  write(ilun,format)"    iriemann2d = 5"
  write(ilun,format)"  CASE DEFAULT"
  write(ilun,format)"    write(*,*)'unknown 2D riemann solver'"
  write(ilun,format)"    call clean_stop"
  write(ilun,format)"  END SELECT"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=nonidealmhd_params,END=106)"
  write(ilun,format)"106 continue"
  write(ilun,format)"  if((nambipolar.ne.0).and.(nambipolar.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nambipolar'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if((nmagdiffu.ne.0).and.(nmagdiffu.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nmagdiffu'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)"  if((nhall.ne.0).and.(nhall.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nhall'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if((nmagdiffu.eq.1).and.(nmagdiffu2.eq.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nmagdiffu : choose one kind not both'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if((nambipolar.eq.1).and.(nambipolar2.eq.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nambipolar : choose one kind not both'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &"
  write(ilun,format)"      (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &"
  write(ilun,format)"      (nhall.eq.1) )then"
  write(ilun,format)"     use_nonideal_mhd = .true."
  write(ilun,format)"  else"
  write(ilun,format)"     use_nonideal_mhd = .false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1) then"
  write(ilun,format)"     write(*,*)'!!!!!!!!!!!!!!!  Non Ideal MHD   !!!!!!!!!!!!!!!!'"
  write(ilun,format)"     write(*,*)'Non ideal MHD parameters'"
  write(ilun,format)"     write(*,*)'Making a test ? Yes=1 No=0',ntestDADM"
  write(ilun,format)"     if(nambipolar.eq.1) then"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion switched ON'"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion coefficient',gammaAD"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion time coefficient',coefad"
  write(ilun,format)"        write(*,*)'Ionisation coefficient',coefionis"
  write(ilun,format)"        if(nminitimestep.eq.1) then"
  write(ilun,format)"           write(*,*)'Mini time step switched ON'"
  write(ilun,format)"           write(*,*)'Mini time step coefficient',coefalfven"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)'Mini time step switched OFF'"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nambipolar2==1) then"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion switched ON : subcylcing'"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion coefficient',gammaAD"
  write(ilun,format)"        write(*,*)'Ambipolar diffusion time coefficient',coefad"
  write(ilun,format)"        write(*,*)'Ionisation coefficient',coefionis"
  write(ilun,format)"        if(nminitimestep.eq.1) then"
  write(ilun,format)"           write(*,*)'Mini time step switched ON'"
  write(ilun,format)"           write(*,*)'Mini time step coefficient',coefalfven"
  write(ilun,format)"        else"
  write(ilun,format)"           write(*,*)'Mini time step switched OFF'"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     if((nambipolar.eq.0) .and. (nambipolar2 == 0)) write(*,*)'Ambipolar diffusion switched OFF'"
  write(ilun,format)""
  write(ilun,format)"     if(nmagdiffu.eq.1)then"
  write(ilun,format)"        write(*,*)'Magnetic diffusion switched ON : multiple time stepping'"
  write(ilun,format)"        write(*,*)'Magnetic diffusion coefficient',etaMD"
  write(ilun,format)"        write(*,*)'Magnetic diffusion  time coefficient',coefohm"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nmagdiffu2.eq.1)then"
  write(ilun,format)"        write(*,*)'Magnetic diffusion switched ON : subcycling'"
  write(ilun,format)"        write(*,*)'Magnetic diffusion coefficient',etaMD"
  write(ilun,format)"        write(*,*)'Magnetic diffusion  time coefficient',coefohm"
  write(ilun,format)"     endif"
  write(ilun,format)"     if((nmagdiffu.eq.0).and.(nmagdiffu2.eq.0))write(*,*)'Magnetic diffusion switched OFF'"
  write(ilun,format)""
  write(ilun,format)"     if(nhall.eq.1)then"
  write(ilun,format)"        write(*,*)'Hall effect switched ON'"
  write(ilun,format)"        write(*,*)'Hall resistivity',rHall"
  write(ilun,format)"        write(*,*)'Hall effect time coefficient',coefhall"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(nhall.eq.0)write(*,*)'Hall effect switched OFF'"
  write(ilun,format)""
  write(ilun,format)"    !if(change_solver.eq.1)then             ! change solver is always used in this version"
  write(ilun,format)"        write(*,*)'Solveur change when the time step becomes too small'"
  write(ilun,format)"        write(*,*)'switch_solv', switch_solv"
  write(ilun,format)"    !endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=pseudovisco_params,END=107)"
  write(ilun,format)"107 continue"
  write(ilun,format)"  if((nvisco.ne.0).and.(nvisco.ne.1)) then"
  write(ilun,format)"     write(*,*)'Wrong choice for nvisco'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1) then"
  write(ilun,format)"     write(*,*)'!!!!!!!!! Pseudo Viscosity Parameters  !!!!!!!!!!'"
  write(ilun,format)"     if(nvisco.eq.1) then"
  write(ilun,format)"        write(*,*)'Pseudo viscosity switched ON'"
  write(ilun,format)"        write(*,*)'Pseudo viscosity coefficient',visco"
  write(ilun,format)"        write(*,*)'Pseudo viscosity time coefficient',coefvisco"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     if(nvisco.eq.0) then"
  write(ilun,format)"        write(*,*)'Pseudo viscosity switched OFF'"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if((nambipolar2.eq.1).or.(nmagdiffu2.eq.1))then"
  write(ilun,format)"     if(pressure_fix.eqv..false.) then"
  write(ilun,format)"        write(*,*)'STS needs pressure_fix=.true. to work....'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)"#else"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=nonidealmhd_params,END=108)"
  write(ilun,format)"108 continue"
  write(ilun,format)"  if( (nambipolar.eq.1) .or. (nambipolar2.eq.1) .or. &"
  write(ilun,format)"       (nmagdiffu .eq.1) .or. (nmagdiffu2 .eq.1) .or. &"
  write(ilun,format)"       (nhall.eq.1) )then"
  write(ilun,format)"     if (myid==1) write(*,*)'You must recompile with NIMHD=1 for non-ideal MHD...'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"  ! Initialize multigroup"
  write(ilun,format)"  allocate(nu_min_hz(1:ngrp),nu_max_hz(1:ngrp),nu_min_ev(1:ngrp),nu_max_ev(1:ngrp))"
  write(ilun,format)"  call create_groups"
  write(ilun,format)"  call tabulate_art4"
  write(ilun,format)"  call read_omegas"
  write(ilun,format)"  if(myid==1 .and. grey_rad_transfer .and. ngrp .gt.1) then"
  write(ilun,format)"     print*,'Warning: Grey Radiation Transfer with NRAD>1'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  scale_E0 = aR*(Tr_floor**4)"
  write(ilun,format)"  P_cal = scale_E0 / (scale_d * scale_v**2)"
  write(ilun,format)"  C_cal = clight / scale_v"
  write(ilun,format)"  is_radiative_energy = .false."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  ! Set i_fld_limiter"
  write(ilun,format)"  i_fld_limiter=i_fld_limiter_nolim"
  write(ilun,format)"  if(fld_limiter=='levermore') i_fld_limiter=i_fld_limiter_levermore"
  write(ilun,format)"  if(fld_limiter=='minerbo')  i_fld_limiter=i_fld_limiter_minerbo"
  write(ilun,format)"  ! Index array for radiative variables and temperature"
  write(ilun,format)"  ! Needed in M1 because temperature is stored in uold(:,nvar)"
  write(ilun,format)"  do irad = 1,nvar_bicg"
  write(ilun,format)"     ind_bicg (irad) = firstindex_er+irad"
  write(ilun,format)"     norm_bicg(irad) = P_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  ind_trad(1) = nvar"
  write(ilun,format)"  norm_trad(1) = Tr_floor"
  write(ilun,format)"  do irad = 2,nvar_trad"
  write(ilun,format)"     ind_trad(irad) = firstindex_er-1+irad"
  write(ilun,format)"     norm_trad(irad) = P_cal"
  write(ilun,format)"     is_radiative_energy(irad) = .true."
  write(ilun,format)"  enddo"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"  ! Set radiative transfer model"
  write(ilun,format)"  select case(rad_trans_model)"
  write(ilun,format)"  case('P1','p1')"
  write(ilun,format)"     irad_trans_model = irad_trans_model_p1"
  write(ilun,format)"  case('M1','m1')"
  write(ilun,format)"     irad_trans_model = irad_trans_model_m1"
  write(ilun,format)"  case default"
  write(ilun,format)"     if(myid==1) write(*,*) 'unknown radiative transfer model: '//rad_trans_model"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end select"
  write(ilun,format)"  call compute_valp"
  write(ilun,format)"  ! Index array for radiative variables and temperature"
  write(ilun,format)"  ! Needed in M1 because temperature is stored in uold(:,nvar)"
  write(ilun,format)"  ind_bicg(1) = nvar"
  write(ilun,format)"  norm_bicg(1) = Tr_floor"
  write(ilun,format)"  do irad = 2,nvar_bicg"
  write(ilun,format)"     ind_bicg(irad) = firstindex_er-1+irad"
  write(ilun,format)"     norm_bicg(irad) = P_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  do irad = ngrp+2,nvar_bicg"
  write(ilun,format)"     norm_bicg(irad) = norm_bicg(irad)*C_cal"
  write(ilun,format)"  enddo"
  write(ilun,format)"  ind_trad=ind_bicg"
  write(ilun,format)"  norm_trad=norm_bicg"
  write(ilun,format)"  is_radiative_energy(2:ngrp+1) = .true."
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Compute the size of the box early,"
  write(ilun,format)"  ! to avoid problems in the initial build of the amr grid"
  write(ilun,format)"  call calc_boxlen"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Make sure virtual boundaries are expanded to "
  write(ilun,format)"  ! account for staggered mesh representation"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  nexpand_bound=2"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for star formation"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(t_star>0)then"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  else if(eps_star>0)then"
  write(ilun,format)"     t_star=0.1635449*(n_star/0.1)**(-0.5)/eps_star"
  write(ilun,format)"     star=.true."
  write(ilun,format)"     pic=.true."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for metal"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  if(metal.and.nvar<(ndim+6))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: metals need nvar >= ndim+6'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify hydro_parameters.f90 and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for non-thermal energies"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"#if NENER>NGRP"
  write(ilun,format)"  if(nvar<(8+nent))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: non-thermal energy need nvar >= 8+nent'"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify NENER and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Check for radiative variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"#if NGRP>0"
  write(ilun,format)"#if USE_FLD==1"
  write(ilun,format)"  if(nvar<(8+nener))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: radiative energies need nvar >= 8+nent+ngrp'"
  write(ilun,format)"#else"
  write(ilun,format)"  if(nvar<(8+nener+nfr))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Error: radiative variables need nvar >= 8+nent+ngrp+nfr'"
  write(ilun,format)"#endif"
  write(ilun,format)"     if(myid==1)write(*,*)'Modify NENER, NGRP and recompile'"
  write(ilun,format)"     nml_ok=.false."
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  ! This section deals with hydro boundary conditions"
  write(ilun,format)"  !-------------------------------------------------"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if (simple_boundary)then"
  write(ilun,format)""
  write(ilun,format)"     ! Compute new coarse grid boundaries"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           nx=nx+1"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              icoarse_min=icoarse_min+1"
  write(ilun,format)"              icoarse_max=icoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ny=ny+1"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jcoarse_min=jcoarse_min+1"
  write(ilun,format)"              jcoarse_max=jcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           nz=nz+1"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kcoarse_min=kcoarse_min+1"
  write(ilun,format)"              kcoarse_max=kcoarse_max+1"
  write(ilun,format)"           end if"
  write(ilun,format)"           nboundary_true=nboundary_true+1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Compute boundary geometry"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        if(ibound_min(i)*ibound_max(i)==1.and.ndim>0.and.bound_type(i)>0)then"
  write(ilun,format)"           if(ibound_min(i)==-1)then"
  write(ilun,format)"              ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_min+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=1"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=11"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=21"
  write(ilun,format)"           else"
  write(ilun,format)"              ibound_min(i)=icoarse_max+ibound_min(i)"
  write(ilun,format)"              ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=2"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=12"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=22"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>1)jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           if(ndim>1)jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(jbound_min(i)*jbound_max(i)==1.and.ndim>1.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           if(jbound_min(i)==-1)then"
  write(ilun,format)"              jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_min+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=3"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=13"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=23"
  write(ilun,format)"           else"
  write(ilun,format)"              jbound_min(i)=jcoarse_max+jbound_min(i)"
  write(ilun,format)"              jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=4"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=14"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=24"
  write(ilun,format)"           end if"
  write(ilun,format)"           if(ndim>2)kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"           if(ndim>2)kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"        else if(kbound_min(i)*kbound_max(i)==1.and.ndim>2.and.bound_type(i)>0)then"
  write(ilun,format)"           ibound_min(i)=icoarse_min+ibound_min(i)"
  write(ilun,format)"           ibound_max(i)=icoarse_max+ibound_max(i)"
  write(ilun,format)"           jbound_min(i)=jcoarse_min+jbound_min(i)"
  write(ilun,format)"           jbound_max(i)=jcoarse_max+jbound_max(i)"
  write(ilun,format)"           if(kbound_min(i)==-1)then"
  write(ilun,format)"              kbound_min(i)=kcoarse_min+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_min+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=5"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=15"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=25"
  write(ilun,format)"           else"
  write(ilun,format)"              kbound_min(i)=kcoarse_max+kbound_min(i)"
  write(ilun,format)"              kbound_max(i)=kcoarse_max+kbound_max(i)"
  write(ilun,format)"              if(bound_type(i)==1)boundary_type(i)=6"
  write(ilun,format)"              if(bound_type(i)==2)boundary_type(i)=16"
  write(ilun,format)"              if(bound_type(i)==3)boundary_type(i)=26"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"     do i=1,nboundary"
  write(ilun,format)"        ! Check for errors"
  write(ilun,format)"        if( (ibound_min(i)<0.or.ibound_max(i)>(nx-1)) .and. (ndim>0) .and.bound_type(i)>0 )then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along X direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (jbound_min(i)<0.or.jbound_max(i)>(ny-1)) .and. (ndim>1) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Y direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"        if( (kbound_min(i)<0.or.kbound_max(i)>(nz-1)) .and. (ndim>2) .and.bound_type(i)>0)then"
  write(ilun,format)"           if(myid==1)write(*,*)'Error in the namelist'"
  write(ilun,format)"           if(myid==1)write(*,*)'Check boundary conditions along Z direction',i"
  write(ilun,format)"           nml_ok=.false."
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)"  nboundary=nboundary_true"
  write(ilun,format)"  if(simple_boundary.and.nboundary==0)then"
  write(ilun,format)"     simple_boundary=.false."
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  ! Compute boundary conservative variables"
  write(ilun,format)"  !--------------------------------------------------"
  write(ilun,format)"  do i=1,nboundary"
  write(ilun,format)"     ! Do imposed BC for radiative transfer"
  write(ilun,format)"     d0=1.0 !compute_db()"
  write(ilun,format)"     d_bound(i)=d0"
  write(ilun,format)"     T_bound(i)=Tr_floor"
  write(ilun,format)"     P_bound(i)=T_bound(i)*d_bound(i)*kb/(mu_gas*mH*scale_v**2)"
  write(ilun,format)"     "
  write(ilun,format)"     boundary_var(i,1)=MAX(d_bound(i),smallr)"
  write(ilun,format)"     boundary_var(i,2)=d_bound(i)*u_bound(i)"
  write(ilun,format)"     boundary_var(i,3)=d_bound(i)*v_bound(i)"
  write(ilun,format)"     boundary_var(i,4)=d_bound(i)*w_bound(i)"
  write(ilun,format)"     boundary_var(i,6)=A_bound(i)"
  write(ilun,format)"     boundary_var(i,7)=B_bound(i)"
  write(ilun,format)"     boundary_var(i,8)=C_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+1)=A_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+2)=B_bound(i)"
  write(ilun,format)"     boundary_var(i,nvar+3)=C_bound(i)"
  write(ilun,format)""
  write(ilun,format)"     er_bound=0.0D0"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"     do j=1,nent"
  write(ilun,format)"        boundary_var(i,firstindex_er+j)=prad_bound(i,j)"
  write(ilun,format)"        er_bound=er_bound+boundary_var(i,8+j)/(gamma_rad(j)-1.0d0)"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if USE_FLD==1 || USE_M_1==1"
  write(ilun,format)"     !     T_bound(i)=P_bound(i)*mu_gas*mH/kb/d_bound(i) *scale_v**2"
  write(ilun,format)"     call temperature_eos(d_bound(i),P_bound(i)/(gamma-1.0d0),T_bound(i),ht)"
  write(ilun,format)"     do j=1,ngrp"
  write(ilun,format)"        boundary_var(i,firstindex_er+j)=radiation_source(T_bound(i),j)/(scale_d*scale_v**2)"
  write(ilun,format)"        er_bound=er_bound+boundary_var(i,firstindex_er+j)"
  write(ilun,format)"#if USE_M_1==1"
  write(ilun,format)"        !Radiative fluxes"
  write(ilun,format)"                   boundary_var(i,firstindex_er+  ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fx_bound(i,j)"
  write(ilun,format)"        if(ndim>1) boundary_var(i,firstindex_er+2*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fy_bound(i,j)"
  write(ilun,format)"        if(ndim>2) boundary_var(i,firstindex_er+3*ngrp+j)=boundary_var(i,firstindex_er+j)*clight/scale_v*fz_bound(i,j)"
  write(ilun,format)"#endif"
  write(ilun,format)"     end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"     ek_bound=0.5d0*d_bound(i)*(u_bound(i)**2+v_bound(i)**2+w_bound(i)**2)"
  write(ilun,format)"     em_bound=0.5d0*(A_bound(i)**2+B_bound(i)**2+C_bound(i)**2)"
  write(ilun,format)"     boundary_var(i,5)=ek_bound+em_bound+er_bound+P_bound(i)/(gamma-1.0d0)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Rearrange level dependent arrays"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  do i=nlevelmax,levelmin,-1"
  write(ilun,format)"     jeans_refine(i)=jeans_refine(i-levelmin+1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do i=1,levelmin-1"
  write(ilun,format)"     jeans_refine(i)=-1.0"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Sort out passive variable indices"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  inener=9 ! MUST BE THIS VALUE !!! RT variable"
  write(ilun,format)"  imetal=firstindex_pscal+1"
  write(ilun,format)"  lastindex_pscal=nvar"
  write(ilun,format)"  if(energy_fix)lastindex_pscal=nvar-1"
  write(ilun,format)"  idelay=imetal"
  write(ilun,format)"  if(metal)idelay=imetal+1"
  write(ilun,format)"  ivirial1=idelay"
  write(ilun,format)"  ivirial2=idelay"
  write(ilun,format)"  if(delayed_cooling)then"
  write(ilun,format)"     ivirial1=idelay+1"
  write(ilun,format)"     ivirial2=idelay+1"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(sf_virial)then"
  write(ilun,format)"     if(sf_compressive) ivirial2=ivirial1+1"
  write(ilun,format)"  endif"
  write(ilun,format)"  ixion=ivirial2"
  write(ilun,format)"  if(delayed_cooling)ixion=ivirial2+1"
  write(ilun,format)"  ichem=ixion"
  write(ilun,format)"  if(aton)ichem=ixion+1"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  ! Set magnetic slope limiters"
  write(ilun,format)"  !-----------------------------------"
  write(ilun,format)"  if (slope_mag_type == -1) then"
  write(ilun,format)"    slope_mag_type = slope_type"
  write(ilun,format)"  endif"
  write(ilun,format)"  if (interpol_mag_type == -1) then"
  write(ilun,format)"    interpol_mag_type = interpol_type"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  ! Read resistivity tables for non-ideal MHD"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  if(use_nonideal_mhd)then"
  write(ilun,format)"     if(use_res==1)then"
  write(ilun,format)"        open(10,file='res_sig.dat', status='old')"
  write(ilun,format)"        read(10,*) nchimie"
  write(ilun,format)"        allocate(resistivite_chimie_res(8,nchimie))"
  write(ilun,format)"        do i=1,nchimie"
  write(ilun,format)"           read(10,*)resistivite_chimie_res(:,i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        close(10)"
  write(ilun,format)"        rho_threshold=max(rho_threshold,resistivite_chimie_res(1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units"
  write(ilun,format)"        resistivite_chimie_res(7,:)=resistivite_chimie_res(7,:)*clight**2/(4.d0*acos(-1.))"
  write(ilun,format)"        resistivite_chimie_res(6,:)=1.43d-7**2/(&"
  write(ilun,format)"        &max(resistivite_chimie_res(6,:)*((1.0d0-tanh(resistivite_chimie_res(1,:)/5.0d13))),1.e-36)&"
  write(ilun,format)"        &*3.d-16*sqrt(resistivite_chimie_res(1,:))*(2.34d-24**1.5)*clight**2)"
  write(ilun,format)"        !     open(1010,file='res_sig_v.dat', status='new')"
  write(ilun,format)"        nminchimie=(resistivite_chimie_res(1,1))"
  write(ilun,format)"        dnchimie=(log10(resistivite_chimie_res(1,nchimie))-log10(resistivite_chimie_res(1,1)))/&"
  write(ilun,format)"                 &(nchimie-1)"
  write(ilun,format)"!                 print*, dnchimie,17.d0/35.d0"
  write(ilun,format)"        !     do i=1,nchimie"
  write(ilun,format)"        !     write(1010,*)resistivite_chimie(1,i),resistivite_chimie(6,i)"
  write(ilun,format)"        !  end do"
  write(ilun,format)"        !     close(1010)"
  write(ilun,format)"        !     stop"
  write(ilun,format)"     else if(use_x2d==1)then"
  write(ilun,format)"        open(42,file='resnh.dat', status='old')"
  write(ilun,format)"        read(42,*) nchimie, tchimie, nvarchimie"
  write(ilun,format)"        read(42,*)"
  write(ilun,format)"        read(42,*)"
  write(ilun,format)"        allocate(resistivite_chimie_x(-1:nvarchimie,nchimie,tchimie,1))"
  write(ilun,format)"        do i=1,tchimie"
  write(ilun,format)"           do j=1,nchimie"
  write(ilun,format)"              read(42,*)resistivite_chimie_x(0:nvarchimie,j,i,1),dummy,dummy,dummy,dummy,resistivite_chimie_x(-1,j,i,1)"
  write(ilun,format)"!              print *, resistivite_chimie_x(:,j,i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           read(42,*)"
  write(ilun,format)"        end do"
  write(ilun,format)"        close(42)"
  write(ilun,format)"        rho_threshold=max(rho_threshold,resistivite_chimie_x(0,1,1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units"
  write(ilun,format)"        nminchimie=(resistivite_chimie_x(0,1,1,1))"
  write(ilun,format)"        dnchimie=(log10(resistivite_chimie_x(0,nchimie,1,1))-log10(resistivite_chimie_x(0,1,1,1)))/&"
  write(ilun,format)"                 &(nchimie-1)"
  write(ilun,format)"!                 print*, dnchimie,15.d0/50.d0"
  write(ilun,format)"        tminchimie=(resistivite_chimie_x(-1,1,1,1))"
  write(ilun,format)"        dtchimie=(log10(resistivite_chimie_x(-1,1,tchimie,1))-log10(resistivite_chimie_x(-1,1,1,1)))/&"
  write(ilun,format)"                 &(tchimie-1)"
  write(ilun,format)"!                 print*, dtchimie,3.d0/50.d0"
  write(ilun,format)"!         close(333)"
  write(ilun,format)"        call rq"
  write(ilun,format)"        call nimhd_3dtable"
  write(ilun,format)"     else if(use_x3d==1)then"
  write(ilun,format)""
  write(ilun,format)"        open(42,file='marchand2016_table.dat',form='unformatted')"
  write(ilun,format)"        read(42) nchimie, tchimie, xichimie, nvarchimie"
  write(ilun,format)"        allocate(resistivite_chimie_x(-2:nvarchimie+4,nchimie,tchimie,xichimie))"
  write(ilun,format)"        read(42) resistivite_chimie_x"
  write(ilun,format)"        close(42)"
  write(ilun,format)""
  write(ilun,format)"        rho_threshold=max(rho_threshold,resistivite_chimie_x(-2,1,1,1)*(mu_gas*mH)/scale_d) ! input in part/cc, output in code units"
  write(ilun,format)"        nminchimie=(resistivite_chimie_x(-2,1,1,1))"
  write(ilun,format)"        dnchimie=(log10(resistivite_chimie_x(-2,nchimie,1,1))-log10(resistivite_chimie_x(-2,1,1,1)))/&"
  write(ilun,format)"                 &(nchimie-1)"
  write(ilun,format)"!                 print*, dnchimie,15.d0/50.d0"
  write(ilun,format)"        tminchimie=(resistivite_chimie_x(-1,1,1,1))"
  write(ilun,format)"        dtchimie=(log10(resistivite_chimie_x(-1,1,tchimie,1))-log10(resistivite_chimie_x(-1,1,1,1)))/&"
  write(ilun,format)"                 &(tchimie-1)"
  write(ilun,format)"!                 print*, dtchimie,3.d0/50.d0"
  write(ilun,format)"        ximinchimie=(resistivite_chimie_x(0,1,1,1))"
  write(ilun,format)"        dxichimie=(log10(resistivite_chimie_x(0,1,1,xichimie))-log10(resistivite_chimie_x(0,1,1,1)))/&"
  write(ilun,format)"                 &(xichimie-1)"
  write(ilun,format)"        call rq_3d"
  write(ilun,format)"        call nimhd_4dtable"
  write(ilun,format)"     else"
  write(ilun,format)"        print*, 'must choose an input for abundances or resistivities'"
  write(ilun,format)"        stop"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(barotrop)fld=.false."
  write(ilun,format)""
  write(ilun,format)"  if(barotrop .and. (.not. analytical_barotrop))then"
  write(ilun,format)"     open(101,file='barotropic_eos.dat', status='old')"
  write(ilun,format)"     read(101,*)nrho_barotrop,rhomin_barotrop,rhomax_barotrop,drho_barotrop"
  write(ilun,format)"     allocate(rho_barotrop(nrho_barotrop))"
  write(ilun,format)"     allocate(temp_barotrop(nrho_barotrop))"
  write(ilun,format)"     do i=1,nrho_barotrop"
  write(ilun,format)"        read(101,*)rho_barotrop(i),temp_barotrop(i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(101)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(eos)then"
  write(ilun,format)"  "
  write(ilun,format)"     !--------------------------------"
  write(ilun,format)"     ! Read eos tables"
  write(ilun,format)"     !--------------------------------"
  write(ilun,format)"!      open(14,file='verif.dat')"
  write(ilun,format)"     open(10,file='tab_eos.dat',status='old',form='unformatted')"
  write(ilun,format)"     read(10) nRho,nEnergy"
  write(ilun,format)"     read(10) rhomin,rhomax,emin,Emax,yHe"
  write(ilun,format)"     "
  write(ilun,format)"     allocate(Rho_eos(nRho,nEnergy),Ener_eos(nRho,nEnergy),Temp_eos(nRho,nEnergy),P_eos(nRho,nEnergy))"
  write(ilun,format)"     allocate(  Cs_eos(nRho,nEnergy),S_eos(nRho,nEnergy),  xH_eos(nRho,nEnergy), xH2_eos(nRho,nEnergy)                  )"
  write(ilun,format)"     allocate(xHe_eos(nRho,nEnergy),xHep_eos(nRho,nEnergy),Cv_eos(nRho,nEnergy)                                       )"
  write(ilun,format)"     !inversion de la table eos"
  write(ilun,format)"     nTemp=nEnergy"
  write(ilun,format)"     allocate(eint_eos(nRho,nTemp))"
  write(ilun,format)"     "
  write(ilun,format)"     read(10)  rho_eos"
  write(ilun,format)"     read(10) Ener_eos"
  write(ilun,format)"     read(10) Temp_eos"
  write(ilun,format)"     read(10)    P_eos"
  write(ilun,format)"     read(10)    S_eos"
  write(ilun,format)"     read(10)   Cs_eos"
  write(ilun,format)"     read(10)   xH_eos"
  write(ilun,format)"     read(10)  xH2_eos"
  write(ilun,format)"     read(10)  xHe_eos"
  write(ilun,format)"     read(10) xHep_eos"
  write(ilun,format)"     close(10)"
  write(ilun,format)"     "
  write(ilun,format)"     rho_eos(:,:) = log10(rho_eos(:,:))"
  write(ilun,format)"     ener_eos(:,:) = log10(ener_eos(:,:))"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (P_eos(ir,ie) .eq. 0.0d0) then"
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = P_eos(ir,ie+1) * P_eos(ir,ie-1) *  P_eos(ir-1,ie) * P_eos(ir+1,ie)"
  write(ilun,format)"                 yy = P_eos(ir+1,ie+1) * P_eos(ir+1,ie-1) *  P_eos(ir-1,ie-1) * P_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = P_eos(ir,ie+2) * P_eos(ir,ie-2) *  P_eos(ir-2,ie) * P_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = P_eos(ir+3,ie+3) * P_eos(ir-3,ie-3) *  P_eos(ir-3,ie+3) * P_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+1) + P_eos(ir,ie-1) + P_eos(ir-1,ie) + P_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+1,ie+1) + P_eos(ir+1,ie-1) + P_eos(ir-1,ie+1)+P_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir,ie+2) + P_eos(ir,ie-2) + P_eos(ir-2,ie) + P_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    P_eos(ir,ie) = 0.25d0*(P_eos(ir+3,ie+3) + P_eos(ir+3,ie-3) + P_eos(ir-3,ie+3)+P_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous P_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (Cs_eos(ir,ie) .eq. 0.0d0) then           "
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = Cs_eos(ir,ie+1) * Cs_eos(ir,ie-1) *  Cs_eos(ir-1,ie) * Cs_eos(ir+1,ie)"
  write(ilun,format)"                 yy = Cs_eos(ir+1,ie+1) * Cs_eos(ir+1,ie-1) *  Cs_eos(ir-1,ie-1) * Cs_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = Cs_eos(ir,ie+2) * Cs_eos(ir,ie-2) *  Cs_eos(ir-2,ie) * Cs_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = Cs_eos(ir+3,ie+3) * Cs_eos(ir-3,ie-3) *  Cs_eos(ir-3,ie+3) * Cs_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+1) + Cs_eos(ir,ie-1) + Cs_eos(ir-1,ie) + Cs_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+1,ie+1) + Cs_eos(ir+1,ie-1) + Cs_eos(ir-1,ie+1)+Cs_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir,ie+2) + Cs_eos(ir,ie-2) + Cs_eos(ir-2,ie) + Cs_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    Cs_eos(ir,ie) = 0.25d0*(Cs_eos(ir+3,ie+3) + Cs_eos(ir+3,ie-3) + Cs_eos(ir-3,ie+3)+Cs_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous Cs_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     do k=1,5"
  write(ilun,format)"        ii=0"
  write(ilun,format)"        jj=0"
  write(ilun,format)"        kk=0"
  write(ilun,format)"        hh=0"
  write(ilun,format)"        ee=0"
  write(ilun,format)"        gg=0"
  write(ilun,format)"        do ir=2,nRho-1"
  write(ilun,format)"           do ie=2,nEnergy-1"
  write(ilun,format)"              if (Temp_eos(ir,ie) .eq. 0.0d0) then           "
  write(ilun,format)"                 ii = ii+1"
  write(ilun,format)"                 xx = Temp_eos(ir,ie+1) * Temp_eos(ir,ie-1) *  Temp_eos(ir-1,ie) * Temp_eos(ir+1,ie)"
  write(ilun,format)"                 yy = Temp_eos(ir+1,ie+1) * Temp_eos(ir+1,ie-1) *  Temp_eos(ir-1,ie-1) * Temp_eos(ir-1,ie+1)"
  write(ilun,format)"                 if(ie > 2 .and. ie < nEnergy-1 .and. ir > 2 .and. ir < nRho-1)then"
  write(ilun,format)"                    ww = Temp_eos(ir,ie+2) * Temp_eos(ir,ie-2) *  Temp_eos(ir-2,ie) * Temp_eos(ir+2,ie)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    ww = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(ie > 3 .and. ie < nEnergy-2 .and. ir > 3 .and. ir < nRho-2)then"
  write(ilun,format)"                    zz = Temp_eos(ir+3,ie+3) * Temp_eos(ir-3,ie-3) *  Temp_eos(ir-3,ie+3) * Temp_eos(ir+3,ie-3)"
  write(ilun,format)"                 else"
  write(ilun,format)"                    zz = 0.0_dp"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if (xx .ne. 0.) then"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+1)+Temp_eos(ir,ie-1)+Temp_eos(ir-1,ie)+Temp_eos(ir+1,ie))"
  write(ilun,format)"                    jj=jj+1              "
  write(ilun,format)"                 else if (yy .ne. 0. .and. k > 0) then"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+1,ie+1)+Temp_eos(ir+1,ie-1)+Temp_eos(ir-1,ie+1)+Temp_eos(ir-1,ie-1))"
  write(ilun,format)"                    kk=kk+1"
  write(ilun,format)"                 else if (ww .ne. 0 .and. k > 1) then"
  write(ilun,format)"                    ee = ee +1"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir,ie+2)+Temp_eos(ir,ie-2)+Temp_eos(ir-2,ie)+Temp_eos(ir+2,ie))"
  write(ilun,format)"                 else if (zz .ne. 0 .and. k > 2) then"
  write(ilun,format)"                    hh=hh+1"
  write(ilun,format)"                    Temp_eos(ir,ie) = 0.25d0*(Temp_eos(ir+3,ie+3)+Temp_eos(ir+3,ie-3)+Temp_eos(ir-3,ie+3)+Temp_eos(ir-3,ie-3))"
  write(ilun,format)"                 else "
  write(ilun,format)"                    gg=gg+1"
  write(ilun,format)"                 endif"
  write(ilun,format)"              endif"
  write(ilun,format)"           enddo"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        if (myid == 1) print*, 'on bouche les trous Temp_eos', ii,jj,kk,ee,hh,gg, 'iter', k"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     Tmin=3.0d0"
  write(ilun,format)"     Tmax=1.0d5"
  write(ilun,format)"     dtemp1 =(log10(Tmax) - log10(Tmin))/ntemp"
  write(ilun,format)"     eint_eos(:,:)=0.0d0"
  write(ilun,format)"     do ir=2,nRho-1"
  write(ilun,format)"        do it=1,ntemp"
  write(ilun,format)"           d_loc = (10.**rho_eos(ir,1))"
  write(ilun,format)"           T0 = 10.**(log10(Tmin) + (it-1.0d0)*dtemp1)"
  write(ilun,format)"           "
  write(ilun,format)"           eint_old = d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0))"
  write(ilun,format)"           if (it >1) then"
  write(ilun,format)"              eint_old = max(d_loc*kb*T0/(mu_gas*mh*(gamma-1.0d0)),eint_eos(ir,it-1))"
  write(ilun,format)"           end if"
  write(ilun,format)"           "
  write(ilun,format)"           epsilon_n = 1.0d0"
  write(ilun,format)"           "
  write(ilun,format)"           do ii=1,1000"
  write(ilun,format)"              call temperature_eos(d_loc/scale_d,eint_old/(scale_d*scale_v**2),temp_new,ht)"
  write(ilun,format)"              if (ht==1) then"
  write(ilun,format)"                 eint_old=0.d0"
  write(ilun,format)"                 exit"
  write(ilun,format)"              end if"
  write(ilun,format)"              call temperature_eos(d_loc/scale_d,eint_old*1.001_dp/(scale_d*scale_v**2),temp_new2,ht)"
  write(ilun,format)"              if (ht==1) then"
  write(ilun,format)"                 eint_old=0.d0"
  write(ilun,format)"                 exit"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              if(abs(Temp_new2-Temp_new) .ne.0)then"
  write(ilun,format)"                 eint_new = eint_old - (Temp_new-T0)/((Temp_new2-Temp_new)/(0.001*eint_old))"
  write(ilun,format)"              else"
  write(ilun,format)"                 eint_new = eint_old"
  write(ilun,format)"              endif"
  write(ilun,format)"              epsilon_n = abs(eint_new - eint_old)/eint_old"
  write(ilun,format)"              eint_old = eint_new"
  write(ilun,format)"              if  (abs(epsilon_n) .lt. 1.d-4) then"
  write(ilun,format)"                 exit"
  write(ilun,format)"              else if (ii==1000) then"
  write(ilun,format)"                 print*, 'newton for e(rho,T) did not converge at ', log10(d_loc),log10(T0)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"           eint_eos(ir,it) = eint_old "
  write(ilun,format)"        enddo"
  write(ilun,format)"     enddo"
  write(ilun,format)"     "
  write(ilun,format)"     Cv_eos(:,:)=0.0d0"
  write(ilun,format)"     "
  write(ilun,format)"     do  ir=2,nRho-1"
  write(ilun,format)"        do  ie=2,nEnergy-1"
  write(ilun,format)"           d_loc = (10.**rho_eos(ir,1))"
  write(ilun,format)"           T0 = 10.**(ener_eos(ir,ie))"
  write(ilun,format)"           "
  write(ilun,format)"           call temperature_eos(d_loc/scale_d,(T0-0.001_dp*T0)/(scale_d*scale_v**2),temp_new,ht)"
  write(ilun,format)"           call temperature_eos(d_loc/scale_d,(T0+0.001_dp*T0)/(scale_d*scale_v**2),temp_new2,ht)"
  write(ilun,format)"           "
  write(ilun,format)"           if((temp_new2-temp_new) .ne. 0.0_dp)then"
  write(ilun,format)"              Cv_eos(ir,ie)=(0.002_dp*T0)/(temp_new2-temp_new)"
  write(ilun,format)"           else"
  write(ilun,format)"              Cv_eos(ir,ie) = 1.0_dp"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     Cv_eos(:,nEnergy)=Cv_eos(:,nEnergy-1)"
  write(ilun,format)"     "
  write(ilun,format)"     if (myid == 1) print*, 'ok pour le bouchage'"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Multigroup opacities initialization"
  write(ilun,format)"  if(fld)then"
  write(ilun,format)"     if((opacity_type == 'grey') .and. (ngrp > 1) .and. (.not.stellar_photon))then"
  write(ilun,format)"        if(myid == 1)then"
  write(ilun,format)"           write(*,*) 'WARNING! Trying to use grey opacity table with ngrp =',ngrp"
  write(ilun,format)"           write(*,*) 'Switching to multigroup opacities'"
  write(ilun,format)"        endif"
  write(ilun,format)"        opacity_type = 'multigroup'"
  write(ilun,format)"     endif"
  write(ilun,format)"!!      call init_opacities"
  write(ilun,format)"     call init_opacities_pascucci"
  write(ilun,format)"  end if"
  write(ilun,format)" "
  write(ilun,format)"  if(PMS_evol .and. rt_feedback .and. Hosokawa_track)then"
  write(ilun,format)"     open(101,file='Hosokawa_track.dat', status='old')"
  write(ilun,format)"     read(101,*)nmdot_PMS,nm_PMS,ndata_PMS"
  write(ilun,format)"     allocate(nb_ligne_PMS(nmdot_PMS))"
  write(ilun,format)"     allocate(data_PMS(nmdot_PMS,nm_PMS,ndata_PMS))"
  write(ilun,format)"     read(101,*)nb_ligne_PMS(1),nb_ligne_PMS(2),nb_ligne_PMS(3),nb_ligne_PMS(4),nb_ligne_PMS(5)"
  write(ilun,format)"     do i=1,nmdot_PMS"
  write(ilun,format)"        do j=1,nm_PMS"
  write(ilun,format)"           read(101,*)data_PMS(i,j,1),data_PMS(i,j,2),data_PMS(i,j,3),data_PMS(i,j,4) ! mdot,mass,luminosity,radius"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     close(101)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_hydro_params"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################ "
  write(ilun,format)"!################################################################"
  write(ilun,format)"!   Modification of original codes written by David H. Bailey    "
  write(ilun,format)"!   This subroutine computes ddb(i) = dda(i)+ddb(i)"
  write(ilun,format)"subroutine DDPDD (dda, ddb, len, itype)"
  write(ilun,format)"use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp):: e, t1, t2"
  write(ilun,format)"  integer i, len, itype"
  write(ilun,format)"!  complex*16:: dda(len), ddb(len)"
  write(ilun,format)"  complex*16:: dda, ddb"
  write(ilun,format)"!  print*,dda,ddb"
  write(ilun,format)"  do i = 1, len"
  write(ilun,format)"     !   Compute dda + ddb using Knuth's trick."
  write(ilun,format)"     t1 = real(dda) + real(ddb)"
  write(ilun,format)"     e = t1 - real(dda)"
  write(ilun,format)"!!      t1 = real(dda(i)) + real(ddb(i))"
  write(ilun,format)"!!      e = t1 - real(dda(i))"
  write(ilun,format)"     t2 = ((real(ddb) - e) + (real(dda) - (t1 - e)))&"
  write(ilun,format)"     &     +imag(dda) + imag(ddb)"
  write(ilun,format)"!!      t2 = ((real(ddb(i)) - e) + (real(dda(i)) - (t1 - e)))&"
  write(ilun,format)"!!      &     +imag(dda(i)) + imag(ddb(i))"
  write(ilun,format)"!!  !    print*,t1,t2"
  write(ilun,format)"     !   The result is t1 + t2, after normalization."
  write(ilun,format)"!!      ddb(i) = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1) )"
  write(ilun,format)"     ddb = cmplx ( t1 + t2, t2 - ((t1 + t2) - t1),dp)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)"  return"
  write(ilun,format)"end subroutine DDPDD"
  write(ilun,format)"../patch/irradiation/test_pascucci/rt_cooling_module.f90"
  write(ilun,format)"! Non-equlibrium (in H and He) cooling module for radiation-hydrodynamics."
  write(ilun,format)"! For details, see Rosdahl et al. 2013, and Rosdahl & Teyssier 2015."
  write(ilun,format)"! Joki Rosdahl, Andreas Bleuler, and Romain Teyssier, September 2015."
  write(ilun,format)""
  write(ilun,format)"module rt_cooling_module"
  write(ilun,format)"  use cooling_module,only:X, Y"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use coolrates_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  private   ! default"
  write(ilun,format)""
  write(ilun,format)"  public rt_set_model, rt_solve_cooling, update_UVrates, cmp_chem_eq     &"
  write(ilun,format)"         , isHe, is_mu_H2, X, Y, rhoc, kB, mH, T2_min_fix, twopi         &"
  write(ilun,format)"         , signc, sigec, PHrate, UVrates, rt_isIR, kappaAbs, kappaSc     &"
  write(ilun,format)"         , is_kIR_T, iIR, rt_isIRtrap, iIRtrapVar, rt_pressBoost         &"
  write(ilun,format)"         , rt_isoPress, rt_T_rad, rt_vc, a_r"
  write(ilun,format)""
  write(ilun,format)"  ! NOTE: T2=T/mu"
  write(ilun,format)"  ! Np = photon density, Fp = photon flux,"
  write(ilun,format)""
  write(ilun,format)"  real(dp),parameter::rhoc      = 1.88000d-29    !  Crit. density [g cm-3]"
  write(ilun,format)"  real(dp),parameter::mH        = 1.66000d-24    !         H atom mass [g]"
  write(ilun,format)"  real(dp),parameter::kB        = 1.38062d-16    ! Boltzm.const. [erg K-1]"
  write(ilun,format)"  real(dp),parameter::a_r       = 7.5657d-15   ! Rad.const. [erg cm-3 K-4]"
  write(ilun,format)"  real(dp),parameter::mu_mol    = 1.2195D0"
  write(ilun,format)"  real(dp),parameter::T2_min_fix=1.d-2           !     Min temperature [K]"
  write(ilun,format)"  real(dp),parameter::twopi     = 6.2831853d0    !            Two times pi"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::T_min, T_frac, x_min, x_frac, Np_min, Np_frac, Fp_min, Fp_frac"
  write(ilun,format)""
  write(ilun,format)"  integer,parameter::iIR=1                       !          IR group index"
  write(ilun,format)"  integer::iIRtrapVar=1                          ! Trapped IR energy index"
  write(ilun,format)"  ! Namelist parameters:"
  write(ilun,format)"  logical::isHe=.true."
  write(ilun,format)"  logical::is_mu_H2=.false."
  write(ilun,format)"  logical::rt_isoPress=.false.         ! Use cE, not F, for rad. pressure"
  write(ilun,format)"  real(dp)::rt_pressBoost=1d0          ! Boost on RT pressure"
  write(ilun,format)"  logical::rt_isIR=.false.             ! Using IR scattering on dust?"
  write(ilun,format)"  logical::rt_isIRtrap=.false.         ! IR trapping in NENER variable?"
  write(ilun,format)"  logical::is_kIR_T=.false.            ! k_IR propto T^2?"
  write(ilun,format)"  logical::rt_T_rad=.false.            ! Use T_gas = T_rad"
  write(ilun,format)"  logical::rt_vc=.false.               ! (semi-) relativistic RT"
  write(ilun,format)"  real(dp)::Tmu_dissoc=1d3             ! Dissociation temperature [K]"
  write(ilun,format)"  real(dp),dimension(nGroups)::kappaAbs=0! Dust and gas mixture absorption opacity"
  write(ilun,format)"  real(dp),dimension(nGroups)::kappaSc=0 ! Dust and gas mixture scattering opacity"
  write(ilun,format)""
  write(ilun,format)"  ! Cooling constants, updated on SED and c-change [cm3 s-1],[erg cm3 s-1]"
  write(ilun,format)"  real(dp),dimension(nGroups,nIons)::signc,sigec,PHrate"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(nIons, 2)::UVrates     !UV backgr. heating/ion. rates"
  write(ilun,format)""
  write(ilun,format)"CONTAINS"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE rt_set_model(h,omegab, omega0, omegaL, astart_sim, T2_sim)"
  write(ilun,format)"! Initialize cooling. All these parameters are unused at the moment and"
  write(ilun,format)"! are only there for the original cooling-module."
  write(ilun,format)"! h (dble)            => H0/100"
  write(ilun,format)"! omegab (dble)       => Omega baryons"
  write(ilun,format)"! omega0 (dble)       => Omega materal total"
  write(ilun,format)"! omegaL (dble)       => Omega Lambda"
  write(ilun,format)"! astart_sim (dble)   => Redshift at which we start the simulation"
  write(ilun,format)"! T2_sim (dble)      <=  Starting temperature in simulation?"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons, ONLY: myid"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use coolrates_module,only: init_coolrates_tables"
  write(ilun,format)"  real(kind=8) :: astart_sim, T2_sim, h, omegab, omega0, omegaL"
  write(ilun,format)"  real(kind=8) :: astart=0.0001, aend, dasura, T2end=T2_min_fix, mu=1., ne"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  if(myid==1) write(*,*) &"
  write(ilun,format)"       '==================RT momentum pressure is turned ON=============='"
  write(ilun,format)"  if(myid==1 .and. rt_isIR) &"
  write(ilun,format)"       write(*,*) 'There is an IR group, with index ',iIR"
  write(ilun,format)"  if(myid==1 .and. rt_isIRtrap) write(*,*) &"
  write(ilun,format)"       '=========IR trapping is turned ON=============='"
  write(ilun,format)"  ! do initialization"
  write(ilun,format)"  isHe=.true. ; if(Y .le. 0.) isHe=.false."
  write(ilun,format)"  T_MIN           = 0.1                  !                      Minimum T2"
  write(ilun,format)"  T_FRAC          = 0.1"
  write(ilun,format)""
  write(ilun,format)"  x_MIN           = 1.d-6                !    Minimum ionization fractions"
  write(ilun,format)"  x_FRAC          = 0.1"
  write(ilun,format)""
  write(ilun,format)"  Np_MIN = 1.d-13                        !            Photon density floor"
  write(ilun,format)"  Np_FRAC = 0.2"
  write(ilun,format)""
  write(ilun,format)"  Fp_MIN  = 1D-13*rt_c_cgs               !           Minimum photon fluxes"
  write(ilun,format)"  Fp_FRAC = 0.5"
  write(ilun,format)""
  write(ilun,format)"  ! Calculate initial temperature"
  write(ilun,format)"  if (astart_sim < astart) then"
  write(ilun,format)"     write(*,*) 'ERROR in set_model : astart_sim is too small.'"
  write(ilun,format)"     write(*,*) 'astart     =',astart"
  write(ilun,format)"     write(*,*) 'astart_sim =',astart_sim"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)"  aend=astart_sim"
  write(ilun,format)"  dasura=0.02d0"
  write(ilun,format)""
  write(ilun,format)"  call update_rt_c"
  write(ilun,format)"  call init_UV_background"
  write(ilun,format)"  if(cosmo) then"
  write(ilun,format)"     call update_UVrates(aexp)"
  write(ilun,format)"     call init_coolrates_tables(aexp)"
  write(ilun,format)"  else"
  write(ilun,format)"     call update_UVrates(astart_sim)"
  write(ilun,format)"     call init_coolrates_tables(astart_sim)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(nrestart==0 .and. cosmo)                                            &"
  write(ilun,format)"       call rt_evol_single_cell(astart,aend,dasura,h,omegab,omega0       &"
  write(ilun,format)"                               ,omegaL,T2end,mu,ne,.false.)"
  write(ilun,format)"  T2_sim=T2end"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE rt_set_model"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE update_UVrates(aexp)"
  write(ilun,format)"! Set the UV ionization and heating rates according to the given a_exp."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use amr_parameters,only:haardt_madau"
  write(ilun,format)"  real(dp)::aexp"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  UVrates=0."
  write(ilun,format)"  if(.not. haardt_madau) RETURN"
  write(ilun,format)""
  write(ilun,format)"  call inp_UV_rates_table(1./aexp - 1., UVrates, .true.)"
  write(ilun,format)""
  write(ilun,format)"  !if(myid==1) then"
  write(ilun,format)"  !   write(*,*) 'The UV rates have changed to:'"
  write(ilun,format)"  !   do i=1,nIons"
  write(ilun,format)"  !      write(*,910) UVrates(i,:)"
  write(ilun,format)"  !   enddo"
  write(ilun,format)"  !endif"
  write(ilun,format)"  !910 format (1pe21.6, ' s-1', 1pe21.6,' erg s-1')"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE update_UVrates"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE rt_solve_cooling(T2, xion, Np, Fp, p_gas, dNpdt, dFpdt        &"
  write(ilun,format)"                           ,nH, c_switch, Zsolar, dt, a_exp, nCell)"
  write(ilun,format)"! Semi-implicitly solve for new temperature, ionization states,"
  write(ilun,format)"! photon density/flux, and gas velocity in a number of cells."
  write(ilun,format)"! Parameters:"
  write(ilun,format)"! T2     <=> T/mu [K]"
  write(ilun,format)"! xion   <=> NION ionization fractions"
  write(ilun,format)"! Np     <=> NGROUPS photon number densities [cm-3]"
  write(ilun,format)"! Fp     <=> NGROUPS * ndim photon number fluxes [cm-2 s-1]"
  write(ilun,format)"! p_gas  <=> ndim gas momentum densities [cm s-1 g cm-3]"
  write(ilun,format)"! dNpdt   =>  Op split increment in photon densities during dt"
  write(ilun,format)"! dFpdt   =>  Op split increment in photon flux magnitudes during dt"
  write(ilun,format)"! nH      =>  Hydrogen number densities [cm-3]"
  write(ilun,format)"! c_switch=>  Cooling switch (1 for cool/heat, 0 for no cool/heat)"
  write(ilun,format)"! Zsolar  =>  Cell metallicities [solar fraction]"
  write(ilun,format)"! dt      =>  Timestep size             [s]"
  write(ilun,format)"! a_exp   =>  Cosmic expansion"
  write(ilun,format)"! nCell   =>  Number of cells (length of all the above vectors)"
  write(ilun,format)"!"
  write(ilun,format)"! We use a slightly modified method of Anninos et al. (1997)."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp),dimension(1:nvector):: T2"
  write(ilun,format)"  real(dp),dimension(1:nIons, 1:nvector):: xion"
  write(ilun,format)"  real(dp),dimension(1:nGroups, 1:nvector):: Np, dNpdt"
  write(ilun,format)"  real(dp),dimension(1:ndim, 1:nGroups, 1:nvector):: Fp, dFpdt"
  write(ilun,format)"  real(dp),dimension(1:ndim, 1:nvector):: p_gas"
  write(ilun,format)"  real(dp),dimension(1:nvector):: nH, Zsolar"
  write(ilun,format)"  logical,dimension(1:nvector):: c_switch"
  write(ilun,format)"  real(dp)::dt, a_exp"
  write(ilun,format)"  integer::ncell !--------------------------------------------------------"
  write(ilun,format)"  real(dp),dimension(1:nvector):: tLeft, ddt"
  write(ilun,format)"  logical:: dt_ok"
  write(ilun,format)"  real(dp)::dt_rec"
  write(ilun,format)"  real(dp):: dT2"
  write(ilun,format)"  real(dp),dimension(nIons):: dXion"
  write(ilun,format)"  real(dp),dimension(nGroups):: dNp"
  write(ilun,format)"  real(dp),dimension(1:ndim, 1:nGroups):: dFp"
  write(ilun,format)"  real(dp),dimension(1:ndim):: dp_gas"
  write(ilun,format)"  integer::i, ia, ig,  nAct, nAct_next, loopcnt, code"
  write(ilun,format)"  integer,dimension(1:nvector):: indAct              ! Active cell indexes"
  write(ilun,format)"  real(dp)::one_over_rt_c_cgs, one_over_egy_IR_erg, one_over_x_FRAC"
  write(ilun,format)"  real(dp)::one_over_Np_FRAC, one_over_Fp_FRAC, one_over_T_FRAC"
  write(ilun,format)"  real(dp),dimension(1:nGroups) :: group_egy_ratio, group_egy_erg"
  write(ilun,format)"  real(dp):: mu"
  write(ilun,format)""
  write(ilun,format)"  ! Store some temporary variables reduce computations"
  write(ilun,format)"  one_over_rt_c_cgs = 1d0 / rt_c_cgs"
  write(ilun,format)"  one_over_Np_FRAC = 1d0 / Np_FRAC"
  write(ilun,format)"  one_over_Fp_FRAC = 1d0 / Fp_FRAC"
  write(ilun,format)"  one_over_T_FRAC = 1d0 / T_FRAC"
  write(ilun,format)"  one_over_x_FRAC = 1d0 / x_FRAC"
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"  if(rt .and. nGroups .gt. 0) then"
  write(ilun,format)"     group_egy_erg(1:nGroups) = group_egy(1:nGroups) * ev_to_erg"
  write(ilun,format)"     if(rt_isIR) then"
  write(ilun,format)"        group_egy_ratio(1:nGroups) = group_egy(1:nGroups) / group_egy(iIR)"
  write(ilun,format)"        one_over_egy_IR_erg = 1.d0 / group_egy_erg(iIR)"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"#endif"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  tleft(1:ncell) = dt                !       Time left in dt for each cell"
  write(ilun,format)"  ddt(1:ncell) = dt                  ! First guess at sub-timestep lengths"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ncell"
  write(ilun,format)"     indact(i) = i                   !      Set up indexes of active cells"
  write(ilun,format)"     ! Ensure all state vars are legal:"
  write(ilun,format)"     T2(i) = MAX(T2(i), T2_min_fix)"
  write(ilun,format)"     ! HACK - if a high temperature, set fully ionised"
  write(ilun,format)"     if (T2(i) .gt. 1e5) then"
  write(ilun,format)"        xion(1,i) = 1d0"
  write(ilun,format)"        xion(2,i) = 1d-6"
  write(ilun,format)"        xion(3,i) = 1d0"
  write(ilun,format)"     endif"
  write(ilun,format)"     ! END HACK"
  write(ilun,format)"     xion(1:nIons,i) = MIN(MAX(xion(1:nIons,i), x_MIN),1.d0)"
  write(ilun,format)"     if(xion(2,i)+xion(3,i) .gt. 1.d0) then"
  write(ilun,format)"        if(xion(2,i) .gt. xion(3,i)) then"
  write(ilun,format)"           xion(2,i)=1.d0-xion(3,i)"
  write(ilun,format)"        else"
  write(ilun,format)"           xion(3,i)=1.d0-xion(2,i)"
  write(ilun,format)"        endif"
  write(ilun,format)"     endif"
  write(ilun,format)"     if(rt) then"
  write(ilun,format)"        do ig=1,ngroups"
  write(ilun,format)"           Np(ig,i) = MAX(smallNp, Np(ig,i))"
  write(ilun,format)"           call reduce_flux(Fp(:,ig,i),Np(ig,i)*rt_c_cgs)"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Loop until all cells have tleft=0"
  write(ilun,format)"  ! **********************************************"
  write(ilun,format)"  nAct=nCell                                      ! Currently active cells"
  write(ilun,format)"  loopcnt=0 ; n_cool_cells=n_cool_cells+nCell     !             Statistics"
  write(ilun,format)"  do while (nAct .gt. 0)      ! Iterate while there are still active cells"
  write(ilun,format)"     loopcnt=loopcnt+1   ;   tot_cool_loopcnt=tot_cool_loopcnt+nAct"
  write(ilun,format)"     nAct_next=0                     ! Active cells for the next iteration"
  write(ilun,format)"     do ia=1,nAct                             ! Loop over the active cells"
  write(ilun,format)"        i = indAct(ia)                        !                 Cell index"
  write(ilun,format)"        call cool_step(i)"
  write(ilun,format)"        if(loopcnt .gt. 100000) then"
  write(ilun,format)"           call display_coolinfo(.true., loopcnt, i, dt-tleft(i), dt     &"
  write(ilun,format)"                            ,ddt(i), nH(i), T2(i),  xion(:,i),  Np(:,i)  &"
  write(ilun,format)"                            ,Fp(:,:,i),  p_gas(:,i)                      &"
  write(ilun,format)"                            ,dT2, dXion, dNp, dFp, dp_gas, code)"
  write(ilun,format)"        endif"
  write(ilun,format)"        if(.not. dt_ok) then"
  write(ilun,format)"           ddt(i)=ddt(i)/2.                    ! Try again with smaller dt"
  write(ilun,format)"           nAct_next=nAct_next+1 ; indAct(nAct_next) = i"
  write(ilun,format)"           loopCodes(code) = loopCodes(code)+1"
  write(ilun,format)"           cycle"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Update the cell state (advance the time by ddt):"
  write(ilun,format)"        T2(i)     = T2(i) + dT2"
  write(ilun,format)"        xion(:,i) = xion(:,i) + dXion(:)"
  write(ilun,format)"        if(nGroups .gt. 0) then"
  write(ilun,format)"           Np(:,i)   = Np(:,i) + dNp(:)"
  write(ilun,format)"           Fp(:,:,i) = Fp(:,:,i) + dFp(:,:)"
  write(ilun,format)"        endif"
  write(ilun,format)"        p_gas(:,i)   = p_gas(:,i) + dp_gas(:)"
  write(ilun,format)""
  write(ilun,format)"        tleft(i)=tleft(i)-ddt(i)"
  write(ilun,format)"        if(tleft(i) .gt. 0.) then           ! Not finished with this cell"
  write(ilun,format)"           nAct_next=nAct_next+1 ; indAct(nAct_next) = i"
  write(ilun,format)"        else if(tleft(i) .lt. 0.) then        ! Overshot by abs(tleft(i))"
  write(ilun,format)"           print*,'In rt_solve_cooling: tleft < 0  !!'"
  write(ilun,format)"           stop"
  write(ilun,format)"        endif"
  write(ilun,format)"        ddt(i)=min(dt_rec,tleft(i))    ! Use recommended dt from cool_step"
  write(ilun,format)"     end do ! end loop over active cells"
  write(ilun,format)"     nAct=nAct_next"
  write(ilun,format)"  end do ! end iterative loop"
  write(ilun,format)""
  write(ilun,format)"  ! loop statistics"
  write(ilun,format)"  max_cool_loopcnt=max(max_cool_loopcnt,loopcnt)"
  write(ilun,format)"contains"
  write(ilun,format)""
  write(ilun,format)"  !XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"  SUBROUTINE cool_step(icell)"
  write(ilun,format)"  ! Compute change in cell state in timestep ddt(icell), or set in dt_rec"
  write(ilun,format)"  ! a recommendation for new timestep if ddt(icell) proves too large."
  write(ilun,format)"  ! T2      => T/mu [K]                                -- dT2 is new value"
  write(ilun,format)"  ! xion    => NION ionization fractions               --     dXion is new"
  write(ilun,format)"  ! Np      => NGROUPS photon number densities [cm-3]  -- dNp is new value"
  write(ilun,format)"  ! Fp      => NGROUPS * ndim photon fluxes [cm-2 s-1] -- dFp is new value"
  write(ilun,format)"  ! p_gas   => ndim gas momenta [cm s-1 g cm-3]        --    dp_gas is new"
  write(ilun,format)"  ! dNpdt   =>  Op split increment in photon densities during dt"
  write(ilun,format)"  ! dFpdt   =>  Op split increment in photon flux magnitudes during dt"
  write(ilun,format)"  ! nH      =>  Hydrogen number densities [cm-3]"
  write(ilun,format)"  ! c_switch=>  Cooling switch (1 for cool/heat, 0 for no cool/heat)"
  write(ilun,format)"  ! Zsolar  =>  Cell metallicities [solar fraction]"
  write(ilun,format)"  ! dt      =>  Timestep size [s]"
  write(ilun,format)"  ! a_exp   =>  Cosmic expansion"
  write(ilun,format)"  ! dt_ok   <=  .f. if timestep constraints were broken, .t. otherwise"
  write(ilun,format)"  ! dt_rec  <=  Recommended timesteps for next iteration"
  write(ilun,format)"  ! code    <= Error code in cool step, if dt_ok=.f."
  write(ilun,format)"  !"
  write(ilun,format)"  ! The original values, T2, xion etc, must stay unchanged, while dT2,"
  write(ilun,format)"  ! dxion etc contain the new values (the difference at the end of the"
  write(ilun,format)"  ! routine)."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"    use amr_commons"
  write(ilun,format)"    use rt_metal_cooling_module"
  write(ilun,format)"    use const"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    integer, intent(in)::icell"
  write(ilun,format)"    real(dp),dimension(nDim),save:: dmom"
  write(ilun,format)"    real(dp),dimension(nIons),save:: alpha, beta, nN, nI"
  write(ilun,format)"    real(dp),save:: dUU, fracMax"
  write(ilun,format)"    real(dp),save:: xHeI, mu=1., TK, nHe, ne, neInit, Hrate, dAlpha, dBeta"
  write(ilun,format)"    real(dp),save:: s, jac, Crate, dCdT2, X_nHkb, rate, dRate, cr, de"
  write(ilun,format)"    real(dp),save:: photoRate, metal_tot,metal_prime, ss_factor"
  write(ilun,format)"    integer,save:: iion,igroup,idim"
  write(ilun,format)"    real(dp),dimension(nGroups),save:: recRad, phAbs, phSc, dustAbs"
  write(ilun,format)"    real(dp),dimension(nGroups),save:: dustSc, kAbs_loc,kSc_loc"
  write(ilun,format)"    real(dp),save:: rho, TR, one_over_C_v, E_rad, dE_T, fluxMag, mom_fact"
  write(ilun,format)"    !---------------------------------------------------------------------"
  write(ilun,format)"    dt_ok=.false."
  write(ilun,format)"    nHe=0.25*nH(icell)*Y/X  !         Helium number density"
  write(ilun,format)"    ! U contains the original values, dU the updated ones:"
  write(ilun,format)"    dT2=T2(icell) ; dXion(:)=xion(:,icell) ; dNp(:)=Np(:,icell)"
  write(ilun,format)"    dFp(:,:)=Fp(:,:,icell) ; dp_gas(:)=p_gas(:,icell)"
  write(ilun,format)"    ! xHI = MAX(1.-dXion(1),0.) ; xHII = dXion(1)"
  write(ilun,format)"    ! xHeII=dXion(2) ; xHeIII=dXion(3)"
  write(ilun,format)"    xHeI=MAX(1.-dXion(2)-dXion(3),0.d0)"
  write(ilun,format)"    ! nN='neutral' species (pre-ionized), nI=their ionized counterparts"
  write(ilun,format)"    nN(1)  = nH(icell) * (1.d0-dXion(1))                         !     nHI"
  write(ilun,format)"    nN(2)  = nHe*xHeI                                            !    nHeI"
  write(ilun,format)"    nN(3)  = nHe*dXion(2)                                        !   nHeII"
  write(ilun,format)"    nI(1)  = nH(icell) *dXion(1)                                 !    nHII"
  write(ilun,format)"    nI(2)  = nN(3)                                               !   nHeII"
  write(ilun,format)"    nI(3)  = nHe*dXion(3)                                        !  nHeIII"
  write(ilun,format)"    mu = getMu(dXion(1), dXion(2), dXion(3), dT2)"
  write(ilun,format)"    TK = dT2 * mu                                           !  Temperature"
  write(ilun,format)"    if(rt_isTconst) TK=rt_Tconst                       !  Force constant T"
  write(ilun,format)"    ne= nH(icell)*dXion(1)+nHE*(dXion(2)+2.*dXion(3))  !  Electron density"
  write(ilun,format)"    neInit=ne"
  write(ilun,format)"    fracMax=0d0   ! Max fractional update, to check if dt can be increased"
  write(ilun,format)"    ss_factor=1d0                    ! UV background self_shielding factor"
  write(ilun,format)"    if(self_shielding) ss_factor = exp(-nH(icell)/1d-2)"
  write(ilun,format)""
  write(ilun,format)"    rho = nH(icell) / X * mH"
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"    ! Set dust opacities--------------------------------------------------"
  write(ilun,format)"    if(rt .and. nGroups .gt. 0) then"
  write(ilun,format)"       kAbs_loc = kappaAbs"
  write(ilun,format)"       kSc_loc  = kappaSc"
  write(ilun,format)"       if(is_kIR_T) then                           ! k_IR depends on T_rad"
  write(ilun,format)"          ! For the radiation temperature,  weigh the energy in each group"
  write(ilun,format)"          ! by its opacity over IR opacity (derived from IR temperature)"
  write(ilun,format)"          E_rad = group_egy_erg(iIR) * dNp(iIR)"
  write(ilun,format)"          TR = max(0d0,(E_rad*rt_c_fraction/a_r)**0.25)   ! IR temperature"
  write(ilun,format)"          kAbs_loc(iIR) = kappaAbs(iIR) * (TR/10d0)**2"
  write(ilun,format)"          do iGroup=1,nGroups"
  write(ilun,format)"             if(i .ne. iIR)                                              &"
  write(ilun,format)"                  E_rad = E_rad + kAbs_loc(iGroup) / kAbs_loc(iIR)       &"
  write(ilun,format)"                                * group_egy_erg(iGroup) * dNp(iGroup)"
  write(ilun,format)"          end do"
  write(ilun,format)"          TR = max(0d0,(E_rad*rt_c_fraction/a_r)**0.25) ! Rad. temperature"
  write(ilun,format)"          if(rt_T_rad) then ! Use radiation temperature for everything"
  write(ilun,format)"             dT2 = TR/mu ;   TK = TR"
  write(ilun,format)"          endif"
  write(ilun,format)"          kAbs_loc(iIR) = kappaAbs(iIR) * (TK/10d0)**2 * exp(-TR/2d3)"
  write(ilun,format)"          kSc_loc(iIR)  = kappaSc(iIR)  * (TK/10d0)**2 * exp(-TR/2d3)"
  write(ilun,format)"!!           ! Romain master version"
  write(ilun,format)"!!           ! Set the IR opacities according to the rad. temperature:"
  write(ilun,format)"!!           kAbs_loc(iIR) = kappaAbs(iIR) * (TR/10d0)**2 * exp(-TR/1d3)"
  write(ilun,format)"!!           kSc_loc(iIR)  = kappaSc(iIR)  * (TR/10d0)**2 * exp(-TR/1d3)"
  write(ilun,format)"       endif"
  write(ilun,format)"       ! Set dust absorption and scattering rates [s-1]:"
  write(ilun,format)"       dustAbs(:)  = kAbs_loc(:) *rho*Zsolar(icell)*rt_c_cgs"
  write(ilun,format)"       dustSc(iIR) = kSc_loc(iIR)*rho*Zsolar(icell)*rt_c_cgs"
  write(ilun,format)"!       if(myid==1) write(*,*) 'kabsloc, dustabs, kscloc, dustsc: ', kAbs_loc, dustAbs, kSc_loc, dustSc"
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)"    !(i) UPDATE PHOTON DENSITY AND FLUX **********************************"
  write(ilun,format)"    if(rt .and. rt_advect) then"
  write(ilun,format)"       recRad(1:nGroups)=0. ; phAbs(1:nGroups)=0."
  write(ilun,format)"       ! Scattering rate; reduce the photon flux, but not photon density:"
  write(ilun,format)"       phSc(1:nGroups)=0."
  write(ilun,format)""
  write(ilun,format)"       ! EMISSION FROM GAS"
  write(ilun,format)"       if(.not. rt_OTSA .and. rt_advect) then ! ----------- Rec. radiation"
  write(ilun,format)"          alpha(1) = inp_coolrates_table(tbl_alphaA_HII, TK) &"
  write(ilun,format)"                   - inp_coolrates_table(tbl_alphaB_HII, TK)"
  write(ilun,format)"          ! alpha(2) A-B becomes negative around 1K, hence the max"
  write(ilun,format)"          alpha(2) = MAX(0.d0,  inp_coolrates_table(tbl_alphaA_HeII, TK) &"
  write(ilun,format)"                              - inp_coolrates_table(tbl_alphaB_HeII, TK))"
  write(ilun,format)"          alpha(3) = inp_coolrates_table(tbl_alphaA_HeIII, TK) &"
  write(ilun,format)"                   - inp_coolrates_table(tbl_alphaB_HeIII, TK)"
  write(ilun,format)"          do iion=1,nIons"
  write(ilun,format)"             if(spec2group(iion) .gt. 0) &  ! Contribution of ion -> group"
  write(ilun,format)"                  recRad(spec2group(iion)) = &"
  write(ilun,format)"                  recRad(spec2group(iion)) + alpha(iion) * nI(iion) * ne"
  write(ilun,format)"          enddo"
  write(ilun,format)"       endif"
  write(ilun,format)""
  write(ilun,format)"       ! ABSORPTION/SCATTERING OF PHOTONS BY GAS"
  write(ilun,format)"       do igroup=1,nGroups      ! -------------------Ionization absorbtion"
  write(ilun,format)"          phAbs(igroup) = SUM(nN(:)*signc(igroup,:)) ! s-1"
  write(ilun,format)"       end do"
  write(ilun,format)"       ! IR, optical and UV depletion by dust absorption: ----------------"
  write(ilun,format)"       if(rt_isIR) & !IR scattering/abs on dust (abs after T update)"
  write(ilun,format)"            phSc(iIR)  = phSc(iIR) + dustSc(iIR)"
  write(ilun,format)"       "
  write(ilun,format)"       do igroup=1,nGroups        ! Deplete photons, since they go into IR"
  write(ilun,format)"          if( .not. (rt_isIR .and. igroup.eq.iIR) ) &  ! IR done elsewhere"
  write(ilun,format)"               !write(*,*) 'phabs,dustabs, phsc, dustsc: ', phAbs(igroup), dustAbs(igroup), phSc(igroup),dustSc(igroup)"
  write(ilun,format)"               phAbs(igroup) = phAbs(igroup) + dustAbs(igroup)"
  write(ilun,format)"               phSc(igroup)  = phSc(igroup) + dustSc(igroup)!+ 1d3*rho*rt_c_cgs ! Mie scattering rate in s-1"
  write(ilun,format)"               ! changer constante de scattering par planck mean of kappa scatt"
  write(ilun,format)"       end do"
  write(ilun,format)""
  write(ilun,format)"       dmom(1:nDim)=0d0"
  write(ilun,format)"       do igroup=1,nGroups  ! ------------------- Do the update of N and F"
  write(ilun,format)"          dNp(igroup)= MAX(smallNp,                                      &"
  write(ilun,format)"                        (ddt(icell)*(recRad(igroup)+dNpdt(igroup,icell)) &"
  write(ilun,format)"                                    +dNp(igroup))                        &"
  write(ilun,format)"                        / (1.d0+ddt(icell)*phAbs(igroup)))"
  write(ilun,format)""
  write(ilun,format)"          dUU = ABS(dNp(igroup)-Np(igroup,icell))                        &"
  write(ilun,format)"                /(Np(igroup,icell)+Np_MIN) * one_over_Np_FRAC"
  write(ilun,format)"          if(dUU .gt. 1.d0) then"
  write(ilun,format)"             code=1 ;   RETURN                        ! ddt(icell) too big"
  write(ilun,format)"          endif"
  write(ilun,format)"          fracMax=MAX(fracMax,dUU)      ! To check if ddt can be increased"
  write(ilun,format)""
  write(ilun,format)"          do idim=1,nDim"
  write(ilun,format)"             dFp(idim,igroup) = &"
  write(ilun,format)"                  (ddt(icell)*dFpdt(idim,igroup,icell)+dFp(idim,igroup)) &"
  write(ilun,format)"                  /(1d0+ddt(icell)*(phAbs(igroup)+phSc(igroup)))"
  write(ilun,format)"          end do"
  write(ilun,format)"          call reduce_flux(dFp(:,igroup),dNp(igroup)*rt_c_cgs)"
  write(ilun,format)""
  write(ilun,format)"          do idim=1,nDim"
  write(ilun,format)"             dUU = ABS(dFp(idim,igroup)-Fp(idim,igroup,icell))           &"
  write(ilun,format)"                  / (ABS(Fp(idim,igroup,icell))+Fp_MIN) * one_over_Fp_FRAC"
  write(ilun,format)"             if(dUU .gt. 1.d0) then"
  write(ilun,format)"                code=2 ;   RETURN                     ! ddt(icell) too big"
  write(ilun,format)"             endif"
  write(ilun,format)"             fracMax=MAX(fracMax,dUU)   ! To check if ddt can be increased"
  write(ilun,format)"          end do"
  write(ilun,format)""
  write(ilun,format)"       end do"
  write(ilun,format)""
  write(ilun,format)"       do igroup=1,nGroups ! -------Momentum transfer from photons to gas:"
  write(ilun,format)"          mom_fact = ddt(icell) * (phAbs(igroup) + phSc(igroup)) &"
  write(ilun,format)"               * group_egy_erg(igroup) * one_over_c_cgs"
  write(ilun,format)""
  write(ilun,format)"          if(rt_isoPress .and. .not. (rt_isIR .and. igroup==iIR)) then"
  write(ilun,format)"             ! rt_isoPress: assume f=1, where f is reduced flux."
  write(ilun,format)"             fluxMag=sqrt(sum((dFp(:,igroup))**2))"
  write(ilun,format)"             if(fluxMag .gt. 0d0) then"
  write(ilun,format)"                mom_fact = mom_fact * dNp(igroup) / fluxMag"
  write(ilun,format)"             else"
  write(ilun,format)"                mom_fact = 0d0"
  write(ilun,format)"             endif"
  write(ilun,format)"          else"
  write(ilun,format)"             mom_fact = mom_fact * one_over_rt_c_cgs"
  write(ilun,format)"          end if"
  write(ilun,format)""
  write(ilun,format)"          do idim = 1, nDim"
  write(ilun,format)"             dmom(idim) = dmom(idim) + dFp(idim,igroup) * mom_fact"
  write(ilun,format)"          end do"
  write(ilun,format)"       end do"
  write(ilun,format)"       dp_gas = dp_gas + dmom * rt_pressBoost        ! update gas momentum"
  write(ilun,format)""
  write(ilun,format)"       ! Add absorbed UV/optical energy to IR:----------------------------"
  write(ilun,format)"       if(rt_isIR) then"
  write(ilun,format)"          do igroup=iIR+1,nGroups"
  write(ilun,format)"             dNp(iIR) = dNp(iIR) + dustAbs(igroup) * ddt(icell)          &"
  write(ilun,format)"                  * dNp(igroup) * group_egy_ratio(igroup)"
  write(ilun,format)"          end do"
  write(ilun,format)"       endif"
  write(ilun,format)"       ! -----------------------------------------------------------------"
  write(ilun,format)"    endif !if(rt)"
  write(ilun,format)"#endif"
  write(ilun,format)"    !(ii) UPDATE TEMPERATURE *********************************************"
  write(ilun,format)"    if(c_switch(icell) .and. cooling .and. .not. rt_T_rad) then"
  write(ilun,format)"       Hrate=0.                             !  Heating rate [erg cm-3 s-1]"
  write(ilun,format)"       if(rt .and. rt_advect) then"
  write(ilun,format)"          do igroup=1,nGroups                              !  Photoheating"
  write(ilun,format)"             Hrate = Hrate + dNp(igroup) * SUM(nN(:) * PHrate(igroup,:))"
  write(ilun,format)"          end do"
  write(ilun,format)"       endif"
  write(ilun,format)"       if(haardt_madau) Hrate= Hrate + SUM(nN(:)*UVrates(:,2)) * ss_factor"
  write(ilun,format)"       Crate = compCoolrate(TK,ne,nN(1),nI(1),nN(2),nN(3),nI(3),dCdT2)"
  write(ilun,format)"       dCdT2 = dCdT2 * mu                            ! dC/dT2 = mu * dC/dT"
  write(ilun,format)"       metal_tot=0.d0 ; metal_prime=0.d0             ! Metal cooling"
  write(ilun,format)"       Zsolar(icell) = 1d0 ! HACK"
  write(ilun,format)"       !if(Zsolar(icell) .gt. 0d0) &"
  write(ilun,format)"       !     call rt_cmp_metals(T2(icell),nH(icell),mu,metal_tot          &"
  write(ilun,format)"       !                       ,metal_prime,a_exp)"
  write(ilun,format)"       call rt_metal_cool(T2(icell),nH(icell),dXion(1),mu,metal_tot,metal_prime)"
  write(ilun,format)"       X_nHkb= X/(1.5 * nH(icell) * kB)            ! Multiplication factor   "
  write(ilun,format)"       rate  = X_nHkb*(Hrate - Crate - Zsolar(icell)*metal_tot)"
  write(ilun,format)"       dRate = -X_nHkb*(dCdT2 + Zsolar(icell)*metal_prime)     ! dRate/dT2"
  write(ilun,format)"       ! 1st order dt constr"
  write(ilun,format)"       dUU   = ABS(MAX(T2_min_fix, T2(icell)+rate*ddt(icell))-T2(icell))"
  write(ilun,format)"       ! New T2 value"
  write(ilun,format)"       dT2   = MAX(T2_min_fix &"
  write(ilun,format)"                  ,T2(icell)+rate*ddt(icell)/(1.-dRate*ddt(icell)))"
  write(ilun,format)"       dUU   = MAX(dUU, ABS(dT2-T2(icell))) / (T2(icell)+T_MIN) &"
  write(ilun,format)"                        *one_over_T_FRAC"
  write(ilun,format)"       if(dUU .gt. 1.) then                                     ! 10% rule"
  write(ilun,format)"          code=3 ; RETURN"
  write(ilun,format)"       endif"
  write(ilun,format)"       fracMax=MAX(fracMax,dUU)"
  write(ilun,format)"       TK=dT2*mu"
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"    if(rt_isIR) then"
  write(ilun,format)"       if(kAbs_loc(iIR) .gt. 0d0 .and. .not. rt_T_rad) then"
  write(ilun,format)"          ! Evolve IR-Dust equilibrium temperature------------------------"
  write(ilun,format)"          ! Delta (Cv T)= ( c_red/lambda E - c/lambda a T^4)"
  write(ilun,format)"          !           / ( 1/Delta t + 4 c/lambda/C_v a T^3 + c_red/lambda)"
  write(ilun,format)"          one_over_C_v = mh*mu*(gamma-1d0) / (rho*kb)"
  write(ilun,format)"          E_rad = group_egy_erg(iIR) * dNp(iIR)"
  write(ilun,format)"          dE_T = (rt_c_cgs * E_rad - c_cgs*a_r*TK**4)                    &"
  write(ilun,format)"               /(1d0/(kAbs_loc(iIR) * Zsolar(icell) * rho * ddt(icell))  &"
  write(ilun,format)"               +4d0*c_cgs * one_over_C_v *a_r*TK**3+rt_c_cgs)"
  write(ilun,format)"          dT2 = dT2 + 1d0/mu * one_over_C_v * dE_T"
  write(ilun,format)"          dNp(iIR) = dNp(iIR) - dE_T * one_over_egy_IR_erg"
  write(ilun,format)""
  write(ilun,format)"          dT2 = max(T2_min_fix,dT2)"
  write(ilun,format)"          dNp(iIR) = max(dNp(iIR), smallNp)"
  write(ilun,format)"          ! 10% rule for photon density:"
  write(ilun,format)"          dUU = ABS(dNp(iIR)-Np(iIR,icell)) / (Np(iIR,icell)+Np_MIN)     &"
  write(ilun,format)"                                            * one_over_Np_FRAC"
  write(ilun,format)"          if(dUU .gt. 1.) then"
  write(ilun,format)"             code=4 ;   RETURN"
  write(ilun,format)"          endif"
  write(ilun,format)"          fracMax=MAX(fracMax,dUU)"
  write(ilun,format)""
  write(ilun,format)"          dUU   = ABS(dT2-T2(icell)) / (T2(icell)+T_MIN) * one_over_T_FRAC"
  write(ilun,format)"          if(dUU .gt. 1.) then                           ! 10% rule for T2"
  write(ilun,format)"             code=5 ; RETURN"
  write(ilun,format)"          endif"
  write(ilun,format)"          fracMax=MAX(fracMax,dUU)"
  write(ilun,format)"          TK=dT2*mu"
  write(ilun,format)"          call reduce_flux(dFp(:,iIR),dNp(iIR)*rt_c_cgs)"
  write(ilun,format)"       endif"
  write(ilun,format)"    endif"
  write(ilun,format)"#endif"
  write(ilun,format)"    !(iii) UPDATE xHII****************************************************"
  write(ilun,format)"    ! First recompute interaction rates since T is updated"
  write(ilun,format)"    if(rt_OTSA .or. .not. rt_advect) then           !  Recombination rates"
  write(ilun,format)"       alpha(1) = inp_coolrates_table(tbl_alphaB_HII, TK, dalpha)"
  write(ilun,format)"    else"
  write(ilun,format)"       alpha(1) = inp_coolrates_table(tbl_alphaA_HII, TK, dalpha)"
  write(ilun,format)"    endif"
  write(ilun,format)"    beta(1) = inp_coolrates_table(tbl_beta_HI, TK, dBeta) !  Coll-ion rate"
  write(ilun,format)"    cr = beta(1) * ne                             !               Creation"
  write(ilun,format)"    if(rt) cr = cr + SUM(signc(:,1)*dNp)          !                  [s-1]"
  write(ilun,format)"    if(haardt_madau) cr = cr + UVrates(1,1) * ss_factor"
  write(ilun,format)"    de = alpha(1) * ne                            !            Destruction"
  write(ilun,format)""
  write(ilun,format)"    ! Not Anninos, but more stable (this IS neccessary, as the one-cell  !"
  write(ilun,format)"    ! tests oscillate wildly in the Anninos method):                     !"
  write(ilun,format)"    S  = cr*(1.-dXion(1))-de*dXion(1)"
  write(ilun,format)"    dUU= ABS(MIN(MAX(dXion(1)+ddt(icell)*S, x_MIN), 1.)-dXion(1))"
  write(ilun,format)"    jac=(1.-dXion(1))*(beta(1)*nH(icell)-ne*TK*mu*X*dBeta) & !jac=dS/dxHII"
  write(ilun,format)"         - cr - de - dXion(1) * (alpha(1)*nH(icell)-ne*TK*mu*X*dAlpha)"
  write(ilun,format)"    dXion(1) = xion(1,icell)                                             &"
  write(ilun,format)"             + ddt(icell)*(cr*(1.-xion(1,icell))-de*xion(1,icell))       &"
  write(ilun,format)"             / (1.-ddt(icell)*jac)"
  write(ilun,format)"    dXion(1) = MIN(MAX(dXion(1), x_MIN),1.d0)"
  write(ilun,format)"    dUU = MAX(dUU, ABS(dXion(1)-xion(1,icell))) / (xion(1,icell)+x_MIN)  &"
  write(ilun,format)"                                                * one_over_x_FRAC"
  write(ilun,format)"    if(dUU .gt. 1.) then"
  write(ilun,format)"       code=6 ; RETURN"
  write(ilun,format)"    endif"
  write(ilun,format)"    fracMax=MAX(fracMax,dUU)"
  write(ilun,format)"    !End a more stable and accurate integration---------------------------"
  write(ilun,format)"    if(isHe) then"
  write(ilun,format)"       ne= nH(icell)*dXion(1)+nHE*(dXion(2)+2.*dXion(3)) ! Bc changed xhii"
  write(ilun,format)"       mu = getMu(dXion(1), dXion(2), dXion(3), dT2)"
  write(ilun,format)"       if(.not. rt_isTconst) TK=dT2*mu !  Update TK because of changed  mu"
  write(ilun,format)""
  write(ilun,format)"       !(iv) UPDATE xHeI *************************************************"
  write(ilun,format)"       if(rt_OTSA .or. .not. rt_advect) then"
  write(ilun,format)"          alpha(2) = inp_coolrates_table(tbl_alphaB_HeII, TK)"
  write(ilun,format)"          alpha(3) = inp_coolrates_table(tbl_alphaB_HeIII, TK)"
  write(ilun,format)"       else"
  write(ilun,format)"          alpha(2) = inp_coolrates_table(tbl_alphaA_HeII, TK)"
  write(ilun,format)"          alpha(3) = inp_coolrates_table(tbl_alphaA_HeIII, TK)"
  write(ilun,format)"       endif"
  write(ilun,format)"       beta(2) =  inp_coolrates_table(tbl_beta_HeI, TK)"
  write(ilun,format)"       beta(3) = inp_coolrates_table(tbl_beta_HeII, TK)"
  write(ilun,format)"       ! Creation = recombination of HeII and electrons"
  write(ilun,format)"       cr = alpha(2) * ne * dXion(2)"
  write(ilun,format)"       ! Destruction = collisional ionization+photoionization of HeI"
  write(ilun,format)"       de = beta(2) * ne"
  write(ilun,format)"       if(rt) de = de + SUM(signc(:,2)*dNp)"
  write(ilun,format)"       if(haardt_madau) de = de + UVrates(2,1) * ss_factor"
  write(ilun,format)"       xHeI = (cr*ddt(icell)+xHeI)/(1.+de*ddt(icell))        !  The update"
  write(ilun,format)"       xHeI = MIN(MAX(xHeI, 0.),1.)"
  write(ilun,format)""
  write(ilun,format)"       !(v) UPDATE xHeII *************************************************"
  write(ilun,format)"       ! Creation = coll.- and photo-ionization of HI + rec. of HeIII"
  write(ilun,format)"       cr = de * xHeI + alpha(3) * ne * dXion(3)"
  write(ilun,format)"       ! Destruction = rec. of HeII + coll.- and photo-ionization of HeII"
  write(ilun,format)"       photoRate=0."
  write(ilun,format)"       if(rt) photoRate = SUM(signc(:,3)*dNp)"
  write(ilun,format)"       if(haardt_madau) photoRate = photoRate + UVrates(3,1) * ss_factor"
  write(ilun,format)"       de = (alpha(2) + beta(3)) * ne + photoRate"
  write(ilun,format)"       dXion(2) = (cr*ddt(icell)+dXion(2))/(1.+de*ddt(icell)) ! The update"
  write(ilun,format)"       dXion(2) = MIN(MAX(dXion(2), x_MIN),1.)"
  write(ilun,format)""
  write(ilun,format)"       !(vii) UPDATE xHeIII **********************************************"
  write(ilun,format)"       ! Creation = coll.- and photo-ionization of HeII"
  write(ilun,format)"       cr = (beta(3) * ne + photoRate) * dXion(2)          !  xHeII is new"
  write(ilun,format)"       ! Destruction = rec. of HeIII and e"
  write(ilun,format)"       de = alpha(3) * ne"
  write(ilun,format)"       dXion(3) = (cr*ddt(icell)+dXion(3))/(1.+de*ddt(icell)) ! The update"
  write(ilun,format)"       dXion(3) = MIN(MAX(dXion(3), x_MIN),1.)"
  write(ilun,format)""
  write(ilun,format)"       !(viii) ATOMIC CONSERVATION OF He *********************************"
  write(ilun,format)"       if(xHeI .ge. dXion(3)) then   ! Either HeI or HeII is most abundant"
  write(ilun,format)"          if(xHeI .le. dXion(2)) dXion(2) = 1.-xHeI-dXion(3) !HeII most ab"
  write(ilun,format)"       else                        ! Either HeII or HeIII is most abundant"
  write(ilun,format)"          if(dXion(2) .le. dXion(3)) then"
  write(ilun,format)"             dXion(3) = 1. - xHeI-dXion(2)                         ! HeIII"
  write(ilun,format)"          else"
  write(ilun,format)"             dXion(2) = 1. - xHeI-dXion(3)                         !  HeII"
  write(ilun,format)"          endif"
  write(ilun,format)"       endif"
  write(ilun,format)"    endif"
  write(ilun,format)""
  write(ilun,format)"    ne = nH(icell)*dXion(1)+nHe*(dXion(2)+2.*dXion(3))"
  write(ilun,format)"    dUU=ABS((ne-neInit)) / (neInit+x_MIN) * one_over_x_FRAC"
  write(ilun,format)"    if(dUU .gt. 1.) then"
  write(ilun,format)"       code=7 ; RETURN"
  write(ilun,format)"    endif"
  write(ilun,format)"    fracMax=MAX(fracMax,dUU)"
  write(ilun,format)""
  write(ilun,format)"    if(rt_isTconst) dT2=rt_Tconst/mu"
  write(ilun,format)""
  write(ilun,format)"    dT2 = dT2-T2(icell) ; dXion(:) = dXion(:)-xion(:,icell)"
  write(ilun,format)"    dNp(:) = dNp(:)-Np(:,icell) ; dFp(:,:) = dFp(:,:)-Fp(:,:,icell)"
  write(ilun,format)"    dp_gas(:)= dp_gas(:)-p_gas(:,icell)"
  write(ilun,format)"    ! Now the dUs are really changes, not new values"
  write(ilun,format)"    !(ix) Check if we are safe to use a bigger timestep in next iteration:"
  write(ilun,format)"    if(fracMax .lt. 0.5) then"
  write(ilun,format)"       dt_rec=ddt(icell)*2."
  write(ilun,format)"    else"
  write(ilun,format)"       dt_rec=ddt(icell)"
  write(ilun,format)"    endif"
  write(ilun,format)"    dt_ok=.true."
  write(ilun,format)"    code=0"
  write(ilun,format)""
  write(ilun,format)"  END SUBROUTINE cool_step"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE rt_solve_cooling"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE display_coolinfo(stopRun, loopcnt, i, dtDone, dt, ddt, nH    &"
  write(ilun,format)"                            ,T2,  xion,  Np,  Fp,  p_gas                &"
  write(ilun,format)"                            ,dT2, dXion, dNp, dFp, dp_gas, code)"
  write(ilun,format)"! Print cooling information to standard output, and maybe stop execution."
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  real(dp),dimension(nIons):: xion, dXion"
  write(ilun,format)"  real(dp),dimension(nGroups):: Np, dNp"
  write(ilun,format)"  real(dp),dimension(nDim, nGroups):: Fp, dFp"
  write(ilun,format)"  real(dp),dimension(nDim):: p_gas, dp_gas"
  write(ilun,format)"  real(dp)::T2, dT2, dtDone, dt, ddt, nH"
  write(ilun,format)"  logical::stopRun"
  write(ilun,format)"  integer::loopcnt,i, code"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  if(stopRun) write(*, 111) loopcnt"
  write(ilun,format)"  if(.true.) then"
  write(ilun,format)"     write(*,900) loopcnt, myid, code, i, dtDone, dt, ddt, rt_c_cgs, nH"
  write(ilun,format)"     write(*,901) T2,      xion,      Np,      Fp,      p_gas"
  write(ilun,format)"     write(*,902) dT2,     dXion,     dNp,     dFp,     dp_gas"
  write(ilun,format)"     write(*,903) dT2/ddt, dXion/ddt, dNp/ddt, dFp/ddt, dp_gas/ddt"
  write(ilun,format)"     write(*,904) abs(dT2)/(T2+T_MIN), abs(dxion)/(xion+x_MIN),          &"
  write(ilun,format)"                  abs(dNp)/(Np+Np_MIN), abs(dFp)/(Fp+Fp_MIN)"
  write(ilun,format)"  endif"
  write(ilun,format)"  print*,loopcodes"
  write(ilun,format)"  print*,group_egy(:)"
  write(ilun,format)"  if(stopRun) then"
  write(ilun,format)"     print *,'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX'"
  write(ilun,format)"     STOP"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"111 format(' Stopping because of large number of timestesps in', &"
  write(ilun,format)"           ' rt_solve_cooling (', I6, ')')"
  write(ilun,format)"900 format (I3, '  myid=', I2, ' code=', I2, ' i=', I5, ' t=', 1pe12.3,xs&"
  write(ilun,format)"            '/', 1pe12.3, ' ddt=', 1pe12.3, ' c=', 1pe12.3, &"
  write(ilun,format)"            ' nH=', 1pe12.3)"
  write(ilun,format)"901 format ('  U      =', 20(1pe12.3))"
  write(ilun,format)"902 format ('  dU     =', 20(1pe12.3))"
  write(ilun,format)"903 format ('  dU/dt  =', 20(1pe12.3))"
  write(ilun,format)"904 format ('  dU/U % =', 20(1pe12.3))"
  write(ilun,format)"END SUBROUTINE display_coolinfo"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE cmp_chem_eq(TK, nH, t_rad_spec, nSpec, nTot, mu)"
  write(ilun,format)""
  write(ilun,format)"! Compute chemical equilibrium abundances of e, HI, HII, HeI, HeII, HeIII"
  write(ilun,format)"! r_rad_spec => photoionization rates [s-1] for HI, HeI, HeII"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp),intent(in)::TK, nH"
  write(ilun,format)"  real(dp),intent(out)::nTot, mu"
  write(ilun,format)"  real(dp),dimension(1:3),intent(in)::t_rad_spec"
  write(ilun,format)"  real(dp),dimension(1:6),intent(out)::nSpec!------------------------"
  write(ilun,format)"  real(dp)::xx, yy"
  write(ilun,format)"  real(dp)::n_HI, n_HII, n_HEI, n_HEII, n_HEIII, n_E"
  write(ilun,format)"  real(dp)::t_rad_HI,  t_rad_HEI,  t_rad_HEII"
  write(ilun,format)"  real(dp)::t_rec_HI,  t_rec_HEI,  t_rec_HEII"
  write(ilun,format)"  real(dp)::t_ion_HI,  t_ion_HEI,  t_ion_HEII"
  write(ilun,format)"  real(dp)::t_ion2_HI, t_ion2_HEI, t_ion2_HEII"
  write(ilun,format)"  real(dp)::x1, err_nE"
  write(ilun,format)"  integer,parameter::HI=1, HeI=2, HeII=3"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  xx=(1.-Y)"
  write(ilun,format)"  yy=Y/(1.-Y)/4."
  write(ilun,format)""
  write(ilun,format)"  t_rad_HI   = t_rad_spec(HI)                !      Photoionization [s-1]"
  write(ilun,format)"  t_rad_HEI  = t_rad_spec(HeI)"
  write(ilun,format)"  t_rad_HEII = t_rad_spec(HeII)"
  write(ilun,format)""
  write(ilun,format)"  if(rt_OTSA) then                           !    Recombination [cm3 s-1]"
  write(ilun,format)"     t_rec_HI   = inp_coolrates_table(tbl_alphaB_HII, TK)"
  write(ilun,format)"     t_rec_HEI  = inp_coolrates_table(tbl_alphaB_HeII, TK)"
  write(ilun,format)"     t_rec_HEII = inp_coolrates_table(tbl_alphaB_HeIII, TK)"
  write(ilun,format)"  else"
  write(ilun,format)"     t_rec_HI   = inp_coolrates_table(tbl_alphaA_HII, TK)"
  write(ilun,format)"     t_rec_HEI  = inp_coolrates_table(tbl_alphaA_HeII, TK)"
  write(ilun,format)"     t_rec_HEII = inp_coolrates_table(tbl_alphaA_HeIII, TK)"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  t_ion_HI   = inp_coolrates_table(tbl_beta_HI, TK) ! Coll. ion. [cm3 s-1]"
  write(ilun,format)"  t_ion_HEI  = inp_coolrates_table(tbl_beta_HeI, TK)"
  write(ilun,format)"  t_ion_HEII = inp_coolrates_table(tbl_beta_HeII, TK)"
  write(ilun,format)""
  write(ilun,format)"  n_E = nH"
  write(ilun,format)"  err_nE = 1."
  write(ilun,format)""
  write(ilun,format)"  do while(err_nE > 1.d-8)"
  write(ilun,format)"     t_ion2_HI   = t_ion_HI   + t_rad_HI  /MAX(n_E,1e-15*nH)  ! [cm3 s-1]"
  write(ilun,format)"     t_ion2_HEI  = t_ion_HEI  + t_rad_HEI /MAX(n_E,1e-15*nH)"
  write(ilun,format)"     t_ion2_HEII = t_ion_HEII + t_rad_HEII/MAX(n_E,1e-15*nH)"
  write(ilun,format)""
  write(ilun,format)"     n_HI  = t_rec_HI/(t_ion2_HI+t_rec_HI)*nH"
  write(ilun,format)"     n_HII = t_ion2_HI/(t_ion2_HI+t_rec_HI)*nH"
  write(ilun,format)""
  write(ilun,format)"     x1=(                                                                &"
  write(ilun,format)"          t_rec_HEII*t_rec_HEI                                           &"
  write(ilun,format)"          +t_ion2_HEI*t_rec_HEII                                         &"
  write(ilun,format)"          +t_ion2_HEII*t_ion2_HEI)                               ! cm6 s-2"
  write(ilun,format)""
  write(ilun,format)"     n_HEIII = yy*t_ion2_HEII*t_ion2_HEI/x1*nH"
  write(ilun,format)"     n_HEII  = yy*t_ion2_HEI *t_rec_HEII/x1*nH"
  write(ilun,format)"     n_HEI   = yy*t_rec_HEII *t_rec_HEI /x1*nH"
  write(ilun,format)""
  write(ilun,format)"     err_nE = ABS((n_E - (n_HII + n_HEII + 2.*n_HEIII))/nH)"
  write(ilun,format)"     n_E = 0.5*n_E+0.5*(n_HII + n_HEII + 2.*n_HEIII)"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  nTOT     = n_E+n_HI+n_HII+n_HEI+n_HEII+n_HEIII"
  write(ilun,format)"  mu       = nH/xx/nTOT"
  write(ilun,format)"  nSpec(1) = n_E"
  write(ilun,format)"  nSpec(2) = n_HI"
  write(ilun,format)"  nSpec(3) = n_HII"
  write(ilun,format)"  nSpec(4) = n_HEI"
  write(ilun,format)"  nSpec(5) = n_HEII"
  write(ilun,format)"  nSpec(6) = n_HEIII"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE cmp_chem_eq"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"SUBROUTINE rt_evol_single_cell(astart,aend,dasura,h,omegab,omega0,omegaL &"
  write(ilun,format)"     & ,T2end,mu,ne,if_write_result)"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"! Used for initialization of thermal state in cosmological simulations."
  write(ilun,format)"!"
  write(ilun,format)"! astart : valeur du facteur d'expansion au debut du calcul"
  write(ilun,format)"! aend   : valeur du facteur d'expansion a la fin du calcul"
  write(ilun,format)"! dasura : la valeur de da/a entre 2 pas de temps"
  write(ilun,format)"! h      : la valeur de H0/100"
  write(ilun,format)"! omegab : la valeur de Omega baryons"
  write(ilun,format)"! omega0 : la valeur de Omega matiere (total)"
  write(ilun,format)"! omegaL : la valeur de Omega Lambda"
  write(ilun,format)"! T2end  : Le T/mu en output"
  write(ilun,format)"! mu     : le poids moleculaire en output"
  write(ilun,format)"! ne     : le ne en output"
  write(ilun,format)"! if_write_result : .true. pour ecrire l'evolution de la temperature"
  write(ilun,format)"!          et de n_e sur l'ecran."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8)::astart,aend,T2end,h,omegab,omega0,omegaL,ne,dasura"
  write(ilun,format)"  logical :: if_write_result"
  write(ilun,format)"  real(dp)::aexp,daexp=0.,dt_cool,T2_com, nH_com  "
  write(ilun,format)"  real(dp),dimension(nIons)::pHI_rates=0."
  write(ilun,format)"  real(kind=8) ::mu"
  write(ilun,format)"  real(dp) :: mu_dp"
  write(ilun,format)"  real(dp) :: n_spec(1:6)"
  write(ilun,format)"  real(dp),dimension(1:nvector):: T2"
  write(ilun,format)"  real(dp),dimension(1:nIons, 1:nvector):: xion"
  write(ilun,format)"  real(dp),dimension(1:nGroups, 1:nvector):: Np, dNpdt"
  write(ilun,format)"  real(dp),dimension(1:ndim, 1:nGroups, 1:nvector):: Fp, dFpdt"
  write(ilun,format)"  real(dp),dimension(1:ndim, 1:nvector):: p_gas"
  write(ilun,format)"  real(dp),dimension(1:nvector)::nH=0., Zsolar=0."
  write(ilun,format)"  logical,dimension(1:nvector)::c_switch=.true."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  aexp = astart"
  write(ilun,format)"  T2_com = 2.726d0 / aexp * aexp**2 / mu_mol"
  write(ilun,format)"  nH_com = omegab*rhoc*h**2*X/mH"
  write(ilun,format)""
  write(ilun,format)"  mu_dp = mu"
  write(ilun,format)"  call cmp_Equilibrium_Abundances( &"
  write(ilun,format)"       & T2_com/aexp**2, nH_com/aexp**3, pHI_rates, mu_dp, n_Spec)"
  write(ilun,format)"  ! Initialize cell state"
  write(ilun,format)"  T2(1)=T2_com                                          !      Temperature"
  write(ilun,format)"  xion(1,1)=n_Spec(3)/(nH_com/aexp**3)                  !   HII   fraction"
  write(ilun,format)"  xion(2,1)=n_Spec(5)/(nH_com/aexp**3)                  !   HeII  fraction"
  write(ilun,format)"  xion(3,1)=n_Spec(6)/(nH_com/aexp**3)                  !   HeIII fraction"
  write(ilun,format)"  p_gas(:,1)=0."
  write(ilun,format)"  Np(:,1)=0. ; Fp(:,:,1)=0.                  ! Photon densities and fluxes"
  write(ilun,format)"  dNpdt(:,1)=0. ; dFpdt(:,:,1)=0."
  write(ilun,format)"  do while (aexp < aend)"
  write(ilun,format)"     call update_UVrates(aexp)"
  write(ilun,format)"     call update_coolrates_tables(aexp)"
  write(ilun,format)""
  write(ilun,format)"     daexp = dasura*aexp"
  write(ilun,format)"     dt_cool = daexp                                                     &"
  write(ilun,format)"             / (aexp*100.*h*3.2408608e-20)                               &"
  write(ilun,format)"             / HsurH0(1.0/dble(aexp)-1.,omega0,omegaL,1.-omega0-omegaL)"
  write(ilun,format)""
  write(ilun,format)"     nH(1) = nH_com/aexp**3"
  write(ilun,format)"     T2(1) = T2(1)/aexp**2"
  write(ilun,format)"     call rt_solve_cooling(T2,xion,Np,Fp,p_gas,dNpdt,dFpdt,nH,c_switch   &"
  write(ilun,format)"                           ,Zsolar,dt_cool,aexp,1)"
  write(ilun,format)"     T2(1)=T2(1)*aexp**2"
  write(ilun,format)"     aexp = aexp + daexp"
  write(ilun,format)"     if (if_write_result) write(*,'(4(1pe10.3))')                        &"
  write(ilun,format)"                              aexp,nH(1),T2_com*mu/aexp**2,n_spec(1)/nH(1)"
  write(ilun,format)"  end do"
  write(ilun,format)"  T2end=T2(1)/(aexp-daexp)**2"
  write(ilun,format)"  ne=(n_spec(3)+(n_spec(5)+2.*n_spec(6))*0.25*Y/X)"
  write(ilun,format)"end subroutine rt_evol_single_cell"
  write(ilun,format)""
  write(ilun,format)"!XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
  write(ilun,format)"FUNCTION HsurH0(z,omega0,omegaL,OmegaR)"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8) :: HsurH0,z,omega0,omegaL,omegaR"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  HsurH0=sqrt(Omega0*(1.d0+z)**3+OmegaR*(1.d0+z)**2+OmegaL)"
  write(ilun,format)"END FUNCTION HsurH0"
  write(ilun,format)""
  write(ilun,format)"! NOTE - rt_cmp_metals HACKED FROM HERE TO rt_metal_cooling_module"
  write(ilun,format)"!        TO PREVENT CIRCULAR MODULE USE"
  write(ilun,format)""
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"FUNCTION getMu(xHII, xHeII, xHeIII, Tmu)"
  write(ilun,format)"! Returns the mean particle mass, in units of the proton mass."
  write(ilun,format)"! xHII, xHeII, xHeIII => Hydrogen and helium ionisation fractions"
  write(ilun,format)"! Tmu => T/mu in Kelvin"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(kind=8),intent(in) :: xHII, xHeII, xHeIII, Tmu"
  write(ilun,format)"  real(kind=8) :: getMu"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  getMu = 1./(X*(1.+xHII) + 0.25*Y*(1.+xHeII+2.*xHeIII))"
  write(ilun,format)"  if(is_kIR_T .or. is_mu_H2) &"
  write(ilun,format)"       getMu = getMu + exp(-1.d0*(Tmu/Tmu_dissoc)**2) * (2.33-getMu)"
  write(ilun,format)"END FUNCTION getMu"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"END MODULE rt_cooling_module"
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE updateRTGroups_CoolConstants()"
  write(ilun,format)"! Update photon group cooling and heating constants, to reflect an update"
  write(ilun,format)"! in rt_c_cgs and in the cross-sections and energies in the groups."
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use rt_cooling_module"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::iP, iI"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  signc=group_csn*rt_c_cgs                                    ! [cm3 s-1]"
  write(ilun,format)"  sigec=group_cse*rt_c_cgs                                    ! [cm3 s-1]"
  write(ilun,format)"  do iP=1,nGroups"
  write(ilun,format)"     do iI=1,nIons               ! Photoheating rates for photons on ions"
  write(ilun,format)"        PHrate(iP,iI) =  ev_to_erg * &        ! See eq (19) in Aubert(08)"
  write(ilun,format)"             (sigec(iP,iI) * group_egy(iP) - signc(iP,iI)*ionEvs(iI))"
  write(ilun,format)"        PHrate(iP,iI) = max(PHrate(iP,iI),0d0) !      No negative heating"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"END SUBROUTINE updateRTGroups_CoolConstants"
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE reduce_flux(Fp, cNp)"
  write(ilun,format)"! Make sure the reduced photon flux is less than one"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp),dimension(ndim):: Fp"
  write(ilun,format)"  real(dp):: cNp, fred"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  fred = sqrt(sum(Fp**2))/cNp"
  write(ilun,format)"  if(fred .gt. 1.d0) Fp = Fp/fred"
  write(ilun,format)"END SUBROUTINE reduce_flux"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"../patch/irradiation/test_pascucci/rt_init.f90"
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"SUBROUTINE rt_init"
  write(ilun,format)""
  write(ilun,format)"!  Initialize everything for radiative transfer"
  write(ilun,format)"!  Some initialisation is also needed in case of non-equilibrium"
  write(ilun,format)"!  chemistry, even if rt=.false."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module,only:rt_protostar_m1"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  use rt_flux_module"
  write(ilun,format)"  use rt_cooling_module,only:rt_isIRtrap,iIRtrapVar"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer:: i, nvar_count"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  if(verbose)write(*,*)'Entering init_rt'"
  write(ilun,format)"  ! Count the number of variables and check if ok:"
  write(ilun,format)"!  nvar_count = ichem-1     ! # of non-rt vars: rho u v w p (z) (delay) (x)"
  write(ilun,format)"  if(rt_isIRtrap) &"
  write(ilun,format)"     iIRtrapVar = inener+ncr  ! Trapped rad. stored in nonthermal pressure var, but after cosmic rays energy densities"
  write(ilun,format)"!  iIons=nvar_count+1         !      Starting index of ionisation fractions"
  write(ilun,format)"!  nvar_count = nvar_count+3  !                                # hydro vars"
  write(ilun,format)""
  write(ilun,format)"  !simplify a bit... nvar_count is not used"
  write(ilun,format)"  iIons = ichem "
  write(ilun,format)""
  write(ilun,format)"!!note be vary careful with the variables allocation"
  write(ilun,format)"!! for now it is assumed that"
  write(ilun,format)"!! 1  is density"
  write(ilun,format)"!! 2:4 velocity"
  write(ilun,format)"!! 5 pressure"
  write(ilun,format)"!! 6:8 magnetic field"
  write(ilun,format)"!! 9:9+ncr : cosmic rays energy density (ncr groups of energy)     "
  write(ilun,format)"!! 9+ncr:9+nener : trapped photons (look at definitions in mhd/read_hydro_param)"
  write(ilun,format)"!! 9+nener9+nener+1:9+nener+nextinct : for extinction (look at definition of firstindex_pscal in mhd/read_hydro_param)"
  write(ilun,format)"!! 9+nener+nextinct+1 : 9+nener+nextinct+1+nions : the ions (rt_init, cooling_fine) "
  write(ilun,format)"!! note defined through imetal=firstindex_pscal+1 in read_hydro_param then idelay=imetal ixion=idelay ichem=ixion "
  write(ilun,format)"!! then in rt_init nvar_count=ichem-1 and iIons = nvar_count+1 (this is terrible, I know....)"
  write(ilun,format)"!! nvar-4:nvar-1 : current (used in godfine1 if IMHD==1) unew(....,nvar-4+idim)"
  write(ilun,format)"!! nvar-1:nvar : internal energy used in set_uold if (energy_fix)"
  write(ilun,format)""
  write(ilun,format)"!if you want to add your own scalar this has to be done between : "
  write(ilun,format)"!9+nener+nextinct+1+nions+1 and nvar-4"
  write(ilun,format)""
  write(ilun,format)"!then do not forget that within the code the magnetic variables are duplicated and stored"
  write(ilun,format)"!nvar+1:nvar+3"
  write(ilun,format)""
  write(ilun,format)"!finally note that ichem, idelay and imetal have not been checked carefully"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!!this part is completely out of date"
  write(ilun,format)"!  if(nvar_count .gt. nvar) then "
  write(ilun,format)"!     if(myid==1) then "
  write(ilun,format)"!        write(*,*) 'rt_init(): Something wrong with NVAR.'"
  write(ilun,format)"!        write(*,*) 'Should have NVAR=2+ndim+1*metal+1*dcool+1*aton+IRtrap+nIons'"
  write(ilun,format)"!        write(*,*) 'ndim ',ndim, ' metal ',metal , ' dcool ',dcool , ' aton ', aton , 'IRtrap ', IRtrap , ' nIons ',nIons"
  write(ilun,format)"!        write(*,*) 'Have NVAR=',nvar"
  write(ilun,format)"!        write(*,*) 'Should have NVAR=',nvar_count"
  write(ilun,format)"!        write(*,*) 'STOPPING!'"
  write(ilun,format)"!     endif"
  write(ilun,format)"!     call clean_stop"
  write(ilun,format)"!  endif"
  write(ilun,format)""
  write(ilun,format)"  if(rt_star .or. sedprops_update .ge. 0) &"
  write(ilun,format)"     call init_SED_table    ! init stellar energy distribution properties"
  write(ilun,format)""
  write(ilun,format)"  if(rt .and. .not. hydro) then"
  write(ilun,format)"     if(myid==1) then"
  write(ilun,format)"        write(*,*) 'hydro must be turned on when running radiative transfer.'"
  write(ilun,format)"        write(*,*) 'STOPPING!'"
  write(ilun,format)"     endif"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  endif"
  write(ilun,format)"  if(rt_star) use_proper_time=.true.    ! Need proper birth time for stars"
  write(ilun,format)"  if(rt) neq_chem=.true.        ! Equilibrium cooling doesn't work with RT"
  write(ilun,format)""
  write(ilun,format)"  ! To maximize efficiency, rt advection and rt timestepping is turned off"
  write(ilun,format)"  ! until needed."
  write(ilun,format)"  if(rt .and. .not.rt_otsa) rt_advect=.true."
  write(ilun,format)"  if(rt .and. rt_nsource .gt. 0) rt_advect=.true."
  write(ilun,format)"  if(rt .and. rt_nregion .gt. 0) rt_advect=.true."
  write(ilun,format)"  if(rt .and. rt_protostar_m1) rt_advect=.true."
  write(ilun,format)"  ! UV propagation is checked in set_model"
  write(ilun,format)"  ! Star feedback is checked in amr_step"
  write(ilun,format)""
  write(ilun,format)"  do i=1,nGroups  ! Starting indices in uold and unew of each photon group"
  write(ilun,format)"     iGroups(i)=1+(ndim+1)*(i-1)"
  write(ilun,format)"     if(nrestart.eq.0) then"
  write(ilun,format)"        rtuold(:,iGroups(i))=smallNp"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)"  if(trim(rt_flux_scheme).eq.'hll') rt_use_hll=.true."
  write(ilun,format)"  if(rt_use_hll) call read_hll_eigenvalues"
  write(ilun,format)""
  write(ilun,format)"  tot_cool_loopcnt=0 ; max_cool_loopcnt=0 ; n_cool_cells=0"
  write(ilun,format)"  loopCodes=0"
  write(ilun,format)"  tot_nPhot=0.d0 ;  step_nPhot=0.d0; step_nStar=0.d0; step_mStar=0.d0"
  write(ilun,format)"END SUBROUTINE rt_init"
  write(ilun,format)""
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"SUBROUTINE update_rt_c"
  write(ilun,format)""
  write(ilun,format)"! Update the speed of light for radiative transfer, in code units."
  write(ilun,format)"! This cannot be just a constant, since scale_v changes with time in"
  write(ilun,format)"! cosmological simulations."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  rt_c=rt_c_cgs/scale_v"
  write(ilun,format)"  rt_c2=rt_c**2"
  write(ilun,format)"END SUBROUTINE update_rt_c"
  write(ilun,format)""
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"SUBROUTINE adaptive_rt_c_update(ilevel, dt)"
  write(ilun,format)""
  write(ilun,format)"! Set the lightspeed such that RT can be done at ilevel in time dt in"
  write(ilun,format)"! a single step."
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_parameters"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer:: ilevel, nx_loc"
  write(ilun,format)"  real(dp):: dt, scale, dx"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  ! Mesh spacing at ilevel"
  write(ilun,format)"  nx_loc=icoarse_max-icoarse_min+1"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx=0.5D0**ilevel*scale"
  write(ilun,format)""
  write(ilun,format)"  ! new lightspeed"
  write(ilun,format)"  rt_c = dx/3.d0/dt * rt_courant_factor"
  write(ilun,format)"  rt_c2 = rt_c**2"
  write(ilun,format)""
  write(ilun,format)"  ! new ligtspeed in cgs"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  rt_c_cgs = rt_c*scale_v"
  write(ilun,format)"  rt_c_fraction = rt_c_cgs/c_cgs"
  write(ilun,format)""
  write(ilun,format)"  call updateRTGroups_CoolConstants        ! These change as a consequence"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE adaptive_rt_c_update"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"SUBROUTINE read_rt_params()"
  write(ilun,format)""
  write(ilun,format)"! Read rt_params namelist"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use cooling_module, only:X, Y"
  write(ilun,format)"  use rt_cooling_module"
  write(ilun,format)"  use UV_module"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  use cloud_module,only:rt_protostar_m1"
  write(ilun,format)"  implicit none"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  namelist/rt_params/rt_star, rt_esc_frac, rt_flux_scheme, rt_smooth     &"
  write(ilun,format)"       & ,rt_is_outflow_bound, rt_TConst, rt_courant_factor              &"
  write(ilun,format)"       & ,rt_c_fraction, rt_nsubcycle, rt_otsa, sedprops_update          &"
  write(ilun,format)"       & ,sed_dir, uv_file, rt_UVsrc_nHmax, nUVgroups, nSEDgroups        &"
  write(ilun,format)"       & ,SED_isEgy, rt_output_coolstats, hll_evals_file                 &"
  write(ilun,format)"       & ,upload_equilibrium_x, X, Y, rt_is_init_xion                    &"
  write(ilun,format)"       & ,rt_err_grad_n, rt_floor_n, rt_err_grad_xHII, rt_floor_xHII     &"
  write(ilun,format)"       & ,rt_err_grad_xHI, rt_floor_xHI, rt_refine_aexp                  &"
  write(ilun,format)"       & ,is_mu_H2,rt_isIR, is_kIR_T, rt_T_rad, rt_vc, rt_pressBoost     &"
  write(ilun,format)"       & ,rt_isoPress, rt_isIRtrap, rt_movie_vars                        &"
  write(ilun,format)"       ! RT regions (for initialization)                                 &"
  write(ilun,format)"       & ,rt_nregion, rt_region_type                                     &"
  write(ilun,format)"       & ,rt_reg_x_center, rt_reg_y_center, rt_reg_z_center              &"
  write(ilun,format)"       & ,rt_reg_length_x, rt_reg_length_y, rt_reg_length_z              &"
  write(ilun,format)"       & ,rt_exp_region, rt_reg_group                                    &"
  write(ilun,format)"       & ,rt_n_region, rt_u_region, rt_v_region, rt_w_region             &"
  write(ilun,format)"       ! RT source regions (for every timestep)                          &"
  write(ilun,format)"       & ,rt_nsource, rt_source_type                                     &"
  write(ilun,format)"       & ,rt_src_x_center, rt_src_y_center, rt_src_z_center              &"
  write(ilun,format)"       & ,rt_src_length_x, rt_src_length_y, rt_src_length_z              &"
  write(ilun,format)"       & ,rt_exp_source, rt_src_group, rt_src_start, rt_src_end          &"
  write(ilun,format)"       & ,rt_n_source, rt_u_source, rt_v_source, rt_w_source             &"
  write(ilun,format)"       ! RT boundary (for boundary conditions)                           &"
  write(ilun,format)"       & ,rt_n_bound,rt_u_bound,rt_v_bound,rt_w_bound                    &"
  write(ilun,format)"       & ,rt_movie_vars, rt_sink, rt_protostar_m1"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Set default initialisation of ionisation states:"
  write(ilun,format)"  ! -Off if restarting, but can set to true (for postprocessing)"
  write(ilun,format)"  ! -On otherwise, but can set to false (for specificic initialisation)"
  write(ilun,format)"  if(neq_chem .or. rt) then"
  write(ilun,format)"     if(nrestart .gt. 0) then"
  write(ilun,format)"        rt_is_init_xion=.false."
  write(ilun,format)"     else"
  write(ilun,format)"        rt_is_init_xion=.true."
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"  "
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=rt_params,END=101)"
  write(ilun,format)"101 continue                                   ! No harm if no rt namelist"
  write(ilun,format)""
  write(ilun,format)"  if(nGroups.le.0) rt=.false. ! No sense  doing rt if there are no photons"
  write(ilun,format)"  if(.not. rt .and. .not. rt_star) sedprops_update=-1"
  write(ilun,format)""
  write(ilun,format)"  if(rt_err_grad_n .gt. 0. .or. rt_err_grad_xHII .gt. 0.                 &"
  write(ilun,format)"       .or. rt_err_grad_xHI .gt. 0.) rt_refine=.true."
  write(ilun,format)""
  write(ilun,format)"  rt_c_cgs = c_cgs * rt_c_fraction"
  write(ilun,format)"  !call update_rt_c"
  write(ilun,format)""
  write(ilun,format)"  ! Trapped IR pressure closure as in Rosdahl & Teyssier 2015, eq 43:"
  write(ilun,format)"  if(rt_isIRtrap) gamma_rad(1) = rt_c_fraction / 3d0 + 1d0"
  write(ilun,format)""
  write(ilun,format)"  if(rt_Tconst .ge. 0.d0) rt_isTconst=.true. "
  write(ilun,format)"  call read_rt_groups()"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE read_rt_params"
  write(ilun,format)""
  write(ilun,format)"!*************************************************************************"
  write(ilun,format)"SUBROUTINE read_rt_groups()"
  write(ilun,format)""
  write(ilun,format)"! Read rt_groups namelist"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use rt_cooling_module"
  write(ilun,format)"  use SED_module"
  write(ilun,format)"  use radiation_parameters !raph for kappaAbs=kplanck(Tstar) and kappaSc"
  write(ilun,format)"  use hydro_parameters, only: ngrp"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::i, igrp !igrp for kappaAbs=kplanck(Tstar) and kappaSc"
  write(ilun,format)"!  real(dp)::planck_ana, planck_ana_scat !raph for kappaAbs=kplanck(Tstar)"
  write(ilun,format)"!-------------------------------------------------------------------------"
  write(ilun,format)"  namelist/rt_groups/group_csn, group_cse, group_egy, spec2group         &"
  write(ilun,format)"       & , groupL0, groupL1, kappaAbs, kappaSc"
  write(ilun,format)"  interface "
  write(ilun,format)"    real(dp) function planck_ana(a,b,c,d)"
  write(ilun,format)"    import :: dp"
  write(ilun,format)"    real(dp), intent(in)  :: a,b,c"
  write(ilun,format)"    integer, intent(in)   :: d"
  write(ilun,format)"    end function planck_ana"
  write(ilun,format)""
  write(ilun,format)"    real(dp) function planck_ana_scat(a,b,c,d)"
  write(ilun,format)"    import :: dp"
  write(ilun,format)"    real(dp), intent(in)  :: a,b,c"
  write(ilun,format)"    integer, intent(in)   :: d"
  write(ilun,format)"    end function planck_ana_scat"
  write(ilun,format)"  end interface"
  write(ilun,format)""
  write(ilun,format)"  if(myid==1) then"
  write(ilun,format)"     write(*,'(' Working with ',I2,' photon groups and  '                &"
  write(ilun,format)"          & ,I2, ' ion species')') nGroups, nIons"
  write(ilun,format)"     write(*,*) ''"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  if(nGroups .le. 0) then"
  write(ilun,format)"     rt = .false."
  write(ilun,format)"     return"
  write(ilun,format)"  endif"
  write(ilun,format)"#if NGROUPS>0"
  write(ilun,format)"  !   Use ionization energies for HI, HeI, HeII as default group intervals"
  write(ilun,format)"  groupL0(1:min(nGroups,3))=ionEvs(1:min(nGroups,3))!Lower interval bounds"
  write(ilun,format)"  groupL1(1:min(nGroups,2))=ionEvs(2:min(nGroups+1,3)) !      Upper bounds"
  write(ilun,format)"  groupL1(min(nGroups,3))=0.                        ! Upper bound=infinity"
  write(ilun,format)""
  write(ilun,format)"  ! Default groups are all blackbodies at E5 Kelvin"
  write(ilun,format)"  group_csn(1,:)=(/3.007d-18, 0d0, 0d0/)   ! Avg photoion. c-section (cm2)"
  write(ilun,format)"  group_cse(1,:)=(/2.781d-18, 0d0, 0d0/)   !     Weighted  c-section (cm2)"
  write(ilun,format)"  group_egy(1)  =18.85                     !        Avg photon Energy (eV)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGROUPS>1"
  write(ilun,format)"  if(nGroups .ge. 2) group_csn(2,:)=(/5.687d-19, 4.478d-18, 0d0/)"
  write(ilun,format)"  if(nGroups .ge. 2) group_cse(2,:)=(/5.042d-19, 4.130d-18, 0d0/)"
  write(ilun,format)"  if(nGroups .ge. 2) group_egy(2)  = 35.079"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NGROUPS>2"
  write(ilun,format)"  if(nGroups .ge. 3) group_csn(3,:)=(/7.889d-20, 1.197d-18, 1.055d-18/)"
  write(ilun,format)"  if(nGroups .ge. 3) group_cse(3,:)=(/7.456d-20, 1.142d-18, 1.001d-18/)"
  write(ilun,format)"  if(nGroups .ge. 3) group_egy(3)  =65.666"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  do i=1,min(nIons,nGroups)"
  write(ilun,format)"     spec2group(i)=i                   ! Species contributions to groups"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=rt_groups,END=101)"
  write(ilun,format)""
  write(ilun,format)"  if (ngrp==1) then"
  write(ilun,format)"     kappaAbs = planck_ana(1.0d0, Tstar, Tstar ,1) !M1 abs opacity at Tstar"
  write(ilun,format)"     if(isoscat) kappaSc  = planck_ana_scat(1.0d0, Tstar, Tstar, 1) !M1 scat opacity"
  write(ilun,format)"     if(myid==1) write(*,*) 'M1 absorption is Planck's mean opacity at the star temperature'"
  write(ilun,format)"     if(myid==1 .and. isoscat) write(*,*) 'M1 scattering is Planck's mean opacity at the star temperature'"
  write(ilun,format)"  else"
  write(ilun,format)"     if(myid==1) write(*,*) 'ngrp>1 so M1 absorption and scattering opacities are taken from the namelist'"
  write(ilun,format)"  endif  "
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"101 continue              ! no harm if no rt namelist"
  write(ilun,format)""
  write(ilun,format)"  if(minval(group_egy) .le. 0d0 .and. myid==1) then"
  write(ilun,format)"     print*,'========================================================='"
  write(ilun,format)"     print*,'WARNING! Some photon groups have zero or negative energy!'"
  write(ilun,format)"     print*,'This could have unwanted effects, so be careful!!!'"
  write(ilun,format)"     print*,'========================================================='"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  call updateRTGroups_CoolConstants"
  write(ilun,format)"  call write_group_props(.false.,6)"
  write(ilun,format)"END SUBROUTINE read_rt_groups"
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE add_rt_sources(ilevel,dt)"
  write(ilun,format)""
  write(ilun,format)"! Inject radiation from RT source regions (from the RT namelist). Since"
  write(ilun,format)"! the light sources are continuously emitting radiation, this is called"
  write(ilun,format)"! continuously during code execution, rather than just during"
  write(ilun,format)"! initialization."
  write(ilun,format)"!"
  write(ilun,format)"! ilevel => amr level at which to inject the radiation"
  write(ilun,format)"! dt     => timestep for injection (since injected values are per time)"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  real(dp)::dt"
  write(ilun,format)"  integer::i,igrid,ncache,iskip,ngrid"
  write(ilun,format)"  integer::ind,idim,ivar,ix,iy,iz,nx_loc"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nrtvar),save::uu"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  call add_UV_background(ilevel)"
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return    ! no grids at this level"
  write(ilun,format)"  if(rt_nsource .le. 0) return      ! no rt sources"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh size at level ilevel in coarse cell units"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  ! Set position of cell centers relative to grid center"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Local constants"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  ! dx (and dx_loc=dx) are just equal to 1/nx (where 1 is the boxlength)"
  write(ilun,format)"  ! Loop over grids by vector sweeps"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        ! Gather cell indices"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Gather cell centre positions"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=xg(ind_grid(i),idim)+xc(ind,idim)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Rescale position from code units to user units"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              xx(i,idim)=(xx(i,idim)-skip_loc(idim))*scale"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Read the RT variables"
  write(ilun,format)"        do ivar=1,nrtvar"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              uu(i,ivar)=rtunew(ind_cell(i),ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! find injected values per cell"
  write(ilun,format)"        call rt_sources_vsweep(xx,uu,dx_loc,dt,ngrid)"
  write(ilun,format)"        ! Write the RT variables"
  write(ilun,format)"        do ivar=1,nrtvar"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              rtunew(ind_cell(i),ivar)=uu(i,ivar)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering add_rt_sources for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE add_rt_sources"
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE add_UV_background(ilevel)"
  write(ilun,format)""
  write(ilun,format)"! Inject radiation from RT source regions (from the RT namelist). Since"
  write(ilun,format)"! the light sources are continuously emitting radiation, this is called"
  write(ilun,format)"! continuously during code execution, rather than just during"
  write(ilun,format)"! initialization."
  write(ilun,format)"!"
  write(ilun,format)"! ilevel => amr level at which to inject the radiation"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use UV_module, ONLY: UV_Nphot_cgs, nUVgroups, iUVgroups"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  integer::i,igrid,ncache,iskip,ngrid,j"
  write(ilun,format)"  integer::ind,ic,ig"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_grid"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_np  &"
  write(ilun,format)"            ,scale_fp,efactor,nH"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return     ! no grids at this level"
  write(ilun,format)"  if(.not. rt_isDiffuseUVsrc) return ! no propagated UV background"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  call rt_units(scale_np, scale_fp)"
  write(ilun,format)""
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  ! Loop over grids by vector sweeps"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ic=iskip+ind_grid(i) ! cell index"
  write(ilun,format)"           ! Read the local gas density and inject the UV radiation"
  write(ilun,format)"           nH=unew(ic,1)*scale_nH"
  write(ilun,format)"           efactor = exp(-nH/rt_UVsrc_nHmax)"
  write(ilun,format)"           do j=1,nUVgroups"
  write(ilun,format)"              ig = iGroups(iUVgroups(j))"
  write(ilun,format)"              rtunew(ic,ig) = max(rtunew(ic,ig)                     &"
  write(ilun,format)"                                 ,UV_Nphot_cgs(j)/scale_np * efactor)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering add_UV_background for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"END SUBROUTINE add_UV_background"
  write(ilun,format)""
  write(ilun,format)"!************************************************************************"
  write(ilun,format)"SUBROUTINE rt_sources_vsweep(x,uu,dx,dt,nn)"
  write(ilun,format)""
  write(ilun,format)"! Do a vector sweep, injecting RT source regions into cells, that is if"
  write(ilun,format)"! they are in any of these regions."
  write(ilun,format)"!"
  write(ilun,format)"! x      =>  ncells*ndim: positions of grid cells"
  write(ilun,format)"! uu    <=  ncells*nrtvars: injected rt variables in each cell"
  write(ilun,format)"! dx     =>  real cell width in code units"
  write(ilun,format)"! dt     =>  real timestep length in code units"
  write(ilun,format)"! nn     =>  int number of cells"
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use rt_parameters"
  write(ilun,format)"  use radiation_parameters"
  write(ilun,format)"  use cooling_module,only: clight"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer ::nn"
  write(ilun,format)"  real(dp)::dx,dt,dx_cgs,dt_cgs"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:nrtvar)::uu"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::x"
  write(ilun,format)"  integer::i,k,group_ind"
  write(ilun,format)"  real(dp)::vol,r,xn,yn,zn,en"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::scale_np,scale_fp,pi"
  write(ilun,format)"  real(dp)::radiation_source,lum_group,lum_star,rstar_adim"
  write(ilun,format)""
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)"  "
  write(ilun,format)"!------------------------------------------------------------------------"
  write(ilun,format)"  ! Initialize everything to zero"
  write(ilun,format)"  !  uu=0.0d0"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  call rt_units(scale_np, scale_fp)"
  write(ilun,format)"  dx_cgs=dx*scale_l"
  write(ilun,format)"  dt_cgs=dt*scale_t"
  write(ilun,format)"  rstar_adim = rstar*6.96d10 / scale_l"
  write(ilun,format)"  lum_star=(5.67d-5*(Tstar**4))*4.0d0*3.1415d0*(rstar_adim)**2/(scale_d*(scale_v)**3)/(2.d0*Rin)"
  write(ilun,format)"  ! Loop over RT regions"
  write(ilun,format)"  do k=1,rt_nsource"
  write(ilun,format)""
  write(ilun,format)"     ! Find which photon group we should be contributing to"
  write(ilun,format)"     if(rt_src_group(k) .le. 0 .or. rt_src_group(k) .gt. nGroups) cycle"
  write(ilun,format)"     group_ind = iGroups(rt_src_group(k))"
  write(ilun,format)"     if ((t-rt_src_start(k)) .lt. 0.) cycle"
  write(ilun,format)"     if(((t-rt_src_end(k)) .gt. 0.) .and. (rt_src_end(k) .gt. 0.)) cycle"
  write(ilun,format)"     ! For 'square' regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'square')then"
  write(ilun,format)"       ! Exponent of choosen norm"
  write(ilun,format)"        en=rt_exp_source(k)"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           ! Compute position in normalized coordinates"
  write(ilun,format)"           xn=0.0d0; yn=0.0d0; zn=0.0d0"
  write(ilun,format)"           xn=2.0d0*abs(x(i,1)-rt_src_x_center(k))/rt_src_length_x(k)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=2.0d0*abs(x(i,2)-rt_src_y_center(k))/rt_src_length_y(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=2.0d0*abs(x(i,3)-rt_src_z_center(k))/rt_src_length_z(k)"
  write(ilun,format)"#endif"
  write(ilun,format)"           ! Compute cell 'radius' relative to region center"
  write(ilun,format)"           if(rt_exp_source(k)<10)then"
  write(ilun,format)"              r=(xn**en+yn**en+zn**en)**(1.0/en)"
  write(ilun,format)"           else"
  write(ilun,format)"              r=max(xn,yn,zn)"
  write(ilun,format)"           end if"
  write(ilun,format)"           ! If cell lies within region, inject value"
  write(ilun,format)"           if(r<1.0)then"
  write(ilun,format)"              uu(i,group_ind) = rt_n_source(k)/rt_c_cgs/scale_Np"
  write(ilun,format)"              ! The input flux is the fraction Fp/(c*Np) (Max 1 magnitude)"
  write(ilun,format)"              uu(i,group_ind+1) =                                       &"
  write(ilun,format)"                        rt_u_source(k) * rt_c * rt_n_source(k) / scale_Np"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"              uu(i,group_ind+2) =                                       &"
  write(ilun,format)"                        rt_v_source(k) * rt_c * rt_n_source(k) / scale_Np"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"              uu(i,group_ind+3) =                                       &"
  write(ilun,format)"                        rt_w_source(k) * rt_c * rt_n_source(k) / scale_Np"
  write(ilun,format)"#endif"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! For 'point' regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'point')then"
  write(ilun,format)"        ! Volume elements"
  write(ilun,format)"        vol=dx_cgs**ndim"
  write(ilun,format)"        ! Compute CIC weights relative to region center"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           xn=1.0; yn=1.0; zn=1.0"
  write(ilun,format)"           xn=max(1.0-abs(x(i,1)-rt_src_x_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=max(1.0-abs(x(i,2)-rt_src_y_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=max(1.0-abs(x(i,3)-rt_src_z_center(k))/dx, 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"           r=xn*yn*zn"
  write(ilun,format)"           if(r .gt. 0.) then"
  write(ilun,format)"              ! If cell lies within CIC cloud, inject value."
  write(ilun,format)"              ! Photon input is in # per sec...need to convert to uu"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"              lum_group = radiation_source(Tstar,1)/(scale_d*scale_v**2)*(pi*rstar_adim**2*clight/scale_v)/(2.d0*Rin)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"              lum_group = radiation_source(Tstar,1)/(scale_d*scale_v**2)*(pi*rstar_adim**2*clight/scale_v)"
  write(ilun,format)"#endif"
  write(ilun,format)"              uu(i,group_ind)=uu(i,group_ind)                            &"
  write(ilun,format)"                   + lum_group*scale_d*scale_v**2*dt/(scale_Np*group_egy(1)*ev_to_erg)*r/(dx**ndim)"
  write(ilun,format)""
  write(ilun,format)"              uu(i,group_ind)=uu(i,group_ind)                            &"
  write(ilun,format)"                            + rt_n_source(k) / scale_Np * r / vol * dt_cgs"
  write(ilun,format)""
  write(ilun,format)"              uu(i,group_ind+1)=uu(i,group_ind+1) + rt_u_source(k) *rt_c &"
  write(ilun,format)"                            * rt_n_source(k) / scale_Np * r / vol * dt_cgs"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"              uu(i,group_ind+2)=uu(i,group_ind+2) + rt_v_source(k) *rt_c &"
  write(ilun,format)"                            * rt_n_source(k) / scale_Np * r / vol * dt_cgs"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"              uu(i,group_ind+3)=uu(i,group_ind+3) + rt_w_source(k) *rt_c &"
  write(ilun,format)"                            * rt_n_source(k) / scale_Np * r / vol * dt_cgs"
  write(ilun,format)"#endif"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! For shell regions only:"
  write(ilun,format)"     if(rt_source_type(k) .eq. 'shell')then"
  write(ilun,format)"        ! An emitting spherical shell with center coordinates given,"
  write(ilun,format)"        ! along with inner and outer radius (rt_src_length_x,z)."
  write(ilun,format)"        ! Compute CIC weights relative to region center"
  write(ilun,format)"        do i=1,nn"
  write(ilun,format)"           xn=0.0; yn=0.0; zn=0.0"
  write(ilun,format)"           xn=max(abs(x(i,1)-rt_src_x_center(k)), 0.0_dp)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"           yn=max(abs(x(i,2)-rt_src_y_center(k)), 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"           zn=max(abs(x(i,3)-rt_src_z_center(k)), 0.0_dp)"
  write(ilun,format)"#endif"
  write(ilun,format)"           r=sqrt(xn**2+yn**2+zn**2)"
  write(ilun,format)"           if(r .gt. rt_src_length_x(k) .and. &"
  write(ilun,format)"                r .lt. rt_src_length_y(k)) then"
  write(ilun,format)"              ! If cell lies within CIC cloud, inject value"
  write(ilun,format)"              ! photon input is in # per sec...need to convert to uu"
  write(ilun,format)"              uu(i,group_ind)=rt_n_source(k) / scale_np"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)"END SUBROUTINE rt_sources_vsweep"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"../patch/irradiation/test_pascucci/sink_particle.f90"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine create_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)"  ! sink creation routine"
  write(ilun,format)"  ! -remove all cloud particles, keep only global sink arrays"
  write(ilun,format)"  ! -call clumpfinder for potential relevant peaks"
  write(ilun,format)"  ! -flag peaks which are eligible for sink formation (flag 2)"
  write(ilun,format)"  ! -new sink particle are created"
  write(ilun,format)"  ! -new cloud particles are created"
  write(ilun,format)"  ! -cloud particles are scattered to grid"
  write(ilun,format)"  ! -accretion routine is called (with on_creation=.true.)"
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::ilevel,ivar"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)' Entering create_sink'"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Merge all particles to level 1"
  write(ilun,format)"  do ilevel=levelmin-1,1,-1"
  write(ilun,format)"     call merge_tree_fine(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Remove all particle clouds around old sinks (including the central one)"
  write(ilun,format)"  call kill_entire_cloud(1)"
  write(ilun,format)""
  write(ilun,format)"  ! DO NOT MODIFY FLAG2 BETWEEN CLUMP_FINDER AND MAKE_SINK_FROM_CLUMP"
  write(ilun,format)"  if (create_sinks)then"
  write(ilun,format)""
  write(ilun,format)"     ! Run the clump finder,(produce no output, keep clump arrays allocated)"
  write(ilun,format)"     call clump_finder(.false.,.true.)"
  write(ilun,format)""
  write(ilun,format)"     ! Trim clumps down to R_accretion ball around peaks"
  write(ilun,format)"     if(clump_core)call trim_clumps"
  write(ilun,format)""
  write(ilun,format)"     ! Compute simple additive quantities and means (1st moments)"
  write(ilun,format)"     call compute_clump_properties(uold(1,1))"
  write(ilun,format)""
  write(ilun,format)"     ! Compute quantities relative to mean (2nd moments)"
  write(ilun,format)"     call compute_clump_properties_round2"
  write(ilun,format)""
  write(ilun,format)"     ! Apply all checks and flag cells for sink formation"
  write(ilun,format)"     call flag_formation_sites"
  write(ilun,format)""
  write(ilun,format)"     ! Create new sink particles if relevant"
  write(ilun,format)"     do ilevel=levelmin,nlevelmax"
  write(ilun,format)"        call make_sink_from_clump(ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Deallocate clump finder arrays"
  write(ilun,format)"     deallocate(npeaks_per_cpu)"
  write(ilun,format)"     deallocate(ipeak_start)"
  write(ilun,format)"     if (ntest>0)then"
  write(ilun,format)"        deallocate(icellp)"
  write(ilun,format)"        deallocate(levp)"
  write(ilun,format)"        deallocate(testp_sort)"
  write(ilun,format)"        deallocate(imaxp)"
  write(ilun,format)"     endif"
  write(ilun,format)"     call deallocate_all"
  write(ilun,format)""
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Merge sink for smbh runs"
  write(ilun,format)"  if (smbh)then"
  write(ilun,format)"    call merge_smbh_sink"
  write(ilun,format)"  else"
  write(ilun,format)"     if(merging_timescale>0.d0)call merge_star_sink"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Create new cloud particles"
  write(ilun,format)"  call create_cloud_from_sink"
  write(ilun,format)""
  write(ilun,format)"  ! Scatter particle to the grid"
  write(ilun,format)"  ! Compute Bondi parameters"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     call make_tree_fine(ilevel)"
  write(ilun,format)"     call kill_tree_fine(ilevel)"
  write(ilun,format)"     call virtual_tree_fine(ilevel)"
  write(ilun,format)"     call collect_acczone_avg(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Perform first accretion with seed mass"
  write(ilun,format)"  ! Gather particles to levelmin"
  write(ilun,format)"  do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"     call set_unew_sink(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"     call grow_sink(ilevel,.true.)"
  write(ilun,format)"     call merge_tree_fine(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)"  do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"     call set_uold_sink(ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro quantities for split cells"
  write(ilun,format)"  if(hydro)then"
  write(ilun,format)"     do ilevel=nlevelmax,levelmin,-1"
  write(ilun,format)"        call upload_fine(ilevel)"
  write(ilun,format)"        do ivar=1,nvar"
  write(ilun,format)"           call make_virtual_fine_dp(uold(1,ivar),ilevel)"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! Update boundaries"
  write(ilun,format)"        if(simple_boundary)call make_boundary_hydro(ilevel)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Update the cloud particle properties at levelmin"
  write(ilun,format)"  ! So they match their parent sink properties"
  write(ilun,format)"  call update_cloud(levelmin)"
  write(ilun,format)""
  write(ilun,format)"  ! Effective accretion rate during last coarse step"
  write(ilun,format)"  acc_rate(1:nsink)=delta_mass(1:nsink)/dtnew(levelmin)"
  write(ilun,format)""
  write(ilun,format)"  ! Compute and print accretion rates"
  write(ilun,format)"  call compute_accretion_rate(.true.)"
  write(ilun,format)""
  write(ilun,format)"end subroutine create_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine create_cloud_from_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine creates the whole cloud of particles for each sink,"
  write(ilun,format)"  ! Particles are produced in the right MPI domain and inserted in the"
  write(ilun,format)"  ! linked list at level 1."
  write(ilun,format)"  ! The cloud radius is dble(ir_cloud)*dx_min, where dx_min is"
  write(ilun,format)"  ! the cell size at levelmax. For cosmo runs, the cloud radius is"
  write(ilun,format)"  ! dx_min/aexp (therefore it is constant in *physical* units)."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale,dx_min,rr,rmax,rmass"
  write(ilun,format)"  integer ::icpu,isink,indp,ii,jj,kk,nx_loc,idim"
  write(ilun,format)"  real(dp),dimension(1:ndim)::xrel"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xtest"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,cc,ind_cloud"
  write(ilun,format)"  logical ,dimension(1:nvector)::ok_true"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)"  logical::in_box"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ok_true=.true."
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,1)==0) return"
  write(ilun,format)"  if(verbose)write(*,*)' Entering create_cloud_from_sink'"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  ! Level 1 linked list"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     if(numbl(icpu,1)>0)then"
  write(ilun,format)"        ind_grid(1)=headl(icpu,1)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"  period(2)=(ny==1)"
  write(ilun,format)"  period(3)=(nz==1)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)""
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min"
  write(ilun,format)"  rmass=dble(ir_cloud_massive)*dx_min"
  write(ilun,format)""
  write(ilun,format)"  do kk=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"     xrel(3)=dble(kk)*dx_min/2.0"
  write(ilun,format)"     do jj=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"        xrel(2)=dble(jj)*dx_min/2.0"
  write(ilun,format)"        do ii=-2*ir_cloud,2*ir_cloud"
  write(ilun,format)"           xrel(1)=dble(ii)*dx_min/2.0"
  write(ilun,format)"           rr=sqrt(sum(xrel**2))"
  write(ilun,format)"           if(rr<=rmax)then"
  write(ilun,format)"              do isink=1,nsink"
  write(ilun,format)"                 xtest(1,1:3)=xsink(isink,1:3)+xrel(1:3)"
  write(ilun,format)"                 in_box=.true."
  write(ilun,format)"                 do idim=1,ndim"
  write(ilun,format)"                    if (period(idim) .and. xtest(1,idim)>boxlen)xtest(1,idim)=xtest(1,idim)-boxlen"
  write(ilun,format)"                    if (period(idim) .and. xtest(1,idim)<0.)xtest(1,idim)=xtest(1,idim)+boxlen"
  write(ilun,format)"                    if (xtest(1,idim)<0.0 .or. xtest(1,idim)>boxlen)in_box=.false."
  write(ilun,format)"                 end do"
  write(ilun,format)"                 cc(1)=0"
  write(ilun,format)"                 if(in_box)call cmp_cpumap(xtest,cc,1)"
  write(ilun,format)"                 if(cc(1).eq.myid)then"
  write(ilun,format)"                    call remove_free(ind_cloud,1)"
  write(ilun,format)"                    call add_list(ind_cloud,ind_grid,ok_true,1)"
  write(ilun,format)"                    indp=ind_cloud(1)"
  write(ilun,format)"                    idp(indp)=-isink"
  write(ilun,format)"                    levelp(indp)=levelmin"
  write(ilun,format)"                    if (rr<=rmass .and. msink(isink)<mass_sink_direct_force*2d33/(scale_d*scale_l**3))then"
  write(ilun,format)"                       mp(indp)=msink(isink)/dble(ncloud_sink_massive)"
  write(ilun,format)"                    else"
  write(ilun,format)"                       mp(indp)=0."
  write(ilun,format)"                    end if"
  write(ilun,format)"                    xp(indp,1:3)=xtest(1,1:3)"
  write(ilun,format)"                    vp(indp,1:3)=vsink(isink,1:3)"
  write(ilun,format)"                    tp(indp)=tsink(isink)     ! Birth epoch"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     direct_force_sink(isink)=(msink(isink) .ge. mass_sink_direct_force*2d33/(scale_d*scale_l**3))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine create_cloud_from_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine kill_entire_cloud(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine removes cloud particles (including the central one)."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,ncache,istart"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  logical,dimension(1:nvector)::ok=.true."
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)"  ! Gather sink and cloud particles."
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu+nboundary"
  write(ilun,format)"     if(icpu<=ncpu)then"
  write(ilun,format)"        ncache=numbl(icpu,ilevel)"
  write(ilun,format)"        istart=headl(icpu,ilevel)"
  write(ilun,format)"     else"
  write(ilun,format)"        ncache=numbb(icpu-ncpu,ilevel)"
  write(ilun,format)"        istart=headb(icpu-ncpu,ilevel)"
  write(ilun,format)"     end if"
  write(ilun,format)"     igrid=istart"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,ncache"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then"
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig"
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call remove_list(ind_part,ind_grid_part,ok,ip)"
  write(ilun,format)"                 call add_free_cond(ind_part,ok,ip)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"        call remove_list(ind_part,ind_grid_part,ok,ip)"
  write(ilun,format)"        call add_free_cond(ind_part,ok,ip)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"111 format('   Entering kill_cloud for level ',I2)"
  write(ilun,format)"end subroutine kill_entire_cloud"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine collect_acczone_avg(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is used to collect all relevant information to compute the"
  write(ilun,format)"  ! the accretion rates. The information is collected level-by-level when"
  write(ilun,format)"  ! going down in the call tree (leafs at the bottom), while accretion is"
  write(ilun,format)"  ! performed on the way up."
  write(ilun,format)"  ! - first, the volume of each particle is computed. The volume is reduced if"
  write(ilun,format)"  ! sinks are overlapping."
  write(ilun,format)"  ! - then a loop over all particles of ilevel (vectorized) is used to compute"
  write(ilun,format)"  ! the volume-weighted quantities."
  write(ilun,format)"  ! No gaussian accretion kernel is used anymore..."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,nx_loc,isink"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  real(dp)::dx_loc,dx_min,scale,factG"
  write(ilun,format)"  character(LEN=15)::action"
  write(ilun,format)""
  write(ilun,format)"  if(ilevel<levelmin)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  action='count'"
  write(ilun,format)"  call count_clouds(ilevel,action)"
  write(ilun,format)""
  write(ilun,format)"  call make_virtual_reverse_dp(rho(1),ilevel)"
  write(ilun,format)"  call make_virtual_fine_dp(rho(1),ilevel)"
  write(ilun,format)""
  write(ilun,format)"  action='weight'"
  write(ilun,format)"  call count_clouds(ilevel,action)"
  write(ilun,format)""
  write(ilun,format)"  level_sink_new(1:nsinkmax,ilevel)=.false."
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)""
  write(ilun,format)"  ! compute (volume weighted) averages over accretion zone"
  write(ilun,format)"  wden=0d0; wvol=0d0; weth=0d0; wmom=0d0"
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)""
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then"
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig"
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"        call collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)""
  write(ilun,format)"  if(nsink>0)then"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(wden,wden_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(wvol,wvol_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(weth,weth_new,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(wmom,wmom_new,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(level_sink_new,level_sink,nsinkmax*(nlevelmax-levelmin+1),MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     wden_new=wden"
  write(ilun,format)"     wvol_new=wvol"
  write(ilun,format)"     weth_new=weth"
  write(ilun,format)"     wmom_new=wmom"
  write(ilun,format)"     level_sink=level_sink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     weighted_density(isink,ilevel)=wden_new(isink)"
  write(ilun,format)"     weighted_volume(isink,ilevel)=wvol_new(isink)"
  write(ilun,format)"     weighted_momentum(isink,ilevel,1:ndim)=wmom_new(isink,1:ndim)"
  write(ilun,format)"     weighted_ethermal(isink,ilevel)=weth_new(isink)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering collect_acczone_avg for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine collect_acczone_avg"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine collect_acczone_avg_np(ind_grid,ind_part,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! inner loop of collect_acczone_avg"
  write(ilun,format)"  ! weighted gas quantities for each particle are computed"
  write(ilun,format)"  ! no CIC averaging over quantities anymore as average over whole sink"
  write(ilun,format)"  ! accretion zone is computed"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  integer::j,isink,idim,ind"
  write(ilun,format)"  real(dp)::d,e,v2"
  write(ilun,format)"  real(dp)::weight"
  write(ilun,format)"  real(dp),dimension(1:3)::vv"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xpart"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::indp"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim)::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim)::vol"
  write(ilun,format)"  logical,dimension(1:nvector,1:twotondim)::ok"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j,ind))then"
  write(ilun,format)""
  write(ilun,format)"           ! Convert uold to primitive variables"
  write(ilun,format)"           d=max(uold(indp(j,ind),1),smallr)"
  write(ilun,format)"           vv(1)=uold(indp(j,ind),2)/d"
  write(ilun,format)"           vv(2)=uold(indp(j,ind),3)/d"
  write(ilun,format)"           vv(3)=uold(indp(j,ind),4)/d"
  write(ilun,format)""
  write(ilun,format)"           ! Compute fluid total energy"
  write(ilun,format)"           e=uold(indp(j,ind),5)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"           bx1=uold(indp(j,ind),6)"
  write(ilun,format)"           by1=uold(indp(j,ind),7)"
  write(ilun,format)"           bz1=uold(indp(j,ind),8)"
  write(ilun,format)"           bx2=uold(indp(j,ind),nvar+1)"
  write(ilun,format)"           by2=uold(indp(j,ind),nvar+2)"
  write(ilun,format)"           bz2=uold(indp(j,ind),nvar+3)"
  write(ilun,format)"           e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do irad=0,nener-1"
  write(ilun,format)"              e=e-uold(indp(j,ind),inener+irad)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           if(energy_fix)e=uold(indp(j,ind),nvar)"
  write(ilun,format)"           e=e/d ! Specific energy"
  write(ilun,format)"           v2=vv(1)**2+vv(2)**2+vv(3)**2"
  write(ilun,format)"           e=e-0.5d0*v2 ! Remove kinetic energy"
  write(ilun,format)""
  write(ilun,format)"           ! Get sink index"
  write(ilun,format)"           isink=-idp(ind_part(j))"
  write(ilun,format)""
  write(ilun,format)"           ! Get cloud particle CIC weight"
  write(ilun,format)"           weight=weightp(ind_part(j),ind)"
  write(ilun,format)"           if (weight>0.)level_sink_new(isink,ilevel)=.true."
  write(ilun,format)""
  write(ilun,format)"           ! Compute sink average quantities"
  write(ilun,format)"           wvol(isink)=wvol(isink)+weight"
  write(ilun,format)"           wden(isink)=wden(isink)+weight*d"
  write(ilun,format)"           wmom(isink,1:3)=wmom(isink,1:3)+weight*d*vv(1:3)"
  write(ilun,format)"           weth(isink)=weth(isink)+weight*d*e"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine collect_acczone_avg_np"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine grow_sink(ilevel,on_creation)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  logical::on_creation"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine performs accretion onto the sink. It vectorizes the loop"
  write(ilun,format)"  ! over all sink cloud particles and calls accrete_sink as soon as nvector"
  write(ilun,format)"  ! particles are collected"
  write(ilun,format)"  ! -> replaces grow_bondi and grow_jeans"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,isink,lev"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  logical::highest_level"
  write(ilun,format)""
  write(ilun,format)"  if(accretion_scheme=='none'.and.(.not.on_creation))return"
  write(ilun,format)""
  write(ilun,format)"  if(.not. on_creation)then"
  write(ilun,format)"     ! Determine if on highest active level..."
  write(ilun,format)"     if (ilevel==nlevelmax)then"
  write(ilun,format)"        highest_level=.true."
  write(ilun,format)"     else if (numbtot(1,ilevel+1)==0)then"
  write(ilun,format)"        highest_level=.true."
  write(ilun,format)"     else"
  write(ilun,format)"        highest_level=.false."
  write(ilun,format)"     end if"
  write(ilun,format)"     if (.not. highest_level)return"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  ! Compute sink accretion rates"
  write(ilun,format)"  call compute_accretion_rate(.false.)"
  write(ilun,format)""
  write(ilun,format)"  ! Reset new sink variables"
  write(ilun,format)"  msink_new=0d0; xsink_new=0.d0; vsink_new=0d0; delta_mass_new=0d0; lsink_new=0d0"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then"
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig"
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call accrete_sink(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel,on_creation)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)call accrete_sink(ind_grid,ind_part,ind_grid_part,ig,ip,ilevel,on_creation)"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)"  if(nsink>0)then"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(msink_new,msink_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(delta_mass_new,delta_mass_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(xsink_new,xsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(vsink_new,vsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"     call MPI_ALLREDUCE(lsink_new,lsink_all,nsinkmax*3,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     msink_all=msink_new"
  write(ilun,format)"     delta_mass_all=delta_mass_new"
  write(ilun,format)"     xsink_all=xsink_new"
  write(ilun,format)"     vsink_all=vsink_new"
  write(ilun,format)"     lsink_all=lsink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     ! Reset jump in old sink coordinates"
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        sink_jump(isink,1:ndim,lev)=sink_jump(isink,1:ndim,lev)-xsink(isink,1:ndim)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Accrete to sink variables in the frame of the initial sink position"
  write(ilun,format)"     msink(isink)=msink(isink)+msink_all(isink)"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)+xsink_all(isink,1:ndim)/msink(isink)"
  write(ilun,format)"     vsink(isink,1:ndim)=vsink(isink,1:ndim)+vsink_all(isink,1:ndim)/msink(isink)"
  write(ilun,format)"     lsink(isink,1:3)=lsink(isink,1:3)+lsink_all(isink,1:3)-cross(xsink_all(isink,1:ndim),vsink_all(isink,1:ndim))/msink(isink)"
  write(ilun,format)""
  write(ilun,format)"     ! Store jump in new sink coordinates"
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        sink_jump(isink,1:ndim,lev)=sink_jump(isink,1:ndim,lev)+xsink(isink,1:ndim)"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! Store accreted mass"
  write(ilun,format)"     if (agn.and.ok_blast_agn(isink))then"
  write(ilun,format)"        delta_mass(isink)=delta_mass_all(isink) ! only the most recent accretion"
  write(ilun,format)"     else"
  write(ilun,format)"!!         ! Romain master version"
  write(ilun,format)"!!         delta_mass(isink)=delta_mass(isink)+delta_mass_all(isink)"
  write(ilun,format)"        delta_mass(isink)=delta_mass_all(isink)"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"     dmfsink(isink)=dmfsink(isink)+msink_all(isink)"
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"111 format('   Entering grow_sink for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine grow_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine accrete_sink(ind_grid,ind_part,ind_grid_part,ng,np,ilevel,on_creation)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module, only:facc_star_mom"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid_part,ind_part"
  write(ilun,format)"  logical::on_creation"
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine is called by subroutine grow_sink. It performs accretion"
  write(ilun,format)"  ! for nvector particles. Routine is not very efficient. Optimize if taking too long..."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,j,nx_loc,isink,ivar,idim,ind,ht"
  write(ilun,format)"  real(dp)::d,e,d_floor,density,volume,eint"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp)::factG,scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,c2"
  write(ilun,format)"  real(dp)::dx,dx_loc,dx_min,scale,vol_min,vol_loc,weight,m_acc=0.,d_jeans"
  write(ilun,format)"  ! Grid based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim)::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim)::vol"
  write(ilun,format)"  ! Particle based arrays"
  write(ilun,format)"  logical,dimension(1:nvector,1:twotondim)::ok"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim)::indp"
  write(ilun,format)"  real(dp),dimension(1:3)::vv,v_mom"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:3)::r_rel,v_rel,x_acc,p_acc,l_acc"
  write(ilun,format)"  real(dp)::fbk_ener_AGN,fbk_mom_AGN"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::tan_theta,cone_dist,orth_dist,rr2"
  write(ilun,format)"  real(dp),dimension(1:3)::cone_dir"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"  period(2)=(ny==1)"
  write(ilun,format)"  period(3)=(nz==1)"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Jet geometry safety net"
  write(ilun,format)"  cone_opening = max(tiny(0.0),cone_opening)"
  write(ilun,format)"  cone_opening = min(cone_opening, 180.d0)"
  write(ilun,format)"  tan_theta = tan(3.1415926/180.*cone_opening/2) ! tangent of half of the opening angle"
  write(ilun,format)""
  write(ilun,format)"  ! Get cloud particle CIC weights"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xpart(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  call cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over eight CIC volumes"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(ok(j,ind))then ! Only volumes at the current level"
  write(ilun,format)""
  write(ilun,format)"           ! Convert uold to primitive variables"
  write(ilun,format)"           d=max(uold(indp(j,ind),1),smallr)"
  write(ilun,format)"           vv(1)=uold(indp(j,ind),2)/d"
  write(ilun,format)"           vv(2)=uold(indp(j,ind),3)/d"
  write(ilun,format)"           vv(3)=uold(indp(j,ind),4)/d"
  write(ilun,format)""
  write(ilun,format)"           ! Compute the gas total specific energy (kinetic plus thermal)"
  write(ilun,format)"           ! removing all the other energies, if any."
  write(ilun,format)"           e=uold(indp(j,ind),5)"
  write(ilun,format)""
  write(ilun,format)"           ! PH retrieve the kinetic energy as well"
  write(ilun,format)"           ! we change the velocity of the gas to conserve angular momentum"
  write(ilun,format)"           e = e - 0.5*(uold(indp(j,ind),2)**2+uold(indp(j,ind),3)**2+uold(indp(j,ind),4)**2)/uold(indp(j,ind),1)"
  write(ilun,format)""
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"           bx1=uold(indp(j,ind),6)"
  write(ilun,format)"           by1=uold(indp(j,ind),7)"
  write(ilun,format)"           bz1=uold(indp(j,ind),8)"
  write(ilun,format)"           bx2=uold(indp(j,ind),nvar+1)"
  write(ilun,format)"           by2=uold(indp(j,ind),nvar+2)"
  write(ilun,format)"           bz2=uold(indp(j,ind),nvar+3)"
  write(ilun,format)"           e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"           do irad=1,nener"
  write(ilun,format)"              e=e-uold(indp(j,ind),inener-1+irad)"
  write(ilun,format)"           end do"
  write(ilun,format)"#endif"
  write(ilun,format)"           e=e/d ! Specific energy"
  write(ilun,format)"           if(energy_fix)e=uold(indp(j,ind),nvar)/d"
  write(ilun,format)"           eint=e*d"
  write(ilun,format)""
  write(ilun,format)"           ! Get sink index"
  write(ilun,format)"           isink=-idp(ind_part(j))"
  write(ilun,format)""
  write(ilun,format)"           ! Reference frame relative to the sink position"
  write(ilun,format)"           r_rel(1:3)=xx(j,1:3,ind)-xsink(isink,1:3)"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              if (period(idim) .and. r_rel(idim)>boxlen*0.5)r_rel(idim)=r_rel(idim)-boxlen"
  write(ilun,format)"              if (period(idim) .and. r_rel(idim)<boxlen*(-0.5))r_rel(idim)=r_rel(idim)+boxlen"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Reference frame relative to the sink velocity"
  write(ilun,format)"           v_rel(1:3)=vv(1:3)-vsink(isink,1:3)"
  write(ilun,format)""
  write(ilun,format)"           ! Cloud particle CIC weight"
  write(ilun,format)"           weight=weightp(ind_part(j),ind)"
  write(ilun,format)""
  write(ilun,format)"           ! Get sink average density"
  write(ilun,format)"           density=rho_gas(isink)"
  write(ilun,format)"           volume=volume_gas(isink)"
  write(ilun,format)"           !!PH 5/2/2017 when threshold_accretion is used 'weight' can be 0"
  write(ilun,format)"           if (volume==0. .or. density==0. .and. .not. threshold_accretion )print*,'something might be going wrong here...',weight,volume,density,ilevel,xsink(isink,1),xsink(isink,2),xsink(isink,3),isink"
  write(ilun,format)""
  write(ilun,format)"           ! Compute accreted mass"
  write(ilun,format)"           if (on_creation)then"
  write(ilun,format)"              if (new_born(isink))then"
  write(ilun,format)"                 ! on sink creation, new sinks"
  write(ilun,format)"                 m_acc=mseed(isink)*weight/volume*d/density"
  write(ilun,format)"              else"
  write(ilun,format)"                 ! on sink creation, preexisting sinks"
  write(ilun,format)"                 m_acc=0.0"
  write(ilun,format)"              end if"
  write(ilun,format)"           else"
  write(ilun,format)"              if (bondi_accretion)then"
  write(ilun,format)"                 m_acc=dMsink_overdt(isink)*dtnew(ilevel)*weight/volume*d/density"
  write(ilun,format)"              end if"
  write(ilun,format)""
  write(ilun,format)"              if (threshold_accretion.and.d_sink>0.0)then"
  write(ilun,format)"                 d_floor=d_sink ! User defined density threshold"
  write(ilun,format)"                 ! Jeans length related density threshold  "
  write(ilun,format)"                 if(jeans_accretion)then"
  write(ilun,format)"                    call soundspeed_eos(d,eint,c2)"
  write(ilun,format)"                    c2=c2**2"
  write(ilun,format)"                    d_jeans=c2*3.1415926/(4.0*dx_loc)**2/factG"
  write(ilun,format)"                    d_floor=d_jeans"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 m_acc=c_acc*weight*(d-d_floor)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)"           m_acc=max(m_acc,0.0_dp)"
  write(ilun,format)""
  write(ilun,format)"           ! Accreted relative center of mass"
  write(ilun,format)"           x_acc(1:3)=m_acc*r_rel(1:3)"
  write(ilun,format)""
  write(ilun,format)"           ! PH compute the part of the velocity associated to the momentum"
  write(ilun,format)"           ! then the gas keeps part of its momentum which is not accreted onto the sink"
  write(ilun,format)"           rr2 = r_rel(1)**2+r_rel(2)**2+r_rel(3)**2"
  write(ilun,format)"           v_mom(1:3) = 0.0"
  write(ilun,format)"           if(.not.on_creation) v_mom(1:3) = (1.-facc_star_mom)* (v_rel(1:3) - (v_rel(1)*r_rel(1)+v_rel(2)*r_rel(2)+v_rel(3)*r_rel(3))/rr2*r_rel(1:3))"
  write(ilun,format)""
  write(ilun,format)"           ! Accreted relative momentum"
  write(ilun,format)"           p_acc(1:3)=m_acc*(v_rel(1:3)-v_mom(1:3))"
  write(ilun,format)""
  write(ilun,format)"           ! Accreted relative angular momentum"
  write(ilun,format)"           l_acc(1:3)=m_acc*cross(r_rel(1:3),v_rel(1:3)-v_mom(1:3))"
  write(ilun,format)""
  write(ilun,format)"           ! Add accreted properties to sink variables"
  write(ilun,format)"           msink_new(isink)=msink_new(isink)+m_acc"
  write(ilun,format)"           xsink_new(isink,1:3)=xsink_new(isink,1:3)+x_acc(1:3)"
  write(ilun,format)"           vsink_new(isink,1:3)=vsink_new(isink,1:3)+p_acc(1:3)"
  write(ilun,format)"           lsink_new(isink,1:3)=lsink_new(isink,1:3)+l_acc(1:3)"
  write(ilun,format)"           delta_mass_new(isink)=delta_mass_new(isink)+m_acc"
  write(ilun,format)""
  write(ilun,format)"            ! Check for neg density inside sink accretion radius"
  write(ilun,format)"           if (8*m_acc/vol_loc>d .and. (.not. on_creation))then "
  write(ilun,format)"              write(*,*)'====================================================='"
  write(ilun,format)"              write(*,*)'DANGER of neg density :-( at location'"
  write(ilun,format)"              write(*,*)xx(j,1:3,ind)"
  write(ilun,format)"              write(*,*)'due to',isink"
  write(ilun,format)"              write(*,*)m_acc/vol_loc,d/d_sink,density/d_sink"
  write(ilun,format)"              write(*,*)indp(j,ind),myid"
  write(ilun,format)"              write(*,*)'nol_accretion: ',nol_accretion"
  write(ilun,format)"              do i=1,nsink"
  write(ilun,format)"                 write(*,*)i,' distance ',sum((xx(j,1:3,ind)-xsink(i,1:3))**2)**0.5/dx_min"
  write(ilun,format)"              end do"
  write(ilun,format)"              write(*,*)'try to decrease c_acc in SINK_PARAMS'"
  write(ilun,format)"              write(*,*)'====================================================='"
  write(ilun,format)"              !           call clean_stop"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           ! Accrete mass, momentum and gas total energy"
  write(ilun,format)"           unew(indp(j,ind),1)=unew(indp(j,ind),1)-m_acc/vol_loc"
  write(ilun,format)"           ! Retrieve part of the angular momentum"
  write(ilun,format)"           unew(indp(j,ind),2:4)=unew(indp(j,ind),2:4)-m_acc*(vv(1:3)-v_mom(1:3))/vol_loc"
  write(ilun,format)""
  write(ilun,format)"           ! Add the new specific kinetic energy"
  write(ilun,format)"           if(energy_fix)unew(indp(j,ind),nvar)=unew(indp(j,ind),nvar)-m_acc*e/vol_loc"
  write(ilun,format)"           e = e + 0.5* ( (vv(1)-v_mom(1))**2 + (vv(2)-v_mom(2))**2 + (vv(3)-v_mom(3))**2 )"
  write(ilun,format)"           unew(indp(j,ind),5)=unew(indp(j,ind),5)-m_acc*e/vol_loc"
  write(ilun,format)"           ! Note that we do not accrete magnetic fields and non-thermal energies."
  write(ilun,format)""
  write(ilun,format)"           ! Accrete passive scalars"
  write(ilun,format)"           do ivar=imetal,lastindex_pscal"
  write(ilun,format)"              unew(indp(j,ind),ivar)=unew(indp(j,ind),ivar)-m_acc*uold(indp(j,ind),ivar)/d/vol_loc"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! AGN feedback"
  write(ilun,format)"           if( .not. on_creation)then"
  write(ilun,format)"              if(agn)then"
  write(ilun,format)"                 if(ok_blast_agn(isink).and.delta_mass(isink)>0.0)then"
  write(ilun,format)"                    if(feedback_scheme=='energy')then"
  write(ilun,format)"                       fbk_ener_AGN=min(delta_mass(isink)*T2_AGN/scale_T2*weight/volume*d/density,T2_max/scale_T2*weight*d)"
  write(ilun,format)"                       unew(indp(j,ind),5)=unew(indp(j,ind),5)+fbk_ener_AGN/vol_loc"
  write(ilun,format)"                    end if"
  write(ilun,format)"                    if(feedback_scheme=='momentum')then"
  write(ilun,format)"                       fbk_mom_AGN=min(delta_mass(isink)*v_AGN*(180./cone_opening)*1.e5/scale_v*weight/volume*d/density,v_max*1.e5/scale_v*weight*d)"
  write(ilun,format)"                       ! checking if particle is in cone"
  write(ilun,format)"                       cone_dir(1:3)=lsink(isink,1:3)/sqrt(sum(lsink(isink,1:3)**2))"
  write(ilun,format)"                       cone_dist=sum(r_rel(1:3)*cone_dir(1:3))"
  write(ilun,format)"                       orth_dist=sqrt(sum((r_rel(1:3)-cone_dist*cone_dir(1:3))**2))"
  write(ilun,format)"                       if (orth_dist.le.abs(cone_dist)*tan_theta)then"
  write(ilun,format)"                          unew(indp(j,ind),2:4)=unew(indp(j,ind),2:4)+fbk_mom_AGN*r_rel(1:3)/(ir_cloud*dx_min)/vol_loc"
  write(ilun,format)"                          unew(indp(j,ind),5)=unew(indp(j,ind),5)+sum(fbk_mom_AGN*r_rel(1:3)/(ir_cloud*dx_min)*vv(1:3))/vol_loc"
  write(ilun,format)"                       end if"
  write(ilun,format)"                    end if"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine accrete_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine compute_accretion_rate(write_sinks)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical::write_sinks"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine computes the accretion rate onto the sink particles based"
  write(ilun,format)"  ! on the information collected in collect accretion"
  write(ilun,format)"  ! It also creates output for the sink particle positions"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,nx_loc,isink"
  write(ilun,format)"  integer::imdot,im1,im2"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_m"
  write(ilun,format)"  real(dp)::factG,d_star,boost"
  write(ilun,format)"  real(dp)::r2,v2,c2,density,volume,ethermal,dx_min,scale,mgas,rho_inf,v_bondi"
  write(ilun,format)"  real(dp),dimension(1:3)::velocity"
  write(ilun,format)"  real(dp),dimension(1:nsinkmax)::dMEDoverdt"
  write(ilun,format)"  real(dp)::T2_gas,delta_mass_min"
  write(ilun,format)"  real(dp)::mass,log_mdot,mean_mdot,mass_reduced,star_mass,pi"
  write(ilun,format)"  real(dp)::de1,de2,dd1,dd2,mass_table,Lum,radius,mdot_real,y1,y2,z2,z1,a,b,surface"
  write(ilun,format)""
  write(ilun,format)"  dt_acc=huge(0._dp)"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/pi*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  scale_m=scale_d*scale_l**3d0"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  d_star=n_star/scale_nH"
  write(ilun,format)""
  write(ilun,format)"  ! Compute sink particle accretion rate by averaging contributions from all levels"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     density=0.d0; volume=0.d0; velocity=0.d0; ethermal=0d0"
  write(ilun,format)"     do i=levelmin,nlevelmax"
  write(ilun,format)"        density=density+weighted_density(isink,i)"
  write(ilun,format)"        ethermal=ethermal+weighted_ethermal(isink,i)"
  write(ilun,format)"        velocity(1:3)=velocity(1:3)+weighted_momentum(isink,i,1:3)"
  write(ilun,format)"        volume=volume+weighted_volume(isink,i)"
  write(ilun,format)"     end do"
  write(ilun,format)"     mgas=density"
  write(ilun,format)"     density=density/(volume+tiny(0.0_dp))"
  write(ilun,format)"     if (density>0)then"
  write(ilun,format)"        velocity(1:3)=velocity(1:3)/(density*volume+tiny(0.0_dp))"
  write(ilun,format)"        ethermal=ethermal/(density*volume+tiny(0.0_dp))"
  write(ilun,format)"        c2=MAX((gamma-1.0)*ethermal,smallc**2)"
  write(ilun,format)"        c2sink(isink)=c2"
  write(ilun,format)"        v2=SUM((velocity(1:3)-vsink(isink,1:3))**2)"
  write(ilun,format)"        v_bondi=sqrt(c2+v2)"
  write(ilun,format)""
  write(ilun,format)"        ! Compute Bondi-Hoyle accretion rate in code units"
  write(ilun,format)"        if (star.and.acc_sink_boost.lt.0.0)then"
  write(ilun,format)"           boost=max((density/d_star)**2,1.0_dp)"
  write(ilun,format)"        else"
  write(ilun,format)"           boost=abs(acc_sink_boost)"
  write(ilun,format)"        end if"
  write(ilun,format)""
  write(ilun,format)"        v_bondi=v_bondi*boost**(-1./3.)"
  write(ilun,format)""
  write(ilun,format)"        ! Bondi radius"
  write(ilun,format)"        r2=(factG*msink(isink)/v_bondi**2)**2"
  write(ilun,format)""
  write(ilun,format)"        ! extrapolate to rho_inf"
  write(ilun,format)"        rho_inf=density/(bondi_alpha(ir_cloud*0.5*dx_min/r2**0.5))"
  write(ilun,format)""
  write(ilun,format)"        ! use other values for lambda depending on the EOS, this is for isothermal"
  write(ilun,format)"        dMBHoverdt(isink)=4.*3.1415926*rho_inf*r2*v_bondi"
  write(ilun,format)"        dMEDoverdt(isink)=4.*3.1415926*6.67d-8*msink(isink)*1.66d-24/(0.1*6.652d-25*3d10)*scale_t"
  write(ilun,format)""
  write(ilun,format)"        ! set sink accretion rate to Bondi value"
  write(ilun,format)"        if(smbh.or.bondi_accretion)dMsink_overdt(isink)=dMBHoverdt(isink)"
  write(ilun,format)""
  write(ilun,format)"        ! limit accretion to Eddington rate"
  write(ilun,format)"        if(eddington_limit)then"
  write(ilun,format)"             dMsink_overdt(isink)=min(dMBHoverdt(isink),dMEDoverdt(isink))"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! store average quantities for accretion and diagnostics"
  write(ilun,format)"        eps_sink(isink)=ethermal"
  write(ilun,format)"        rho_gas(isink)=density"
  write(ilun,format)"        volume_gas(isink)=volume"
  write(ilun,format)"        vel_gas(isink,1:ndim)=velocity(1:ndim)"
  write(ilun,format)""
  write(ilun,format)"        ! make sure, accretion rate is positive"
  write(ilun,format)"        dMsink_overdt(isink)=max(0.d0,dMsink_overdt(isink))"
  write(ilun,format)""
  write(ilun,format)"        ! compute maximum timestep allowed by sink"
  write(ilun,format)"        if (dMsink_overdt(isink)>0.0)then"
  write(ilun,format)""
  write(ilun,format)"           ! make sure that sink doesnt accrete more than the gas mass within one timestep"
  write(ilun,format)"           if (bondi_accretion .or. flux_accretion)dt_acc(isink)=c_acc*mgas/dMsink_overdt(isink)"
  write(ilun,format)"           ! make sure that sink doesnt accrete more than its own mass within one timestep"
  write(ilun,format)"           dt_acc(isink)=min(dt_acc(isink),(c_acc*msink(isink)/dMsink_overdt(isink)))"
  write(ilun,format)""
  write(ilun,format)"           ! make sure that agn feedback doesn't increase the thermal energy of the gas too much"
  write(ilun,format)"           if(agn)then"
  write(ilun,format)""
  write(ilun,format)"              ! check whether we should have AGN feedback"
  write(ilun,format)"              ok_blast_agn(isink)=.false."
  write(ilun,format)"              T2_gas=ethermal*scale_T2 ! in Kelvin"
  write(ilun,format)"              delta_mass_min = mgas*(T2_min-T2_gas)/(T2_AGN-T2_min)"
  write(ilun,format)"              if((T2_gas.ge.T2_min).or.(delta_mass(isink).ge.mgas*(T2_min-T2_gas)/(T2_AGN-T2_min)))then"
  write(ilun,format)"                ok_blast_agn(isink)=.true."
  write(ilun,format)"              end if"
  write(ilun,format)"              if(myid==1.and.verbose_AGN.and.ok_blast_agn(isink).and.delta_mass(isink).gt.0.)then"
  write(ilun,format)"                write(*,'('***BLAST***',I4,1X,4(1PE12.5,1X))')isink &"
  write(ilun,format)"                    & ,msink(isink)*scale_d*scale_l**3/2d33 &"
  write(ilun,format)"                    & ,delta_mass(isink)*scale_d*scale_l**3/2d33 &"
  write(ilun,format)"                    & ,((delta_mass(isink)*T2_AGN+mgas*T2_gas) &"
  write(ilun,format)"                    & /(delta_mass(isink)+mgas))"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              ! make sure that sink doesnt blast more than the gas internal energy within one timestep"
  write(ilun,format)"!              if((T2_gas.ge.T2_min).or.(delta_mass(isink).ge.delta_mass_min))then"
  write(ilun,format)"!                 dt_acc(isink)=min(dt_acc(isink),(c_acc*mgas*T2_gas/(dMsink_overdt(isink)*T2_AGN)))"
  write(ilun,format)"!              end if"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  if(PMS_evol .and. rt_feedback)then"
  write(ilun,format)"     if(Hosokawa_track)then"
  write(ilun,format)"        ! Compute internal luminosity from Hosokawa PMS tracks"
  write(ilun,format)"        do isink=1,nsink"
  write(ilun,format)"           star_mass=facc_star*msink(isink)"
  write(ilun,format)"!           if((star_mass*scale_m/Msun) .gt. 1.d-2)then! .and. (t-tsink(isink))*(scale_t/year) .gt. larson_lifetime)then "
  write(ilun,format)"              if(star_mass*scale_m/Msun .gt. 7.1d-2)then"
  write(ilun,format)"                 mean_mdot = star_mass/(t-tsink(isink))*scale_m/Msun &"
  write(ilun,format)"                      & /(scale_t/year) !in msun/year"
  write(ilun,format)"                 mass = star_mass*scale_m/Msun"
  write(ilun,format)"                 "
  write(ilun,format)"                 mass=log10(mass)"
  write(ilun,format)"                 log_mdot = log10(mean_mdot)"
  write(ilun,format)"                 imdot = floor(log_mdot) + 8"
  write(ilun,format)"                 "
  write(ilun,format)"                 if(imdot .lt. 1)then"
  write(ilun,format)"                    imdot=1              "
  write(ilun,format)"                    mass_table=-10.0"
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          lum = data_PMS(imdot,i+1,3)"
  write(ilun,format)"                          radius = data_PMS(imdot,i+1,4)"
  write(ilun,format)"                          GOTO 110"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"  "
  write(ilun,format)" !                   if(myid==1)print*,'imdot lt 1',i,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                  "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,3)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    y1 = data_PMS(imdot,i  ,1)"
  write(ilun,format)"                    y2 = data_PMS(imdot,i-1,1)"
  write(ilun,format)"                    "
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                 "
  write(ilun,format)"                    lum = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,4)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,4)"
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    "
  write(ilun,format)" !          print*,'Luminosity=',lum,'Lsol',', mass=',mass,'Msol'"
  write(ilun,format)"                    "
  write(ilun,format)"                 else if(imdot .ge. 5)then"
  write(ilun,format)"                    imdot=5"
  write(ilun,format)"                    "
  write(ilun,format)"                    mass_table=-10.0"
  write(ilun,format)"                    i=1"
  write(ilun,format)"!                    if(myid==1)print*,i,mass_table,mass, nb_ligne_PMS(imdot),log_mdot"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          lum = data_PMS(imdot,i+1,3)"
  write(ilun,format)"                          radius = data_PMS(imdot,i+1,4)"
  write(ilun,format)"                          GOTO 110"
  write(ilun,format)"                       end if"
  write(ilun,format)"                        i=i+1"
  write(ilun,format)"                        mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"!                    if(myid==1)print*,'imdot ge 5',i,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,3)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    y1 = data_PMS(imdot,i  ,1)"
  write(ilun,format)"                    y2 = data_PMS(imdot,i-1,1)"
  write(ilun,format)"                    "
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    lum = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                    z1 = data_PMS(imdot,i  ,4)"
  write(ilun,format)"                    z2 = data_PMS(imdot,i-1,4)"
  write(ilun,format)"                    a = (z2-z1)/(y2-y1)"
  write(ilun,format)"                    b=z2-a*y2"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = a*mass + b"
  write(ilun,format)"                    "
  write(ilun,format)"                 else !if(imdot .gt. 1 .and. imdot .lt. 5)then"
  write(ilun,format)"                    mdot_real = float(imdot-8)"
  write(ilun,format)"                    "
  write(ilun,format)"                    !   mdot=log10(mdot)"
  write(ilun,format)"                    dd1 = log_mdot - (mdot_real)"
  write(ilun,format)"                    "
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          GOTO 130"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"130                 dd2 = mass - mass_table"
  write(ilun,format)"                    im1=i"
  write(ilun,format)"                    "
  write(ilun,format)"                    i=1"
  write(ilun,format)"                    mass_table = data_PMS(imdot+1,i,1)"
  write(ilun,format)"                    do while(mass_table .lt. mass)"
  write(ilun,format)"                       dd2 = mass - mass_table      "
  write(ilun,format)"                       if((i+1) .gt. nb_ligne_PMS(imdot))then"
  write(ilun,format)"                          GOTO 140"
  write(ilun,format)"                       end if"
  write(ilun,format)"                       i=i+1"
  write(ilun,format)"                       mass_table = data_PMS(imdot+1,i,1)"
  write(ilun,format)"                    end do"
  write(ilun,format)"                    "
  write(ilun,format)"140                 im2=i"
  write(ilun,format)"                    "
  write(ilun,format)"                    de1 = 1.0d0 - dd1"
  write(ilun,format)"                    de2 = 1.0d0 - dd2"
  write(ilun,format)"                    Lum = 0.d0"
  write(ilun,format)"                    "
  write(ilun,format)"!if(myid==1)print*,im1,im2,imdot,star_mass*scale_m/Msun"
  write(ilun,format)"                    Lum = Lum + de1*de2*data_PMS(imdot  ,im1  ,3)"
  write(ilun,format)"                    Lum = Lum + dd1*de2*data_PMS(imdot+1,im2  ,3)"
  write(ilun,format)"                    Lum = Lum + de1*dd2*data_PMS(imdot  ,im1-1,3)"
  write(ilun,format)"                    Lum = Lum + dd1*dd2*data_PMS(imdot+1,im2-1,3)"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = 0.d0"
  write(ilun,format)"                    "
  write(ilun,format)"                    radius = radius + de1*de2*data_PMS(imdot  ,im1  ,4)"
  write(ilun,format)"                    radius = radius + dd1*de2*data_PMS(imdot+1,im2  ,4)"
  write(ilun,format)"                    radius = radius + de1*dd2*data_PMS(imdot  ,im1-1,4)"
  write(ilun,format)"                    radius = radius + dd1*dd2*data_PMS(imdot+1,im2-1,4)"
  write(ilun,format)"                    "
  write(ilun,format)"                 end if"
  write(ilun,format)"                 "
  write(ilun,format)"110              int_lum(isink) = (10.0d0**(lum))*Lsun/(scale_d*scale_v**2*scale_l**3/scale_t)"
  write(ilun,format)"                 radius=(10.0d0**radius)*Rsun/scale_l"
  write(ilun,format)" !             end ifs"
  write(ilun,format)"!              acc_lum(isink) = facc_star_lum*star_mass*star_mass/(t-tsink(isink))/radius!acc_rate(isink)/radiu"
  write(ilun,format)"              acc_lum(isink) = facc_star_lum*star_mass*facc_star*acc_rate(isink)/radius"
  write(ilun,format)""
  write(ilun,format)"!              print*,'Acc_lum',facc_star_lum,star_mass,(t-tsink(isink)),radius!acc_rate(isink)/radius"
  write(ilun,format)"              lum_sink(isink)=acc_lum(isink)+int_lum(isink)"
  write(ilun,format)"              surface = 4.*pi*(radius*scale_l)**2 ! stellar surface in cgs"
  write(ilun,format)"              Teff_sink(isink) = (lum_sink(isink) *(scale_d*scale_v**2*scale_l**3/scale_t) /(5.6705d-5*surface))**0.25"
  write(ilun,format)"              rsink_star(isink) = radius"
  write(ilun,format)""
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     else ! compute luminosity following the empirical Mass-Luminosity relation (Cox & Giuli's book, p. 8) "
  write(ilun,format)"        do isink=1,nsink"
  write(ilun,format)"           star_mass=facc_star*msink(isink)"
  write(ilun,format)"           if((star_mass*scale_m/Msun) .gt. 1.d-2 .and. (t-tsink(isink))*(scale_t/year) .gt. 5000.)then "
  write(ilun,format)"              lum = -10."
  write(ilun,format)"              mass_reduced=star_mass*scale_m/Msun"
  write(ilun,format)"              if((mass_reduced .gt. 2.d-1) .and. (mass_reduced .lt. 6.d-1)  )then"
  write(ilun,format)"                 lum=-0.59d0+2.64d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 6.d-1) .and. (mass_reduced .lt. 2.5)  )then"
  write(ilun,format)"                 lum=-0.13d0+4.55d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 2.5) .and. (mass_reduced .lt. 20.0d0)  )then"
  write(ilun,format)"                 lum=0.27d0+3.60d0*log10(mass_reduced)"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              if(lum .ne. -10)then"
  write(ilun,format)"                 int_lum(isink)=(10.0d0**(lum))*Lsun/(scale_d*scale_v**2*scale_l**3/scale_t)"
  write(ilun,format)"              else"
  write(ilun,format)"                 int_lum(isink)=0.0d0"
  write(ilun,format)"              end if"
  write(ilun,format)"              "
  write(ilun,format)"              acc_lum(isink) = 0.0d0"
  write(ilun,format)"              radius=-0.66d0 ! Lower limit form Cox book, ~ 0.2 R_sol"
  write(ilun,format)"              mass_reduced=star_mass*scale_m/Msun"
  write(ilun,format)"              if((mass_reduced .gt. 2.d-1) .and. (mass_reduced .lt. 1.5)  )then"
  write(ilun,format)"                 radius=-0.03d0+0.9d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 1.5d0) .and. (mass_reduced .lt. 5)  )then"
  write(ilun,format)"                 radius=0.05d0+0.51d0*log10(mass_reduced)"
  write(ilun,format)"              else if((mass_reduced .gt. 5.) .and. (mass_reduced .lt. 20.0d0)  )then"
  write(ilun,format)"                 radius=-0.13d0+0.78d0*log10(mass_reduced)"
  write(ilun,format)"              end if"
  write(ilun,format)"              radius=(10.0d0**radius)*Rsun/scale_l"
  write(ilun,format)"              acc_lum(isink) = facc_star_lum*star_mass*acc_rate(isink)/radius"
  write(ilun,format)"              "
  write(ilun,format)"              lum_sink(isink)=acc_lum(isink)+int_lum(isink)"
  write(ilun,format)""
  write(ilun,format)"              surface = 4.*pi*(radius*scale_l)**2 ! stellar surface in cgs"
  write(ilun,format)"              Teff_sink(isink) = (lum_sink(isink) *(scale_d*scale_v**2*scale_l**3/scale_t) /(5.6705d-5*surface))**0.25"
  write(ilun,format)"              rsink_star(isink) = radius ! code units"
  write(ilun,format)""
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if (write_sinks)then"
  write(ilun,format)"     call print_sink_properties(dMEDoverdt,rho_inf,r2)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"contains"
  write(ilun,format)"  ! Routine to return alpha, defined as rho/rho_inf, for a critical"
  write(ilun,format)"  ! Bondi accretion solution. The argument is x = r / r_Bondi."
  write(ilun,format)"  ! This is from Krumholz et al. (AJC)"
  write(ilun,format)"  REAL(dp) function bondi_alpha(x)"
  write(ilun,format)"    implicit none"
  write(ilun,format)"    REAL(dp) x"
  write(ilun,format)"    REAL(dp), PARAMETER :: XMIN=0.01, xMAX=2.0"
  write(ilun,format)"    INTEGER, PARAMETER :: NTABLE=51"
  write(ilun,format)"    REAL(dp) lambda_c, xtable, xtablep1, alpha_exp"
  write(ilun,format)"    integer idx"
  write(ilun,format)"    !     Table of alpha values. These correspond to x values that run from"
  write(ilun,format)"    !     0.01 to 2.0 with uniform logarithmic spacing. The reason for"
  write(ilun,format)"    !     this choice of range is that the asymptotic expressions are"
  write(ilun,format)"    !     accurate to better than 2% outside this range."
  write(ilun,format)"    REAL(dp), PARAMETER, DIMENSION(NTABLE) :: alphatable = (/ &"
  write(ilun,format)"         820.254, 701.882, 600.752, 514.341, 440.497, 377.381, 323.427, &"
  write(ilun,format)"         277.295, 237.845, 204.1, 175.23, 150.524, 129.377, 111.27, 95.7613, &"
  write(ilun,format)"         82.4745, 71.0869, 61.3237, 52.9498, 45.7644, 39.5963, 34.2989, &"
  write(ilun,format)"         29.7471, 25.8338, 22.4676, 19.5705, 17.0755, 14.9254, 13.0714, &"
  write(ilun,format)"         11.4717, 10.0903, 8.89675, 7.86467, 6.97159, 6.19825, 5.52812, &"
  write(ilun,format)"         4.94699, 4.44279, 4.00497, 3.6246, 3.29395, 3.00637, 2.75612, &"
  write(ilun,format)"         2.53827, 2.34854, 2.18322, 2.03912, 1.91344, 1.80378, 1.70804, &"
  write(ilun,format)"         1.62439 /)"
  write(ilun,format)"    !     Define a constant that appears in these formulae"
  write(ilun,format)"    lambda_c    = 0.25 * exp(1.5)"
  write(ilun,format)"    !     Deal with the off-the-table cases"
  write(ilun,format)"    if (x .le. XMIN) then"
  write(ilun,format)"       bondi_alpha = lambda_c / sqrt(2. * x**3)"
  write(ilun,format)"    else if (x .ge. XMAX) then"
  write(ilun,format)"       bondi_alpha = exp(1./x)"
  write(ilun,format)"    else"
  write(ilun,format)"       !     We are on the table"
  write(ilun,format)"       idx = floor ((NTABLE-1) * log(x/XMIN) / log(XMAX/XMIN))"
  write(ilun,format)"       xtable = exp(log(XMIN) + idx*log(XMAX/XMIN)/(NTABLE-1))"
  write(ilun,format)"       xtablep1 = exp(log(XMIN) + (idx+1)*log(XMAX/XMIN)/(NTABLE-1))"
  write(ilun,format)"       alpha_exp = log(x/xtable) / log(xtablep1/xtable)"
  write(ilun,format)"       !     Note the extra +1s below because of fortran 1 offset arrays"
  write(ilun,format)"       bondi_alpha = alphatable(idx+1) * (alphatable(idx+2)/alphatable(idx+1))**alpha_exp"
  write(ilun,format)"    end if"
  write(ilun,format)"  end function bondi_alpha"
  write(ilun,format)""
  write(ilun,format)"end subroutine compute_accretion_rate"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine print_sink_properties(dMEDoverdt,rho_inf,r2)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp),dimension(1:nsinkmax)::dMEDoverdt"
  write(ilun,format)"  integer::i,isink"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v,scale_m"
  write(ilun,format)"  real(dp)::l_abs"
  write(ilun,format)"  real(dp)::r2,rho_inf"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  scale_m=scale_d*scale_l**3d0"
  write(ilun,format)""
  write(ilun,format)"  if (smbh) then"
  write(ilun,format)"     if(myid==1.and.nsink>0)then"
  write(ilun,format)"        xmsink(1:nsink)=msink(1:nsink)"
  write(ilun,format)"        call quick_sort_dp(xmsink(1),idsink_sort(1),nsink)"
  write(ilun,format)"        write(*,*)'Number of sink = ',nsink"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        write(*,'(' Id     Mass(Msol) Bondi(Msol/yr)   Edd(Msol/yr)              x              y              z')')"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        do i=nsink,max(nsink-10,1),-1"
  write(ilun,format)"           isink=idsink_sort(i)"
  write(ilun,format)"           write(*,'(I3,10(1X,1PE14.7))')idsink(isink),msink(isink)*scale_m/2d33 &"
  write(ilun,format)"                & ,dMBHoverdt(isink)*scale_m/scale_t/(2d33/(365.*24.*3600.)) &"
  write(ilun,format)"                & ,dMEDoverdt(isink)*scale_m/scale_t/(2d33/(365.*24.*3600.)) &"
  write(ilun,format)"                & ,xsink(isink,1:ndim),delta_mass(isink)*scale_m/2d33"
  write(ilun,format)"        end do"
  write(ilun,format)"        write(*,'(' ============================================================================================')')"
  write(ilun,format)"        if(verbose_AGN)then"
  write(ilun,format)"          write(*,'(' Id     rho(H/cc)  rho_inf(H/cc) Mgas(Msol) cs(km/s) rBondi(pc)')')"
  write(ilun,format)"          write(*,'(' vgas(km/s):  x   y   z     vsink(km/s):  x   y   z')')"
  write(ilun,format)"          write(*,'(' ============================================================================================')')"
  write(ilun,format)"          do i=nsink,max(nsink-10,1),-1"
  write(ilun,format)"            isink=idsink_sort(i)"
  write(ilun,format)"            write(*,'(I3,12(1X,1PE14.7))')idsink(isink),rho_gas(isink)*scale_nH,rho_inf*scale_nH &"
  write(ilun,format)"                & ,rho_gas(isink)*volume_gas(isink)*scale_m/2d33,sqrt(c2sink(isink))*scale_v/1e5 &"
  write(ilun,format)"                & ,sqrt(r2)*scale_l/3.086e18"
  write(ilun,format)"            write(*,'(6(1X,1PE14.7))')vel_gas(isink,1:ndim)*scale_v/1e5,vsink(isink,1:ndim)*scale_v/1e5"
  write(ilun,format)"          end do"
  write(ilun,format)"          write(*,'(' ============================================================================================')')"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)"  if (.not. smbh)then"
  write(ilun,format)"     if(myid==1.and.nsink>0.and. mod(nstep_coarse,ncontrol)==0)then"
  write(ilun,format)"        xmsink(1:nsink)=msink(1:nsink)"
  write(ilun,format)"        call quick_sort_dp(xmsink(1),idsink_sort(1),nsink)"
  write(ilun,format)"        write(*,*)'Number of sink = ',nsink"
  write(ilun,format)"        write(*,*)'Total mass in sink = ',sum(msink(1:nsink))*scale_m/Msun"
  write(ilun,format)"        write(*,*)'simulation time = ',t"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"        write(*,'('   Id     M[Msol]          x             y             z            vx            vy            vz    acc_rate[Msol/y] acc_lum[Lsol]     age[y]    int_lum[Lsol]     Teff [K] ')')"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"        do i=nsink,1,-1"
  write(ilun,format)"           isink=idsink_sort(i)"
  write(ilun,format)"           l_abs=(lsink(isink,1)**2+lsink(isink,2)**2+lsink(isink,3)**2)**0.5+1.d10*tiny(0.d0)"
  write(ilun,format)"           write(*,'(I5,12(2X,E12.5))')&"
  write(ilun,format)"                idsink(isink),msink(isink)*scale_m/Msun, &"
  write(ilun,format)"                xsink(isink,1:ndim),vsink(isink,1:ndim),&"
  write(ilun,format)"                acc_rate(isink)*scale_m/Msun/(scale_t)*year,acc_lum(isink)/scale_t**2*scale_l**3*scale_d*scale_l**2/scale_t/Lsun,&"
  write(ilun,format)"                (t-tsink(isink))*scale_t/year,&"
  write(ilun,format)"                int_lum(isink)*scale_d*scale_l**3*scale_v**2/scale_t/Lsun,Teff_sink(isink)"
  write(ilun,format)"        end do"
  write(ilun,format)"        write(*,'(' ============================================================================================================================================================================= ')')"
  write(ilun,format)"     endif"
  write(ilun,format)"  endif"
  write(ilun,format)"end subroutine print_sink_properties"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine quenching(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine selects regions which are eligible for SMBH formation."
  write(ilun,format)"  ! It is based on a stellar density threshold and on a stellar velocity"
  write(ilun,format)"  ! dispersion threshold."
  write(ilun,format)"  ! On exit, flag2 array is set to 0 for AGN sites and to 1 otherwise."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  real(dp)::str_d,tot_m,ave_u,ave_v,ave_w,sig_u,sig_v,sig_w"
  write(ilun,format)"  integer::igrid,ipart,jpart,next_part,ind_cell,iskip,ind"
  write(ilun,format)"  integer::i,npart1,npart2,nx_loc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  ! Gather star particles only."
  write(ilun,format)""
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  do i=1,active(ilevel)%ngrid"
  write(ilun,format)"     igrid=active(ilevel)%igrid(i)"
  write(ilun,format)"     ! Number of particles in the grid"
  write(ilun,format)"     npart1=numbp(igrid)"
  write(ilun,format)"     npart2=0"
  write(ilun,format)""
  write(ilun,format)"     ! Reset velocity moments"
  write(ilun,format)"     str_d=0.0"
  write(ilun,format)"     tot_m=0.0"
  write(ilun,format)"     ave_u=0.0"
  write(ilun,format)"     ave_v=0.0"
  write(ilun,format)"     ave_w=0.0"
  write(ilun,format)"     sig_u=0.0"
  write(ilun,format)"     sig_v=0.0"
  write(ilun,format)"     sig_w=0.0"
  write(ilun,format)""
  write(ilun,format)"     ! Count star particles"
  write(ilun,format)"     if(npart1>0)then"
  write(ilun,format)"        ipart=headp(igrid)"
  write(ilun,format)"        ! Loop over particles"
  write(ilun,format)"        do jpart=1,npart1"
  write(ilun,format)"           ! Save next particle   <--- Very important !!!"
  write(ilun,format)"           next_part=nextp(ipart)"
  write(ilun,format)"           if(idp(ipart).gt.0.and.tp(ipart).ne.0)then"
  write(ilun,format)"              npart2=npart2+1"
  write(ilun,format)"              tot_m=tot_m+mp(ipart)"
  write(ilun,format)"              ave_u=ave_u+mp(ipart)*vp(ipart,1)"
  write(ilun,format)"              ave_v=ave_v+mp(ipart)*vp(ipart,2)"
  write(ilun,format)"              ave_w=ave_w+mp(ipart)*vp(ipart,3)"
  write(ilun,format)"              sig_u=sig_u+mp(ipart)*vp(ipart,1)**2"
  write(ilun,format)"              sig_v=sig_v+mp(ipart)*vp(ipart,2)**2"
  write(ilun,format)"              sig_w=sig_w+mp(ipart)*vp(ipart,3)**2"
  write(ilun,format)"           endif"
  write(ilun,format)"           ipart=next_part  ! Go to next particle"
  write(ilun,format)"        end do"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Normalize velocity moments"
  write(ilun,format)"     if(npart2.gt.0)then"
  write(ilun,format)"        ave_u=ave_u/tot_m"
  write(ilun,format)"        ave_v=ave_v/tot_m"
  write(ilun,format)"        ave_w=ave_w/tot_m"
  write(ilun,format)"        sig_u=sqrt(sig_u/tot_m-ave_u**2)*scale_v/1d5"
  write(ilun,format)"        sig_v=sqrt(sig_v/tot_m-ave_v**2)*scale_v/1d5"
  write(ilun,format)"        sig_w=sqrt(sig_w/tot_m-ave_w**2)*scale_v/1d5"
  write(ilun,format)"        str_d=tot_m/(2**ndim*vol_loc)*scale_nH"
  write(ilun,format)"     endif"
  write(ilun,format)""
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        ind_cell=iskip+igrid"
  write(ilun,format)"        ! AGN formation sites"
  write(ilun,format)"        ! if n_star>0.1 H/cc and v_disp>100 km/s"
  write(ilun,format)"        if(str_d>0.1.and.MAX(sig_u,sig_v,sig_w)>100.)then"
  write(ilun,format)"           flag2(ind_cell)=0"
  write(ilun,format)"        else"
  write(ilun,format)"           flag2(ind_cell)=1"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering quenching for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine quenching"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine make_sink_from_clump(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use clfind_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info,icpu"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! This routine uses creates a sink in every cell which was flagged (flag2)"
  write(ilun,format)"  ! The global sink variables are updated"
  write(ilun,format)"  ! The true RAMSES particle is NOT produced here..."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer ::ncache,nnew,ivar,ngrid,index_sink,index_sink_tot"
  write(ilun,format)"  integer ::igrid,ix,iy,iz,ind,i,iskip,isink,nx_loc"
  write(ilun,format)"  integer ::ntot,ntot_all"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid_new,ind_cell_new"
  write(ilun,format)"  integer ,dimension(1:ncpu)::ntot_sink_cpu"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  integer ,dimension(1:ncpu)::ntot_sink_all"
  write(ilun,format)"#endif"
  write(ilun,format)"  logical ::ok_free"
  write(ilun,format)"  real(dp)::d,u,v,w,e,factG,delta_d,v2,eint"
  write(ilun,format)"  real(dp)::birth_epoch"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  real(dp)::fourpi,threepi2,tff,tsal"
  write(ilun,format)"  real(dp)::scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2"
  write(ilun,format)"  real(dp)::mclump"
  write(ilun,format)"  real(dp),dimension(1:nvar)::z"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc,x"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp)::bx1,bx2,by1,by2,bz1,bz2"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ht"
  write(ilun,format)"  real(dp)::temp"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"  integer::irad"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'entering make_sink_from_clump for level ',ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  ! Conversion factor from user units to cgs units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  ! Birth epoch as proper time"
  write(ilun,format)"  if(use_proper_time)then"
  write(ilun,format)"     birth_epoch=texp"
  write(ilun,format)"  else"
  write(ilun,format)"     birth_epoch=t"
  write(ilun,format)"  endif"
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Set new sink variables to zero"
  write(ilun,format)"  msink_new=0d0; mseed_new=0d0; tsink_new=0d0; delta_mass_new=0d0; xsink_new=0d0; vsink_new=0d0"
  write(ilun,format)"  oksink_new=0d0; idsink_new=0; new_born_new=.false."
  write(ilun,format)"  dmfsink_new=0d0"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ! and count number of new sinks (flagged cells)"
  write(ilun,format)"  !------------------------------------------------"
  write(ilun,format)"  ntot=0"
  write(ilun,format)"  ntot_sink_cpu=0"
  write(ilun,format)"  if(numbtot(1,ilevel)>0)then"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if(flag2(ind_cell(i))>0)then"
  write(ilun,format)"                 ntot=ntot+1"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"  ! Compute global sink statistics"
  write(ilun,format)"  !---------------------------------"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(ntot,ntot_all,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifdef WITHOUTMPI"
  write(ilun,format)"  ntot_all=ntot"
  write(ilun,format)"#endif"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  ntot_sink_cpu=0; ntot_sink_all=0"
  write(ilun,format)"  ntot_sink_cpu(myid)=ntot"
  write(ilun,format)"  call MPI_ALLREDUCE(ntot_sink_cpu,ntot_sink_all,ncpu,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  ntot_sink_cpu(1)=ntot_sink_all(1)"
  write(ilun,format)"  do icpu=2,ncpu"
  write(ilun,format)"     ntot_sink_cpu(icpu)=ntot_sink_cpu(icpu-1)+ntot_sink_all(icpu)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  nsink=nsink+ntot_all"
  write(ilun,format)"  nindsink=nindsink+ntot_all"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     if(ntot_all.gt.0)then"
  write(ilun,format)"        write(*,'(' Level = ',I6,' New sinks produced from clumps= ',I6,' Total sinks =',I8)')&"
  write(ilun,format)"             & ilevel,ntot_all,nsink"
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !-------------------------------------------"
  write(ilun,format)"  ! Check wether max number of sink is reached"
  write(ilun,format)"  !------------------------------------------"
  write(ilun,format)"  ok_free=(nsink+ntot_all<=nsinkmax)"
  write(ilun,format)"  if(.not. ok_free)then"
  write(ilun,format)"     if(myid==1)write(*,*)'global list of sink particles is too long'"
  write(ilun,format)"     if(myid==1)write(*,*)'New sink particles',ntot_all"
  write(ilun,format)"     if(myid==1)write(*,*)'Increase nsinkmax'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  ! Create new sink particles"
  write(ilun,format)"  !------------------------------"
  write(ilun,format)"  ! Starting identity number"
  write(ilun,format)"  if(myid==1)then"
  write(ilun,format)"     index_sink=nsink-ntot_all"
  write(ilun,format)"     index_sink_tot=nindsink-ntot_all"
  write(ilun,format)"  else"
  write(ilun,format)"     index_sink=nsink-ntot_all+ntot_sink_cpu(myid-1)"
  write(ilun,format)"     index_sink_tot=nindsink-ntot_all+ntot_sink_cpu(myid-1)"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  if(numbtot(1,ilevel)>0)then"
  write(ilun,format)"     ncache=active(ilevel)%ngrid"
  write(ilun,format)"     do igrid=1,ncache,nvector"
  write(ilun,format)"        ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over cells"
  write(ilun,format)"        do ind=1,twotondim"
  write(ilun,format)"           iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Gather cells with a new sink"
  write(ilun,format)"           nnew=0"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              if (flag2(ind_cell(i))>0)then"
  write(ilun,format)"                 nnew=nnew+1"
  write(ilun,format)"                 ind_grid_new(nnew)=ind_grid(i)"
  write(ilun,format)"                 ind_cell_new(nnew)=ind_cell(i)"
  write(ilun,format)"              end if"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Create new sink particles"
  write(ilun,format)"           do i=1,nnew"
  write(ilun,format)"              index_sink=index_sink+1"
  write(ilun,format)"              index_sink_tot=index_sink_tot+1"
  write(ilun,format)""
  write(ilun,format)"              ! Convert uold to primitive variables"
  write(ilun,format)"              d=max(uold(ind_cell_new(i),1),smallr)"
  write(ilun,format)"              u=uold(ind_cell_new(i),2)/d"
  write(ilun,format)"              v=uold(ind_cell_new(i),3)/d"
  write(ilun,format)"              w=uold(ind_cell_new(i),4)/d"
  write(ilun,format)"              e=uold(ind_cell_new(i),5)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              bx1=uold(ind_cell_new(i),6)"
  write(ilun,format)"              by1=uold(ind_cell_new(i),7)"
  write(ilun,format)"              bz1=uold(ind_cell_new(i),8)"
  write(ilun,format)"              bx2=uold(ind_cell_new(i),nvar+1)"
  write(ilun,format)"              by2=uold(ind_cell_new(i),nvar+2)"
  write(ilun,format)"              bz2=uold(ind_cell_new(i),nvar+3)"
  write(ilun,format)"              e=e-0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"              v2=(u**2+v**2+w**2)"
  write(ilun,format)"              e=e-0.5d0*d*v2"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 e=e-uold(ind_cell_new(i),inener-1+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              e=e/d"
  write(ilun,format)"              if(energy_fix)e=uold(ind_cell_new(i),nvar)/d"
  write(ilun,format)"              eint=e*d"
  write(ilun,format)"              call temperature_eos(d,eint,temp,ht)"
  write(ilun,format)""
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 z(ivar)=uold(ind_cell_new(i),ivar)/d"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Get density maximum by quadratic expansion around cell center"
  write(ilun,format)"              x(1)=(xg(ind_grid_new(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"              x(2)=(xg(ind_grid_new(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"              x(3)=(xg(ind_grid_new(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"              call true_max(x(1),x(2),x(3),nlevelmax)"
  write(ilun,format)""
  write(ilun,format)"              ! Mass of the new sink"
  write(ilun,format)"              if(mass_sink_seed>=0.0)then"
  write(ilun,format)"                 mseed_new(index_sink)=mass_sink_seed*2d33/(scale_d*scale_l**3)"
  write(ilun,format)"              else"
  write(ilun,format)"                 if(smbh)then"
  write(ilun,format)"                    ! The SMBH/sink mass is the mass that will heat the gas to 10**7 K after creation"
  write(ilun,format)"                    fourpi=4.0d0*ACOS(-1.0d0)"
  write(ilun,format)"                    threepi2=3.0d0*ACOS(-1.0d0)**2"
  write(ilun,format)"                    if(cosmo)fourpi=1.5d0*omega_m*aexp"
  write(ilun,format)"                    tff=sqrt(threepi2/8./fourpi/max(d,smallr))"
  write(ilun,format)"                    tsal=0.1*6.652d-25*3d10/4./3.1415926/6.67d-8/1.66d-24/scale_t"
  write(ilun,format)"                    mclump=clump_mass4(flag2(ind_cell_new(i)))"
  write(ilun,format)"                    mseed_new(index_sink)=min(1.d-5/1.0*mclump*tsal/tff,mclump/2.0)"
  write(ilun,format)"                 end if"
  write(ilun,format)""
  write(ilun,format)"                 if(smbh.and.agn)then"
  write(ilun,format)"                    mclump=clump_mass4(flag2(ind_cell_new(i)))"
  write(ilun,format)"                    mseed_new(index_sink)=0.5*T2_min/T2_AGN*mclump"
  write(ilun,format)"                 end if"
  write(ilun,format)"              endif"
  write(ilun,format)""
  write(ilun,format)"              ! Give a tiny bit of mass to the sink..."
  write(ilun,format)"              delta_d=d*1.d-10"
  write(ilun,format)"              msink_new(index_sink)=delta_d*vol_loc"
  write(ilun,format)"              delta_mass_new(index_sink)=msink_new(index_sink)"
  write(ilun,format)""
  write(ilun,format)"              ! introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"              dmfsink_new(index_sink)=msink_new(index_sink)"
  write(ilun,format)""
  write(ilun,format)"              ! Global index of the new sink"
  write(ilun,format)"              oksink_new(index_sink)=1d0"
  write(ilun,format)"              idsink_new(index_sink)=index_sink_tot"
  write(ilun,format)""
  write(ilun,format)"              ! Store properties of the new sink"
  write(ilun,format)"              tsink_new(index_sink)=birth_epoch"
  write(ilun,format)"              xsink_new(index_sink,1:3)=x(1:3)"
  write(ilun,format)"              vsink_new(index_sink,1)=u"
  write(ilun,format)"              vsink_new(index_sink,2)=v"
  write(ilun,format)"              vsink_new(index_sink,3)=w"
  write(ilun,format)"              new_born_new(index_sink)=.true."
  write(ilun,format)""
  write(ilun,format)"              ! Convert back to conservative variable"
  write(ilun,format)"              d=d-delta_d"
  write(ilun,format)"!              e=e*d"
  write(ilun,format)"              call enerint_eos(d,temp,e)"
  write(ilun,format)"              if(energy_fix)uold(ind_cell_new(i),nvar)=e"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"              e=e+0.125d0*((bx1+bx2)**2+(by1+by2)**2+(bz1+bz2)**2)"
  write(ilun,format)"#endif"
  write(ilun,format)"              e=e+0.5d0*d*(u**2+v**2+w**2)"
  write(ilun,format)"#if NENER>0"
  write(ilun,format)"              do irad=1,nener"
  write(ilun,format)"                 e=e+uold(ind_cell_new(i),inener-1+irad)"
  write(ilun,format)"              end do"
  write(ilun,format)"#endif"
  write(ilun,format)"              uold(ind_cell_new(i),1)=d"
  write(ilun,format)"              uold(ind_cell_new(i),2)=d*u"
  write(ilun,format)"              uold(ind_cell_new(i),3)=d*v"
  write(ilun,format)"              uold(ind_cell_new(i),4)=d*w"
  write(ilun,format)"              uold(ind_cell_new(i),5)=e"
  write(ilun,format)"              do ivar=imetal,lastindex_pscal"
  write(ilun,format)"                 uold(ind_cell_new(i),ivar)=d*z(ivar)"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over new sink particle cells"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over cells"
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(oksink_new,oksink_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(idsink_new,idsink_all,nsinkmax,MPI_INTEGER         ,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(msink_new ,msink_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(mseed_new ,mseed_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"  call MPI_ALLREDUCE(dmfsink_new, dmfsink_all, nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)""
  write(ilun,format)"  call MPI_ALLREDUCE(tsink_new ,tsink_all ,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(xsink_new ,xsink_all ,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(vsink_new ,vsink_all ,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(delta_mass_new,delta_mass_all,nsinkmax,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"  call MPI_ALLREDUCE(new_born_new,new_born_all,nsinkmax,MPI_LOGICAL,MPI_LOR,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  oksink_all=oksink_new"
  write(ilun,format)"  idsink_all=idsink_new"
  write(ilun,format)"  msink_all=msink_new"
  write(ilun,format)"  mseed_all=mseed_new"
  write(ilun,format)""
  write(ilun,format)"  !introduced by PH 09/2013 to compute the feedback from sink"
  write(ilun,format)"  dmfsink_all=dmfsink_new"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  tsink_all=tsink_new"
  write(ilun,format)"  xsink_all=xsink_new"
  write(ilun,format)"  vsink_all=vsink_new"
  write(ilun,format)"  delta_mass_all=delta_mass_new"
  write(ilun,format)"  new_born_all=new_born_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if(oksink_all(isink)==1)then"
  write(ilun,format)"        idsink(isink)=idsink_all(isink)"
  write(ilun,format)"        msink(isink)=msink_all(isink)"
  write(ilun,format)"        mseed(isink)=mseed_all(isink)"
  write(ilun,format)""
  write(ilun,format)"        !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"        dmfsink(isink)=dmfsink_all(isink)"
  write(ilun,format)""
  write(ilun,format)"        tsink(isink)=tsink_all(isink)"
  write(ilun,format)"        xsink(isink,1:ndim)=xsink_all(isink,1:ndim)"
  write(ilun,format)"        vsink(isink,1:ndim)=vsink_all(isink,1:ndim)"
  write(ilun,format)"        delta_mass(isink)=delta_mass_all(isink)"
  write(ilun,format)"        new_born(isink)=new_born_all(isink)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine make_sink_from_clump"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine true_max(x,y,z,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use clfind_commons, only:ivar_clump"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp)::x,y,z"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)"  ! Description: This subroutine takes the cell of maximum density and computes"
  write(ilun,format)"  ! the true maximum by expanding the density around the cell center to second order."
  write(ilun,format)"  !----------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::k,j,i,nx_loc,counter, ioft, n"
  write(ilun,format)"  integer,dimension(1:threetondim)::cell_index,cell_lev"
  write(ilun,format)"  real(dp)::det,dx,dx_loc,scale,disp_max,numerator"
  write(ilun,format)"  real(dp),dimension(-1:1,-1:1,-1:1)::cube3"
  write(ilun,format)"  real(dp),dimension(1:threetondim,1:ndim)::xtest"
  write(ilun,format)"  real(dp),dimension(1:ndim)::gradient,displacement"
  write(ilun,format)"  real(dp),dimension(1:ndim,1:ndim)::hess,minor"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim) :: xtest_temp"
  write(ilun,format)"  real(dp) :: smallreal = 1D-200"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  counter=0"
  write(ilun,format)"  do i=-1,1"
  write(ilun,format)"     do j=-1,1"
  write(ilun,format)"        do k=-1,1"
  write(ilun,format)"           counter=counter+1"
  write(ilun,format)"           xtest(counter,1)=x+i*dx_loc"
  write(ilun,format)"           xtest(counter,2)=y+j*dx_loc"
  write(ilun,format)"           xtest(counter,3)=z+k*dx_loc"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do ioft = 0, threetondim - 1, nvector"
  write(ilun,format)"     n = min(threetondim - ioft, nvector)"
  write(ilun,format)"     xtest_temp = 0.d0 "
  write(ilun,format)"     do i = 1, n"
  write(ilun,format)"       do j = 1, ndim"
  write(ilun,format)"         xtest_temp(i, j) = xtest(ioft + i, j)"
  write(ilun,format)"       end do"
  write(ilun,format)"     end do"
  write(ilun,format)"     call get_cell_index(cell_index(ioft + 1 : ioft + n), cell_lev(ioft + 1 : ioft + n), &"
  write(ilun,format)"          xtest_temp, ilevel, n)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  counter=0"
  write(ilun,format)"  if(ivar_clump==0)then"
  write(ilun,format)"     do i=-1,1"
  write(ilun,format)"        do j=-1,1"
  write(ilun,format)"           do k=-1,1"
  write(ilun,format)"              counter=counter+1"
  write(ilun,format)"              cube3(i,j,k)=rho(cell_index(counter))"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  else if(hydro)then"
  write(ilun,format)"     do i=-1,1"
  write(ilun,format)"        do j=-1,1"
  write(ilun,format)"           do k=-1,1"
  write(ilun,format)"              counter=counter+1"
  write(ilun,format)"              cube3(i,j,k)=uold(cell_index(counter),1)"
  write(ilun,format)"           end do"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  else"
  write(ilun,format)"     return"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"! compute gradient"
  write(ilun,format)"  gradient(1)=0.5*(cube3(1,0,0)-cube3(-1,0,0))/dx_loc"
  write(ilun,format)"  gradient(2)=0.5*(cube3(0,1,0)-cube3(0,-1,0))/dx_loc"
  write(ilun,format)"  gradient(3)=0.5*(cube3(0,0,1)-cube3(0,0,-1))/dx_loc"
  write(ilun,format)""
  write(ilun,format)"  if (maxval(abs(gradient(1:3)))==0.)return"
  write(ilun,format)""
  write(ilun,format)"  ! compute hessian"
  write(ilun,format)"  hess(1,1)=(cube3(1,0,0)+cube3(-1,0,0)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)"  hess(2,2)=(cube3(0,1,0)+cube3(0,-1,0)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)"  hess(3,3)=(cube3(0,0,1)+cube3(0,0,-1)-2*cube3(0,0,0))/dx_loc**2."
  write(ilun,format)""
  write(ilun,format)"  hess(1,2)=0.25*(cube3(1,1,0)+cube3(-1,-1,0)-cube3(1,-1,0)-cube3(-1,1,0))/dx_loc**2."
  write(ilun,format)"  hess(2,1)=hess(1,2)"
  write(ilun,format)"  hess(1,3)=0.25*(cube3(1,0,1)+cube3(-1,0,-1)-cube3(1,0,-1)-cube3(-1,0,1))/dx_loc**2."
  write(ilun,format)"  hess(3,1)=hess(1,3)"
  write(ilun,format)"  hess(2,3)=0.25*(cube3(0,1,1)+cube3(0,-1,-1)-cube3(0,1,-1)-cube3(0,-1,1))/dx_loc**2."
  write(ilun,format)"  hess(3,2)=hess(2,3)"
  write(ilun,format)""
  write(ilun,format)"  !determinant"
  write(ilun,format)"  det=hess(1,1)*hess(2,2)*hess(3,3)+hess(1,2)*hess(2,3)*hess(3,1)+hess(1,3)*hess(2,1)*hess(3,2) &"
  write(ilun,format)"       -hess(1,1)*hess(2,3)*hess(3,2)-hess(1,2)*hess(2,1)*hess(3,3)-hess(1,3)*hess(2,2)*hess(3,1)"
  write(ilun,format)""
  write(ilun,format)"  !matrix of minors"
  write(ilun,format)"  minor(1,1)=hess(2,2)*hess(3,3)-hess(2,3)*hess(3,2)"
  write(ilun,format)"  minor(2,2)=hess(1,1)*hess(3,3)-hess(1,3)*hess(3,1)"
  write(ilun,format)"  minor(3,3)=hess(1,1)*hess(2,2)-hess(1,2)*hess(2,1)"
  write(ilun,format)""
  write(ilun,format)"  minor(1,2)=-1.*(hess(2,1)*hess(3,3)-hess(2,3)*hess(3,1))"
  write(ilun,format)"  minor(2,1)=minor(1,2)"
  write(ilun,format)"  minor(1,3)=hess(2,1)*hess(3,2)-hess(2,2)*hess(3,1)"
  write(ilun,format)"  minor(3,1)=minor(1,3)"
  write(ilun,format)"  minor(2,3)=-1.*(hess(1,1)*hess(3,2)-hess(1,2)*hess(3,1))"
  write(ilun,format)"  minor(3,2)=minor(2,3)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !displacement of the true max from the cell center"
  write(ilun,format)"  displacement=0."
  write(ilun,format)"  do i=1,3"
  write(ilun,format)"     do j=1,3"
  write(ilun,format)"        numerator = gradient(j)*minor(i,j)"
  write(ilun,format)"        if(numerator>0) displacement(i)=displacement(i)-numerator/(det+10.*numerator*smallreal)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !clipping the displacement in order to keep max in the cell"
  write(ilun,format)"  disp_max=maxval(abs(displacement(1:3)))"
  write(ilun,format)"  if (disp_max > dx_loc*0.499999)then"
  write(ilun,format)"     displacement(1)=displacement(1)/disp_max*dx_loc*0.499999"
  write(ilun,format)"     displacement(2)=displacement(2)/disp_max*dx_loc*0.499999"
  write(ilun,format)"     displacement(3)=displacement(3)/disp_max*dx_loc*0.499999"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  x=x+displacement(1)"
  write(ilun,format)"  y=y+displacement(2)"
  write(ilun,format)"  z=z+displacement(3)"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)"end subroutine true_max"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine update_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  ! This routine is called at the leafs of the tree structure (right after"
  write(ilun,format)"  ! update time). Here is where the global sink variables vsink and xsink are"
  write(ilun,format)"  ! updated by summing the conributions from all levels."
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dteff"
  write(ilun,format)"  integer::lev,isink"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)""
  write(ilun,format)"  if(verbose)write(*,*)'Entering update_sink for level ',ilevel"
  write(ilun,format)""
  write(ilun,format)"  fsink=0."
  write(ilun,format)"  call f_sink_sink"
  write(ilun,format)""
  write(ilun,format)"  vsold(1:nsink,1:ndim,ilevel)=vsnew(1:nsink,1:ndim,ilevel)"
  write(ilun,format)"  vsnew(1:nsink,1:ndim,ilevel)=vsink(1:nsink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over sinks"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)""
  write(ilun,format)"     ! sum force contributions from all levels and gather"
  write(ilun,format)"     do lev=levelmin,nlevelmax"
  write(ilun,format)"        fsink(isink,1:ndim)=fsink(isink,1:ndim)+fsink_partial(isink,1:ndim,lev)"
  write(ilun,format)"     end do"
  write(ilun,format)"     if (.not. direct_force_sink(isink))then"
  write(ilun,format)"        fsink(isink,1:ndim)=fsink(isink,1:ndim)/dble(ncloud_sink)"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! compute timestep for the synchronization"
  write(ilun,format)"     if (new_born(isink))then"
  write(ilun,format)"        ! no sync necessary for newly produced sink"
  write(ilun,format)"        dteff=0d0"
  write(ilun,format)"     else"
  write(ilun,format)"        if(sinkint_level>ilevel)then"
  write(ilun,format)"           ! level at which sinks are integrated has increased"
  write(ilun,format)"           ! newdt_fine at coarser level has not been computed"
  write(ilun,format)"           ! -> use dtnew from coarse level"
  write(ilun,format)"           dteff=dtnew(sinkint_level)"
  write(ilun,format)"        else"
  write(ilun,format)"           ! normal case: finish timestep using dtold from current level."
  write(ilun,format)"           dteff=dtold(sinkint_level)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     ! this is the kick-kick (half old half new timestep)"
  write(ilun,format)"     vsink(isink,1:ndim)=0.5D0*(dtnew(ilevel)+dteff)*fsink(isink,1:ndim)+vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! save the velocity"
  write(ilun,format)"     vsnew(isink,1:ndim,ilevel)=vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! this is the kick-kick (half old half new timestep)"
  write(ilun,format)"     vsink(isink,1:ndim)=0.5D0*(dtnew(ilevel)+dteff)*fsink(isink,1:ndim)+vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! save the velocity"
  write(ilun,format)"     vsnew(isink,1:ndim,ilevel)=vsink(isink,1:ndim)"
  write(ilun,format)""
  write(ilun,format)"     ! and this is the drift (only for the global sink variable)"
  write(ilun,format)"     xsink(isink,1:ndim)=xsink(isink,1:ndim)+vsink(isink,1:ndim)*dtnew(ilevel)"
  write(ilun,format)"     new_born(isink)=.false."
  write(ilun,format)""
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over sinks"
  write(ilun,format)""
  write(ilun,format)"  ! Store deepest level"
  write(ilun,format)"  sinkint_level=ilevel"
  write(ilun,format)""
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine update_sink"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine update_cloud(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)""
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)"  ! update sink cloud particle properties"
  write(ilun,format)"  ! -the particles are moved whenever the level of the grid they sit in is updated"
  write(ilun,format)"  ! -the amount of drift they get is according to their levelp"
  write(ilun,format)"  ! -since this is happening on the way down, at level ilevel all particles with"
  write(ilun,format)"  ! level >= ilevel will be moved. Therefore, the sink_jump for all levels >= ilevel"
  write(ilun,format)"  ! is set ot zero on exit."
  write(ilun,format)"  !----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part,ig,ip,npart1,isink,nx_loc"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)""
  write(ilun,format)"  ! Update particles position and velocity"
  write(ilun,format)"  ig=0"
  write(ilun,format)"  ip=0"
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  igrid=headl(myid,ilevel)"
  write(ilun,format)"  do jgrid=1,numbl(myid,ilevel)"
  write(ilun,format)"     npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"     if(npart1>0)then"
  write(ilun,format)"        ig=ig+1"
  write(ilun,format)"        ind_grid(ig)=igrid"
  write(ilun,format)"        ipart=headp(igrid)"
  write(ilun,format)"        ! Loop over particles"
  write(ilun,format)"        do jpart=1,npart1"
  write(ilun,format)"           ! Save next particle  <---- Very important !!!"
  write(ilun,format)"           next_part=nextp(ipart) !move only particles which do actually belong to that level"
  write(ilun,format)"           if(ig==0)then"
  write(ilun,format)"              ig=1"
  write(ilun,format)"              ind_grid(ig)=igrid"
  write(ilun,format)"           end if"
  write(ilun,format)"           ip=ip+1"
  write(ilun,format)"           ind_part(ip)=ipart"
  write(ilun,format)"           ind_grid_part(ip)=ig"
  write(ilun,format)"           if(ip==nvector)then"
  write(ilun,format)"              call upd_cloud(ind_part,ip)"
  write(ilun,format)"              ip=0"
  write(ilun,format)"              ig=0"
  write(ilun,format)"           end if"
  write(ilun,format)"           ipart=next_part  ! Go to next particle"
  write(ilun,format)"        end do"
  write(ilun,format)"        ! End loop over particles"
  write(ilun,format)"     end if"
  write(ilun,format)"     igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)"  if(ip>0)call upd_cloud(ind_part,ip)"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1.and.verbose)then"
  write(ilun,format)"     write(*,*)'sink drift due to accretion relative to grid size at level ',ilevel"
  write(ilun,format)"     do isink=1,nsink"
  write(ilun,format)"        write(*,*)'#sink: ',isink,' drift: ',sink_jump(isink,1:ndim,ilevel)/dx_loc"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  sink_jump(1:nsink,1:ndim,ilevel:nlevelmax)=0.d0"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering update_cloud for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine update_cloud"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine upd_cloud(ind_part,np)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::np"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_part"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------"
  write(ilun,format)"  ! Vector loop called by update_cloud"
  write(ilun,format)"  !------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,idim,isink,lev"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::new_xp,new_vp"
  write(ilun,format)"  integer,dimension(1:nvector)::level_p"
  write(ilun,format)""
  write(ilun,format)"  ! Overwrite cloud particle mass with sink mass"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     isink=-idp(ind_part(j))"
  write(ilun,format)"     if(isink>0 .and. mp(ind_part(j))>0.)then"
  write(ilun,format)"        mp(ind_part(j))=msink(isink)/dble(ncloud_sink_massive)"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! store velocity"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        new_vp(j,idim)=vp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Overwrite cloud particle velocity with sink velocity"
  write(ilun,format)"  ! is going to be overwritten again before move"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        isink=-idp(ind_part(j))"
  write(ilun,format)"        if(isink>0)then"
  write(ilun,format)"              new_vp(j,idim)=vsink(isink,idim)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! write back velocity"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        vp(ind_part(j),idim)=new_vp(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! read level"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     level_p(j)=levelp(ind_part(j))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Update position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        new_xp(j,idim)=xp(ind_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        isink=-idp(ind_part(j))"
  write(ilun,format)"        if(isink>0)then"
  write(ilun,format)"           lev=level_p(j)"
  write(ilun,format)"           new_xp(j,idim)=new_xp(j,idim)+sink_jump(isink,idim,lev)"
  write(ilun,format)"        endif"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)" ! Write back postion"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        xp(ind_part(j),idim)=new_xp(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine upd_cloud"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine merge_star_sink"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine merges sink particles for the star formation case if"
  write(ilun,format)"  ! they are too close and one of them is younger than ~1000 years"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,isink,jsink,i,nx_loc,mergers"
  write(ilun,format)"  real(dp)::dx_loc,scale,dx_min,rr,rmax2,rmax,mcom,t_larson1"
  write(ilun,format)"  logical::iyoung,jyoung,merge"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::xcom,vcom,lcom"
  write(ilun,format)""
  write(ilun,format)"  if(nsink==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**nlevelmax"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min ! Linking length in physical units"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)""
  write(ilun,format)"  ! Lifetime of first larson core in code units"
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  t_larson1=merging_timescale*365.25*24*3600/scale_t"
  write(ilun,format)""
  write(ilun,format)"  mergers=0"
  write(ilun,format)"  ! Loop over all possible pairs (n-square, problematic when there are zilions of sinks)"
  write(ilun,format)"  do isink=1,nsink-1"
  write(ilun,format)"     if (msink(isink)>-1.)then"
  write(ilun,format)"        do jsink=isink+1,nsink"
  write(ilun,format)""
  write(ilun,format)"           ! Age check"
  write(ilun,format)"           iyoung=(t-tsink(isink)<t_larson1)"
  write(ilun,format)"           jyoung=(t-tsink(jsink)<t_larson1)"
  write(ilun,format)""
  write(ilun,format)"           ! Spacing check"
  write(ilun,format)"           rr=     (xsink(isink,1)-xsink(jsink,1))**2&"
  write(ilun,format)"                & +(xsink(isink,2)-xsink(jsink,2))**2&"
  write(ilun,format)"                & +(xsink(isink,3)-xsink(jsink,3))**2"
  write(ilun,format)""
  write(ilun,format)"           merge=(iyoung .or. jyoung).and.rr<rmax2 ! Sinks are within one linking length"
  write(ilun,format)"           merge=merge .or. (iyoung .and. jyoung .and. rr<4*rmax2) ! Sink clouds are touching each other"
  write(ilun,format)"           merge=merge .and. msink(jsink)>=0"
  write(ilun,format)""
  write(ilun,format)"           if (merge)then"
  write(ilun,format)"              if (myid==1)write(*,*)'merged ', idsink(jsink),' to ',idsink(isink)"
  write(ilun,format)"              mergers=mergers+1"
  write(ilun,format)"              ! Compute centre of mass quantities"
  write(ilun,format)"              mcom     =(msink(isink)+msink(jsink))"
  write(ilun,format)"              xcom(1:3)=(msink(isink)*xsink(isink,1:3)+msink(jsink)*xsink(jsink,1:3))/mcom"
  write(ilun,format)"              vcom(1:3)=(msink(isink)*vsink(isink,1:3)+msink(jsink)*vsink(jsink,1:3))/mcom"
  write(ilun,format)"              lcom(1:3)=msink(isink)*cross((xsink(isink,1:3)-xcom(1:3)),vsink(isink,1:3)-vcom(1:3))+ &"
  write(ilun,format)"                   &    msink(jsink)*cross((xsink(jsink,1:3)-xcom(1:3)),vsink(jsink,1:3)-vcom(1:3))"
  write(ilun,format)"              ! Compute merged quantities"
  write(ilun,format)"              msink(isink)    =mcom"
  write(ilun,format)"              xsink(isink,1:3)=xcom(1:3)"
  write(ilun,format)"              vsink(isink,1:3)=vcom(1:3)"
  write(ilun,format)"              lsink(isink,1:3)=lcom(1:3)+lsink(isink,1:3)+lsink(jsink,1:3)"
  write(ilun,format)"              ! Update final remaining quantities"
  write(ilun,format)"              msink(jsink)=-10."
  write(ilun,format)"              tsink(isink)=min(tsink(isink),tsink(jsink))"
  write(ilun,format)"              idsink(isink)=min(idsink(isink),idsink(jsink))"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. mergers>0)write(*,*)'merged ',mergers,' sinks'"
  write(ilun,format)""
  write(ilun,format)"  ! Sort sink particle arrays to account for merged sinks that disappeared"
  write(ilun,format)"  i=1"
  write(ilun,format)"  do while (mergers>0)"
  write(ilun,format)""
  write(ilun,format)"     if (msink(i)<-1.)then !if sink has been merged to another one"
  write(ilun,format)""
  write(ilun,format)"        mergers=mergers-1"
  write(ilun,format)"        nsink=nsink-1"
  write(ilun,format)""
  write(ilun,format)"        !let them all slide back one index"
  write(ilun,format)"        do j=i,nsink"
  write(ilun,format)"           xsink(j,1:3)=xsink(j+1,1:3)"
  write(ilun,format)"           vsink(j,1:3)=vsink(j+1,1:3)"
  write(ilun,format)"           lsink(j,1:3)=lsink(j+1,1:3)"
  write(ilun,format)"           msink(j)=msink(j+1)"
  write(ilun,format)"           mseed(j)=mseed(j+1)"
  write(ilun,format)""
  write(ilun,format)"           !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"           dmfsink(j)=dmfsink(j+1)"
  write(ilun,format)""
  write(ilun,format)"           new_born(j)=new_born(j+1)"
  write(ilun,format)"           tsink(j)=tsink(j+1)"
  write(ilun,format)"           idsink(j)=idsink(j+1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        !whipe last position in the sink list"
  write(ilun,format)"        xsink(nsink+1,1:3)=0."
  write(ilun,format)"        vsink(nsink+1,1:3)=0."
  write(ilun,format)"        lsink(nsink+1,1:3)=0."
  write(ilun,format)"        msink(nsink+1)=0."
  write(ilun,format)"        mseed(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)"        !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"        dmfsink(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"        new_born(nsink+1)=.false."
  write(ilun,format)"        tsink(nsink+1)=0."
  write(ilun,format)"        idsink(nsink+1)=0"
  write(ilun,format)""
  write(ilun,format)"     else"
  write(ilun,format)"        i=i+1"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine merge_star_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine merge_smbh_sink"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine merges sink particles for the smbh formation case if"
  write(ilun,format)"  ! they are too close"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::j,isink,jsink,i,nx_loc,mergers"
  write(ilun,format)"  real(dp)::dx_loc,scale,dx_min,rr,rmax2,rmax,mcom,v1_v2,factG"
  write(ilun,format)"  logical::merge"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)"  real(dp),dimension(1:3)::xcom,vcom,lcom"
  write(ilun,format)""
  write(ilun,format)"  if(nsink==0)return"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx_loc=0.5D0**nlevelmax"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  rmax=dble(ir_cloud)*dx_min ! Linking length in physical units"
  write(ilun,format)"  rmax2=rmax*rmax"
  write(ilun,format)"  ssoft=sink_soft*dx_min"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  mergers=0"
  write(ilun,format)"  ! Loop over all possible pairs (n-square, problematic when there are zilions of sinks)"
  write(ilun,format)"  do isink=1,nsink-1"
  write(ilun,format)"     if (msink(isink)>-1)then"
  write(ilun,format)"        do jsink=isink+1,nsink"
  write(ilun,format)""
  write(ilun,format)"           ! Spacing check"
  write(ilun,format)"           rr=     (xsink(isink,1)-xsink(jsink,1))**2&"
  write(ilun,format)"                & +(xsink(isink,2)-xsink(jsink,2))**2&"
  write(ilun,format)"                & +(xsink(isink,3)-xsink(jsink,3))**2"
  write(ilun,format)""
  write(ilun,format)"           merge=rr<4*ssoft**2"
  write(ilun,format)"           merge=merge .and. msink(jsink)>0"
  write(ilun,format)""
  write(ilun,format)"           ! Relative velocity check"
  write(ilun,format)"           if (mass_merger_vel_check_AGN>0)then"
  write(ilun,format)"              if((msink(isink)+msink(jsink)).ge.mass_merger_vel_check_AGN*2d33/(scale_d*scale_l**3)) then"
  write(ilun,format)"                 v1_v2=(vsink(isink,1)-vsink(jsink,1))**2+(vsink(isink,2)-vsink(jsink,2))**2+(vsink(isink,3)-vsink(jsink,3))**2"
  write(ilun,format)"                 merge=merge .and. 2*factG*(msink(isink)+msink(jsink))/sqrt(rr)>v1_v2"
  write(ilun,format)"              end if"
  write(ilun,format)"           end if"
  write(ilun,format)""
  write(ilun,format)"           if (merge)then"
  write(ilun,format)"              if (myid==1)write(*,*)'merged ', idsink(jsink),' to ',idsink(isink)"
  write(ilun,format)"              mergers=mergers+1"
  write(ilun,format)"              ! Compute centre of mass quantities"
  write(ilun,format)"              mcom     =(msink(isink)+msink(jsink))"
  write(ilun,format)"              xcom(1:3)=(msink(isink)*xsink(isink,1:3)+msink(jsink)*xsink(jsink,1:3))/mcom"
  write(ilun,format)"              vcom(1:3)=(msink(isink)*vsink(isink,1:3)+msink(jsink)*vsink(jsink,1:3))/mcom"
  write(ilun,format)"              lcom(1:3)=msink(isink)*cross((xsink(isink,1:3)-xcom(1:3)),vsink(isink,1:3)-vcom(1:3))+ &"
  write(ilun,format)"                &       msink(jsink)*cross((xsink(jsink,1:3)-xcom(1:3)),vsink(jsink,1:3)-vcom(1:3))"
  write(ilun,format)"              ! Compute merged quantities"
  write(ilun,format)"              msink(isink)    =mcom"
  write(ilun,format)"              xsink(isink,1:3)=xcom(1:3)"
  write(ilun,format)"              vsink(isink,1:3)=vcom(1:3)"
  write(ilun,format)"              lsink(isink,1:3)=lcom(1:3)+lsink(isink,1:3)+lsink(jsink,1:3)"
  write(ilun,format)""
  write(ilun,format)"              !introduced by PH 09/2013 to follow the feedback from the sinks"
  write(ilun,format)"              dmfsink(isink)=dmfsink(isink)+dmfsink(jsink)"
  write(ilun,format)""
  write(ilun,format)"              ! Update final remaining quantities"
  write(ilun,format)"              delta_mass(isink)=delta_mass(isink)+delta_mass(jsink)"
  write(ilun,format)"              msink(jsink)=-10."
  write(ilun,format)"              tsink(isink)=min(tsink(isink),tsink(jsink))"
  write(ilun,format)"              idsink(isink)=min(idsink(isink),idsink(jsink))"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (myid==1 .and. mergers>0)write(*,*)'merged ',mergers,' sinks'"
  write(ilun,format)""
  write(ilun,format)"  ! Sort sink particle arrays to account for merged sinks that disappeared"
  write(ilun,format)"  i=1"
  write(ilun,format)"  do while (mergers>0)"
  write(ilun,format)""
  write(ilun,format)"     if (msink(i)<-1.)then !if sink has been merged to another one"
  write(ilun,format)""
  write(ilun,format)"        mergers=mergers-1"
  write(ilun,format)"        nsink=nsink-1"
  write(ilun,format)""
  write(ilun,format)"        !let them all slide back one index"
  write(ilun,format)"        do j=i,nsink"
  write(ilun,format)"           xsink(j,1:3)=xsink(j+1,1:3)"
  write(ilun,format)"           vsink(j,1:3)=vsink(j+1,1:3)"
  write(ilun,format)"           lsink(j,1:3)=lsink(j+1,1:3)"
  write(ilun,format)"           msink(j)=msink(j+1)"
  write(ilun,format)"           mseed(j)=mseed(j+1)"
  write(ilun,format)"           new_born(j)=new_born(j+1)"
  write(ilun,format)"           tsink(j)=tsink(j+1)"
  write(ilun,format)"           idsink(j)=idsink(j+1)"
  write(ilun,format)"           delta_mass(j)=delta_mass(j+1)"
  write(ilun,format)"        end do"
  write(ilun,format)""
  write(ilun,format)"        !whipe last position in the sink list"
  write(ilun,format)"        xsink(nsink+1,1:3)=0."
  write(ilun,format)"        vsink(nsink+1,1:3)=0."
  write(ilun,format)"        lsink(nsink+1,1:3)=0."
  write(ilun,format)"        msink(nsink+1)=0."
  write(ilun,format)"        mseed(nsink+1)=0."
  write(ilun,format)"        new_born(nsink+1)=.false."
  write(ilun,format)"        tsink(nsink+1)=0."
  write(ilun,format)"        idsink(nsink+1)=0"
  write(ilun,format)"        delta_mass(nsink+1)=0."
  write(ilun,format)""
  write(ilun,format)"     else"
  write(ilun,format)"        i=i+1"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine merge_smbh_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine f_gas_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)" integer::ilevel"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  ! In this subroutine the sink-gas force contributions are calculated."
  write(ilun,format)"  ! A plummer-sphere with radius ssoft is used for softening"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  integer::igrid,ngrid,ncache,i,ind,iskip,ix,iy,iz,isink"
  write(ilun,format)"  integer::nx_loc,idim"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc,dx_min,factG"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)""
  write(ilun,format)"  logical ,dimension(1:nvector)::ok"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xx,ff"
  write(ilun,format)"  real(dp),dimension(1:nvector)::d2,mcell,denom"
  write(ilun,format)"  real(dp)::rho_tff,rho_tff_tot,d_min"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"  !  Cell spacing at that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  dx_min=scale*0.5D0**nlevelmax/aexp"
  write(ilun,format)"  ssoft=sink_soft*dx_min"
  write(ilun,format)""
  write(ilun,format)"  ! Set position of cell centers relative to grid centre"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     if(ndim>0)xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>1)xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     if(ndim>2)xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  rho_tff=0."
  write(ilun,format)""
  write(ilun,format)"  fsink_new=0."
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Loop over sinks"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)""
  write(ilun,format)"        d_min=boxlen"
  write(ilun,format)""
  write(ilun,format)"        ! Loop over myid grids by vector sweeps"
  write(ilun,format)"        ncache=active(ilevel)%ngrid"
  write(ilun,format)"        do igrid=1,ncache,nvector"
  write(ilun,format)"           ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"           do i=1,ngrid"
  write(ilun,format)"              ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"           end do"
  write(ilun,format)""
  write(ilun,format)"           ! Loop over cells"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Check if cell is refined"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Gas and dark matter mass in cell"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 mcell(i)=rho(ind_cell(i))*vol_loc"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Cell center"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 do i=1,ngrid"
  write(ilun,format)"                    xx(i,idim)=(xg(ind_grid(i),idim)+xc(ind,idim)-skip_loc(idim))*scale"
  write(ilun,format)"                 end do"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Relative position and distance"
  write(ilun,format)"              d2=0.d0"
  write(ilun,format)"              do idim=1,ndim"
  write(ilun,format)"                 if (period(idim))then"
  write(ilun,format)"                    do i=1,ngrid"
  write(ilun,format)"                       ! zero order Ewald sum"
  write(ilun,format)"                       ff(i,idim)=xsink(isink,idim)-xx(i,idim)"
  write(ilun,format)"                       if(ff(i,idim)>0.5*boxlen)ff(i,idim)=ff(i,idim)-boxlen"
  write(ilun,format)"                       if(ff(i,idim)<-0.5*boxlen)ff(i,idim)=ff(i,idim)+boxlen"
  write(ilun,format)"                       d2(i)=d2(i)+ff(i,idim)**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 else"
  write(ilun,format)"                    do i=1,ngrid"
  write(ilun,format)"                       ff(i,idim)=xsink(isink,idim)-xx(i,idim)"
  write(ilun,format)"                       d2(i)=d2(i)+ff(i,idim)**2"
  write(ilun,format)"                    end do"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Store minimum distance of cell in current level to isink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 d_min=min(d_min,d2(i))"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Compute sqrt(1/(ssoft**2+d2(i))) to save time"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 denom(i)=(ssoft**2+d2(i))**(-1.5)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Compute gas acceleration due to sink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 ff(i,1:ndim)=denom(i)*ff(i,1:ndim)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Add gas acceleration due to sink"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 f(ind_cell(i),1:ndim)=f(ind_cell(i),1:ndim)+factG*msink(isink)*ff(i,1:ndim)"
  write(ilun,format)"              end do"
  write(ilun,format)""
  write(ilun,format)"              ! Add sink acceleration due to gas"
  write(ilun,format)"              do i=1,ngrid"
  write(ilun,format)"                 if(ok(i))then"
  write(ilun,format)"                    fsink_new(isink,1:ndim)=fsink_new(isink,1:ndim)-factG*mcell(i)*ff(i,1:ndim)"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end do !end loop over cells"
  write(ilun,format)"        end do !end loop over grids"
  write(ilun,format)""
  write(ilun,format)"        d_min=d_min**0.5"
  write(ilun,format)"        d_min=max(ssoft,d_min)"
  write(ilun,format)"        rho_tff=max(rho_tff,msink(isink)/(4./3.*3.1415926*d_min**3))"
  write(ilun,format)""
  write(ilun,format)"     end if !end if direct force"
  write(ilun,format)"  end do !end loop over sinks"
  write(ilun,format)""
  write(ilun,format)"  !collect sink acceleration from cpus"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(fsink_new,fsink_all,nsinkmax*ndim,MPI_DOUBLE_PRECISION,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     fsink_all=fsink_new"
  write(ilun,format)"#endif"
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)"        fsink_partial(isink,1:ndim,ilevel)=fsink_all(isink,1:ndim)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     call make_virtual_fine_dp(f(1,idim),ilevel)"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !collect rho due to sinks for current level - used for timestep computation"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  call MPI_ALLREDUCE(rho_tff,rho_tff_tot,1,MPI_DOUBLE_PRECISION,MPI_MAX,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"  rho_tff_tot=rho_tff"
  write(ilun,format)"#endif"
  write(ilun,format)"  rho_sink_tff(ilevel)=rho_tff_tot"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  if (ilevel==nlevelmax)call make_virtual_fine_dp(phi(1),ilevel)"
  write(ilun,format)""
  write(ilun,format)"end subroutine f_gas_sink"
  write(ilun,format)""
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine f_sink_sink"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  ! In this subroutine the sink-sink force contribution are calculated by direct"
  write(ilun,format)"  ! n^2 - summation. A plummer-sphere with radius 4 cells is used for softening"
  write(ilun,format)"  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
  write(ilun,format)"  integer::isink,idim,jsink"
  write(ilun,format)"  real(dp),allocatable,dimension(:)::d2"
  write(ilun,format)"  real(dp),allocatable,dimension(:,:)::ff"
  write(ilun,format)"  logical,dimension(1:ndim)::period"
  write(ilun,format)"  real(dp)::factG"
  write(ilun,format)""
  write(ilun,format)"  allocate(d2(1:nsink))"
  write(ilun,format)"  allocate(ff(1:nsink,1:ndim))"
  write(ilun,format)""
  write(ilun,format)"  ! Gravitational constant"
  write(ilun,format)"  factG=1d0"
  write(ilun,format)"  if(cosmo)factG=3d0/8d0/3.1415926*omega_m*aexp"
  write(ilun,format)""
  write(ilun,format)"!  fsink=0."
  write(ilun,format)""
  write(ilun,format)"  period(1)=(nx==1)"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"  if(ndim>1)period(2)=(ny==1)"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"  if(ndim>2)period(3)=(nz==1)"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  do isink=1,nsink"
  write(ilun,format)"     if (direct_force_sink(isink))then"
  write(ilun,format)"        d2=0.d0"
  write(ilun,format)"        ff=0.d0"
  write(ilun,format)"        do idim=1,ndim"
  write(ilun,format)"           !compute relative position and and distances"
  write(ilun,format)"           if (period(idim))then"
  write(ilun,format)"              do jsink=1,nsink"
  write(ilun,format)"                 if (direct_force_sink(jsink))then"
  write(ilun,format)"                    ff(jsink,idim)=xsink(jsink,idim)-xsink(isink,idim)"
  write(ilun,format)"                    if(ff(jsink,idim)>0.5*boxlen)ff(jsink,idim)=ff(jsink,idim)-boxlen"
  write(ilun,format)"                    if(ff(jsink,idim)<-0.5*boxlen)ff(jsink,idim)=ff(jsink,idim)+boxlen"
  write(ilun,format)"                    d2(jsink)=d2(jsink)+ff(jsink,idim)**2"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           else"
  write(ilun,format)"              do jsink=1,nsink"
  write(ilun,format)"                 if (direct_force_sink(jsink))then"
  write(ilun,format)"                    ff(jsink,idim)=xsink(jsink,idim)-xsink(isink,idim)"
  write(ilun,format)"                    d2(jsink)=d2(jsink)+ff(jsink,idim)**2"
  write(ilun,format)"                 end if"
  write(ilun,format)"              end do"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        !compute acceleration"
  write(ilun,format)"        do jsink=1,nsink"
  write(ilun,format)"           if (direct_force_sink(jsink))then"
  write(ilun,format)"              ff(jsink,1:ndim)=factG*msink(jsink)/(ssoft**2+d2(jsink))**1.5*ff(jsink,1:ndim)"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"        do jsink=1,nsink"
  write(ilun,format)"           fsink(isink,1:ndim)=fsink(isink,1:ndim)+ff(jsink,1:ndim)"
  write(ilun,format)"           if(jsink<0)then"
  write(ilun,format)"              print*,'This is just a stupid trick to prevent'"
  write(ilun,format)"              print*,'the compiler from optimizing this loop!'"
  write(ilun,format)"           end if"
  write(ilun,format)"        end do"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)"end subroutine f_sink_sink"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"!#########################################################################"
  write(ilun,format)"subroutine read_sink_params()"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use cloud_module,only:facc_star_mom"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! read sink related parameters and perform some 'sanity chekcs'"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::dx_min,scale,cty"
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  namelist/sink_params/n_sink,rho_sink,d_sink,accretion_scheme,merging_timescale,jeans_accretion,&"
  write(ilun,format)"       ir_cloud_massive,sink_soft,mass_sink_direct_force,ir_cloud,nsinkmax,c_acc,facc_star_mom,create_sinks,mass_sink_seed,&"
  write(ilun,format)"       eddington_limit,sink_drag,acc_sink_boost,mass_merger_vel_check_AGN,&"
  write(ilun,format)"       clump_core,verbose_AGN,T2_AGN,v_AGN,cone_opening,mass_halo_AGN,mass_clump_AGN,feedback_scheme"
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_l,scale_d,scale_t,scale_v"
  write(ilun,format)""
  write(ilun,format)"  if(.not.cosmo) call units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)""
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale = boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)"  ! Read namelist file"
  write(ilun,format)"  rewind(1)"
  write(ilun,format)"  read(1,NML=sink_params,END=111)"
  write(ilun,format)"  goto 112"
  write(ilun,format)"111 if(myid==1)write(*,*)'You did not set up &SINK_PARAMS in the namelist file'"
  write(ilun,format)"  if(myid==1)write(*,*)'Using default values '"
  write(ilun,format)"112 rewind(1)"
  write(ilun,format)""
  write(ilun,format)"  if (sink .and. (ndim .ne. 3))then"
  write(ilun,format)"     if(myid==1)write(*,*)'Sink particles are only implemented for 3d sims.'"
  write(ilun,format)"     print*, ndim"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (sink .and. (nlevelmax==levelmin))then"
  write(ilun,format)"     if(myid==1)write(*,*)'sink particles do currently not work in a single-level cartesian grid'"
  write(ilun,format)"     if(myid==1)write(*,*)'because they need level 1 to be activated.'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (create_sinks .and. accretion_scheme=='none')then"
  write(ilun,format)"     if(myid==1)write(*,*)'formation of new sinks without subsequent accretion is pointless.'"
  write(ilun,format)"     if(myid==1)write(*,*)'Choose accretion_scheme=...!'"
  write(ilun,format)"!     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if ((create_sinks .or. accretion_scheme .ne. 'none') .and. (.not. hydro))then"
  write(ilun,format)"     if(myid==1)write(*,*)'sink creation and accretion require hydro to be turned on'"
  write(ilun,format)"     call clean_stop"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !check for accretion scheme"
  write(ilun,format)"  if (accretion_scheme =='flux')flux_accretion=.true."
  write(ilun,format)"  if (accretion_scheme =='bondi')bondi_accretion=.true."
  write(ilun,format)"  if (accretion_scheme =='threshold')threshold_accretion=.true."
  write(ilun,format)""
  write(ilun,format)"  ! for sink formation and accretion a threshold must be given"
  write(ilun,format)"  if (create_sinks .or. (accretion_scheme .ne. 'none'))then"
  write(ilun,format)""
  write(ilun,format)"     ! check for threshold"
  write(ilun,format)"     if (.not. cosmo)then"
  write(ilun,format)""
  write(ilun,format)"     if (rho_sink<0. .and. n_sink<0. .and. d_sink>0.) then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found d_sink! Assuming code units'"
  write(ilun,format)"     else if (rho_sink>0. .and. n_sink<0. .and. d_sink<0.)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found rho_sink! Assuming g/cc'"
  write(ilun,format)"        d_sink=rho_sink/scale_d"
  write(ilun,format)"     else if (rho_sink<0. .and. n_sink>0. .and. d_sink<0.)then"
  write(ilun,format)"        if(myid==1)write(*,*)'Found n_sink! Assuming H/cc'"
  write(ilun,format)"        d_sink=n_sink/scale_nH"
  write(ilun,format)"     else if ((rho_sink>0. .and. n_sink>0.) .or. (rho_sink>0. .and. d_sink>0.) .or. (n_sink>0. .and. d_sink>0.))then"
  write(ilun,format)"        if (myid==1)write(*,*)'Use n_sink [H/cc] OR rho_sink [g/cc] OR d_sink [code_units]'"
  write(ilun,format)"        call clean_stop"
  write(ilun,format)"     else"
  write(ilun,format)"        if(myid==1)write(*,*)'Trying to setting sink threshold such that jeans length at '"
  write(ilun,format)"        if(myid==1)write(*,*)'max resolution is resolved by 4 cells, assuming isothermal gas'"
  write(ilun,format)"        if(T2_star==0.)then"
  write(ilun,format)"           if(myid==1)write(*,*)'No value for T2_star given. Do not know what to do...'"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        else"
  write(ilun,format)"           dx_min=0.5**nlevelmax*scale"
  write(ilun,format)"           d_sink=T2_star/scale_T2 *3.14159/16./(dx_min**2)"
  write(ilun,format)"           if(myid==1)write(*,*)'d_sink = ',d_sink"
  write(ilun,format)"           if(myid==1)write(*,*)'rho_sink = ',d_sink*scale_d"
  write(ilun,format)"           if(myid==1)write(*,*)'n_sink = ',d_sink*scale_nH"
  write(ilun,format)"        end if"
  write(ilun,format)"     end if"
  write(ilun,format)""
  write(ilun,format)"     endif"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if (.not.smbh)then"
  write(ilun,format)"     if (merging_timescale > 0.)then"
  write(ilun,format)"        cty=scale_t/(365.25*24.*3600.)"
  write(ilun,format)"        cont_speed=-1./(merging_timescale/cty)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! nol_accretion requires a somewhat smaller timestep per default"
  write(ilun,format)"  if(c_acc < 0.)then"
  write(ilun,format)"     if (nol_accretion)then"
  write(ilun,format)"        c_acc=0.25"
  write(ilun,format)"     else"
  write(ilun,format)"        c_acc=0.75"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  !check for periodic boundary conditions"
  write(ilun,format)"  if (nx==1 .or. ny==1 .or. nz==1)then"
  write(ilun,format)"     if (mass_sink_direct_force .ge. 0.)then"
  write(ilun,format)"        if(myid==1)print*, 'periodic boundaries in combination with '"
  write(ilun,format)"        if(myid==1)print*, 'direct force sinks are not treated accurately....'"
  write(ilun,format)"     end if"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  if(mass_sink_direct_force<0.)then"
  write(ilun,format)"     mass_sink_direct_force=huge(0._dp)*1d-100 !huge=1d308 which gives an error if multiplied by >1"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine read_sink_params"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_clouds(ilevel,action)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  character(len=15)::action"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! loop over all sink cloud particles and pass nvector parts to count_clouds_np"
  write(ilun,format)"  ! first pass (action 'count'): count the number of sink cloud parts per cell"
  write(ilun,format)"  ! and store them in flag2"
  write(ilun,format)"  ! second pass (action 'weight'): assign a weight corresponding to the physical"
  write(ilun,format)"  ! volume to each cloud particle. reduce if sinks overlap (flag2 too big)."
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::igrid,jgrid,ipart,jpart,next_part"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,icpu,ind,cell_index"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)""
  write(ilun,format)"  if (action=='count')then"
  write(ilun,format)"     ! Loop over cpus"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        igrid=headl(icpu,ilevel)"
  write(ilun,format)"        ! Loop over grids"
  write(ilun,format)"        do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"           !set flag2 to zero for all cells in the grid"
  write(ilun,format)"           do ind=1,twotondim"
  write(ilun,format)"              cell_index=ncoarse+(ind-1)*ngridmax+igrid"
  write(ilun,format)"              rho(cell_index)=0."
  write(ilun,format)"           end do"
  write(ilun,format)"           igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Loop over cpus"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"     igrid=headl(icpu,ilevel)"
  write(ilun,format)"     ig=0"
  write(ilun,format)"     ip=0"
  write(ilun,format)"     ! Loop over grids"
  write(ilun,format)"     do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"        npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"        npart2=0"
  write(ilun,format)""
  write(ilun,format)"        ! Count sink and cloud particles"
  write(ilun,format)"        if(npart1>0)then"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 npart2=npart2+1"
  write(ilun,format)"              endif"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"        endif"
  write(ilun,format)""
  write(ilun,format)"        ! Gather sink and cloud particles"
  write(ilun,format)"        if(npart2>0)then"
  write(ilun,format)"           ig=ig+1"
  write(ilun,format)"           ind_grid(ig)=igrid"
  write(ilun,format)"           ipart=headp(igrid)"
  write(ilun,format)"           ! Loop over particles"
  write(ilun,format)"           do jpart=1,npart1"
  write(ilun,format)"              ! Save next particle   <--- Very important !!!"
  write(ilun,format)"              next_part=nextp(ipart)"
  write(ilun,format)"              ! Select only sink particles"
  write(ilun,format)"              if(idp(ipart).lt.0)then"
  write(ilun,format)"                 if(ig==0)then"
  write(ilun,format)"                    ig=1"
  write(ilun,format)"                    ind_grid(ig)=igrid"
  write(ilun,format)"                 end if"
  write(ilun,format)"                 ip=ip+1"
  write(ilun,format)"                 ind_part(ip)=ipart"
  write(ilun,format)"                 ind_grid_part(ip)=ig"
  write(ilun,format)"              endif"
  write(ilun,format)"              if(ip==nvector)then"
  write(ilun,format)"                 call count_clouds_np(ind_grid,ind_part,ind_grid_part,ig,ip,action,ilevel)"
  write(ilun,format)"                 ip=0"
  write(ilun,format)"                 ig=0"
  write(ilun,format)"              end if"
  write(ilun,format)"              ipart=next_part  ! Go to next particle"
  write(ilun,format)"           end do"
  write(ilun,format)"           ! End loop over particles"
  write(ilun,format)"        end if"
  write(ilun,format)"        igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     ! End loop over grids"
  write(ilun,format)"     if(ip>0)then"
  write(ilun,format)"        call count_clouds_np(ind_grid,ind_part,ind_grid_part,ig,ip,action,ilevel)"
  write(ilun,format)"    end if"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over cpus"
  write(ilun,format)""
  write(ilun,format)"end subroutine count_clouds"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_clouds_np(ind_grid,ind_part,ind_grid_part,ng,np,action,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons, only:rho"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_part,ind_grid,ind_grid_part"
  write(ilun,format)"  character(len=15)::action"
  write(ilun,format)"  !--------------------------------------------------------------------------------"
  write(ilun,format)"  ! inner loop of count_clouds"
  write(ilun,format)"  !--------------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,nx_loc,isink,idim,ind"
  write(ilun,format)"  real(dp)::scale,dx_min,weight,parts_per_cell,vol_min"
  write(ilun,format)"  integer,dimension(1:nvector,1:twotondim),save::cind_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim),save::vol"
  write(ilun,format)"  logical,dimension(1:nvector,twotondim)::ok"
  write(ilun,format)""
  write(ilun,format)"  ! compute volume of smallest cell"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_min=(0.5D0**nlevelmax)*scale"
  write(ilun,format)"  vol_min=dx_min**ndim"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,np"
  write(ilun,format)"        xpart(i,idim)=xp(ind_part(i),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_cells(cind_part,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! only particles 'in their level' accrete"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do i=1,np"
  write(ilun,format)"        if(.not. ok(i,ind))then"
  write(ilun,format)"           vol(i,ind)=0."
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (action=='count')then"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do i=1,np"
  write(ilun,format)"           rho(cind_part(i,ind))=rho(cind_part(i,ind))+vol(i,ind)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  ! weight each particle with its actual volume (reduced in the case of overlapping sinks)"
  write(ilun,format)"  if (action=='weight')then"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do i=1,np"
  write(ilun,format)"           isink=-idp(ind_part(i))"
  write(ilun,format)"           parts_per_cell=8*8.**(nlevelmax-ilevel)"
  write(ilun,format)"           weight=vol_min*0.125*vol(i,ind)"
  write(ilun,format)"           if (rho(cind_part(i,ind))>parts_per_cell)then"
  write(ilun,format)"              weight=weight*parts_per_cell/rho(cind_part(i,ind))"
  write(ilun,format)"           end if"
  write(ilun,format)"           weightp(ind_part(i),ind)=weight"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"end subroutine count_clouds_np"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine get_cell_index_for_particle(indp,xx,cell_lev,ind_grid,xpart,ind_grid_part,ng,np,ilevel,ok)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,indp,cell_lev,ind_grid_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart,xx"
  write(ilun,format)"  logical,dimension(1:nvector)::ok"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! This subroutine finds the leaf cell in which a particle sits"
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  integer::i,j,idim,nx_loc,ind,ix,iy,iz"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,one_over_dx,one_over_scale"
  write(ilun,format)"  ! Grid based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  integer ,dimension(1:nvector),save::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids"
  write(ilun,format)"  ! Particle based arrays"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::id,igd,icd,icd_fine"
  write(ilun,format)"  integer ,dimension(1:nvector),save::igrid,icell,kg,icell_fine"
  write(ilun,format)"  real(dp),dimension(1:3),save::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3),save::xc"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  one_over_dx=1./dx"
  write(ilun,format)"  one_over_scale=1./scale"
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Lower left corner of 3x3x3 grid-cube"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ng"
  write(ilun,format)"        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Gather 27 neighboring father cells (should be present anytime !)"
  write(ilun,format)"  do i=1,ng"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Rescale position at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=xpart(j,idim)*one_over_scale+skip_loc(idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)*one_over_dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check for illegal moves"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if(x(j,idim)<=0.0D0.or.x(j,idim)>=6.0D0)then"
  write(ilun,format)"           print*,'cpu ', myid, ' hosts an escaped particle'"
  write(ilun,format)"           print*,'x: ',x(j,1:ndim)"
  write(ilun,format)"           print*,'x0: ',x0(ind_grid_part(j),1:ndim)"
  write(ilun,format)"           print*,'xg: ',xg(ind_grid(ind_grid_part(j)),1:ndim)"
  write(ilun,format)"           print*,'xp: ',xpart(j,1:ndim)"
  write(ilun,format)"           print*,'skip_loc: ',skip_loc(1:ndim)"
  write(ilun,format)"           print*,'scale: ',scale"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! NGP at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        id(j,idim)=int(x(j,idim))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"   ! Compute parent grids"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igd(j,idim)=id(j,idim)/2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)+3*igd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     igrid(j)=son(nbors_father_cells(ind_grid_part(j),kg(j)))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particle has escaped to ilevel-1"
  write(ilun,format)"  ok(1:np)=.true."
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if (igrid(j)==0)then"
  write(ilun,format)"!        print*,'particle has escaped to ilevel-1'"
  write(ilun,format)"        ok(j)=.false."
  write(ilun,format)"        indp(j)=nbors_father_cells(ind_grid_part(j),kg(j))"
  write(ilun,format)"        cell_lev(j)=ilevel-1"
  write(ilun,format)"        xx(j,1:ndim)=(xg(ind_grid(ind_grid_part(j)),1:ndim)+(igd(j,1:ndim)-1.)*2.*dx-skip_loc(1:ndim))*scale"
  write(ilun,format)"        if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.000001*dx_loc*3**0.5)print*,'oups at ilevel-1'"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"!        if(ok(j))then"
  write(ilun,format)"           icd(j,idim)=id(j,idim)-2*igd(j,idim)"
  write(ilun,format)"!        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"! #if NDIM==1"
  write(ilun,format)"!   do j=1,np"
  write(ilun,format)"!      if(ok(j))then"
  write(ilun,format)"!         icell(j)=1+icd(j,1)"
  write(ilun,format)"!      end if"
  write(ilun,format)"!   end do"
  write(ilun,format)"! #endif"
  write(ilun,format)"! #if NDIM==2"
  write(ilun,format)"!   do j=1,np"
  write(ilun,format)"!      if(ok(j))then"
  write(ilun,format)"!         icell(j)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"!      end if"
  write(ilun,format)"!   end do"
  write(ilun,format)"! #endif"
  write(ilun,format)"!#if NDIM==3"
  write(ilun,format)"!  do j=1,np"
  write(ilun,format)"!     if(ok(j))then"
  write(ilun,format)"!        icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"!     end if"
  write(ilun,format)"!  end do"
  write(ilun,format)"!#endif"
  write(ilun,format)""
  write(ilun,format)"  call geticell(icell,icd,np)"
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell adress"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        indp(j)=ncoarse+(icell(j)-1)*ngridmax+igrid(j)"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particles have leaked into level ilevel+1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if(ok(j))then"
  write(ilun,format)"        if (son(indp(j))>0)then"
  write(ilun,format)"!           print*,'particle has escaped to ilevel+1'"
  write(ilun,format)"           ok(j)=.false."
  write(ilun,format)"           cell_lev(j)=ilevel+1"
  write(ilun,format)"           do idim=1,ndim"
  write(ilun,format)"              icd_fine(1,idim)=int(2*(x(j,idim)-int(x(j,idim))))"
  write(ilun,format)"           end do"
  write(ilun,format)"           call geticell(icell_fine,icd_fine,1)"
  write(ilun,format)"           xx(j,1:ndim)=(xg(son(indp(j)),1:ndim)+xc(icell_fine(1),1:ndim)*0.5-skip_loc(1:ndim))*scale"
  write(ilun,format)"           indp(j)=ncoarse+(icell_fine(1)-1)*ngridmax+son(indp(j))"
  write(ilun,format)"           if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.0000001*0.25*dx_loc*3**0.5)then"
  write(ilun,format)"              print*,icd_fine(1,1:ndim)"
  write(ilun,format)"              print*,icell_fine(1)"
  write(ilun,format)"              print*,'oups at ilevel+1'"
  write(ilun,format)"           end if"
  write(ilun,format)"        end if"
  write(ilun,format)"     endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  !cell center positions for particles which sit in the leve ilevel"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     if (ok(j))then"
  write(ilun,format)"        xx(j,1:ndim)=(xg(igrid(j),1:ndim)+xc(icell(j),1:ndim)-skip_loc(1:ndim))*scale"
  write(ilun,format)"        cell_lev(j)=ilevel"
  write(ilun,format)"        ! if (sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5>1.000001*0.5*dx_loc*3**0.5)then"
  write(ilun,format)"        !    print*,'oups at ilevel'"
  write(ilun,format)"        !    print*,xpart(j,1:ndim)"
  write(ilun,format)"        !    print*,xx(j,1:ndim)"
  write(ilun,format)"        !    print*,sum((xx(j,1:ndim)-xpart(j,1:ndim))**2)**0.5/dx"
  write(ilun,format)"        ! end if"
  write(ilun,format)"     end if"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine get_cell_index_for_particle"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine geticell(icell,icd,np)"
  write(ilun,format)"  use amr_parameters, only:nvector,ndim"
  write(ilun,format)"  integer::np"
  write(ilun,format)"  integer,dimension(1:nvector,1:ndim)::icd"
  write(ilun,format)"  integer,dimension(1:nvector)::icell"
  write(ilun,format)"  ! mini subroutine that gets the cell index (1 to 8)"
  write(ilun,format)"  ! for certain coordinates (0,1 along each direction)"
  write(ilun,format)"  ! put into a subroutine to make the code look less ugly"
  write(ilun,format)"  integer::j"
  write(ilun,format)""
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"end subroutine geticell"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine get_cell_center(xx,index,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  real(dp),dimension(1:3)::xx"
  write(ilun,format)"  integer::index,ilevel"
  write(ilun,format)"  ! little helper routine that gets the cell center of a cell with a given index"
  write(ilun,format)"  ! used only for debugging..."
  write(ilun,format)"  integer::ind,ix,iy,iz,i,ind8,grid"
  write(ilun,format)"  real(dp)::dx,scale"
  write(ilun,format)"  real(dp),dimension(1:8,1:3)::xc"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  integer::nx_loc"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,8"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ind8=(index-ncoarse)/ngridmax"
  write(ilun,format)""
  write(ilun,format)"  grid=mod((index-ncoarse),ngridmax)"
  write(ilun,format)"  print*,'ind8',ind8"
  write(ilun,format)"  print*,'grid',grid"
  write(ilun,format)"  print*,'xg',xg(grid,1:3)"
  write(ilun,format)"  print*,'xc',xc(ind8+1,1:3)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do i=1,3"
  write(ilun,format)"     xx(i)=(xg(grid,i)+xc(ind8+1,i)-skip_loc(i))*scale"
  write(ilun,format)"  end do"
  write(ilun,format)"  print*,'xx',xx(1:3)"
  write(ilun,format)""
  write(ilun,format)"end subroutine get_cell_center"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine count_parts"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"  integer::info"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! ugly routine to count all particles in the simulation level by level"
  write(ilun,format)"  ! used for debugging"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  integer::igrid,jgrid,i,ngrid,ncache"
  write(ilun,format)"  integer::ig,ip,npart1,npart2,npart2_tot,icpu"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid"
  write(ilun,format)"  integer,dimension(1:nlevelmax)::npts"
  write(ilun,format)""
  write(ilun,format)"  npts=0"
  write(ilun,format)"  do ilevel=1,nlevelmax"
  write(ilun,format)"     npart2=0"
  write(ilun,format)"     ! Loop over cpus"
  write(ilun,format)"     do icpu=1,ncpu"
  write(ilun,format)"        igrid=headl(icpu,ilevel)"
  write(ilun,format)"        ig=0"
  write(ilun,format)"        ip=0"
  write(ilun,format)"        ! Loop over grids"
  write(ilun,format)"        do jgrid=1,numbl(icpu,ilevel)"
  write(ilun,format)"           npart1=numbp(igrid)  ! Number of particles in the grid"
  write(ilun,format)"           npart2=npart2+npart1"
  write(ilun,format)"           igrid=next(igrid)   ! Go to next grid"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"     call MPI_ALLREDUCE(npart2,npart2_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"     npart2_tot=npart2"
  write(ilun,format)"#endif"
  write(ilun,format)"     npts(ilevel)=npart2_tot"
  write(ilun,format)"  end do"
  write(ilun,format)"  if (myid==1)print*,'total'"
  write(ilun,format)"  if (myid==1)print*,npts(1:nlevelmax)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"   npts=0"
  write(ilun,format)"   do ilevel=1,nlevelmax"
  write(ilun,format)"      npart2=0"
  write(ilun,format)""
  write(ilun,format)"      ncache=active(ilevel)%ngrid"
  write(ilun,format)"      do igrid=1,ncache,nvector"
  write(ilun,format)"         ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"         do i=1,ngrid"
  write(ilun,format)"            ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"         end do"
  write(ilun,format)"         do i=1,ngrid"
  write(ilun,format)"            npart2=npart2+numbp(ind_grid(i))"
  write(ilun,format)"         end do"
  write(ilun,format)""
  write(ilun,format)"      end do"
  write(ilun,format)""
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"      call MPI_ALLREDUCE(npart2,npart2_tot,1,MPI_INTEGER,MPI_SUM,MPI_COMM_WORLD,info)"
  write(ilun,format)"#else"
  write(ilun,format)"      npart2_tot=npart2"
  write(ilun,format)"#endif"
  write(ilun,format)"      npts(ilevel)=npart2_tot"
  write(ilun,format)"   end do"
  write(ilun,format)"   if (myid==1)print*,'active'"
  write(ilun,format)"   if (myid==1)print*,npts(1:nlevelmax)"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine count_parts"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_grid_part"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim)::vol"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim)::indp"
  write(ilun,format)"  logical ,dimension(1:nvector,1:twotondim)::ok"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,twotondim)::xx"
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine returns the CIC cells and volumes for np particles."
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  integer::i,j,ind,idim,nx_loc,ix,iy,iz"
  write(ilun,format)"  real(dp)::dx,dx_loc,scale,vol_loc"
  write(ilun,format)"  ! Grid-based arrays"
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_cell"
  write(ilun,format)"  integer ,dimension(1:nvector,1:threetondim),save::nbors_father_cells"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::nbors_father_grids"
  write(ilun,format)"  ! Particle-based arrays"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x,dd,dg"
  write(ilun,format)"  integer ,dimension(1:nvector,1:ndim),save::ig,id,igg,igd,icg,icd"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::igrid,icell,kg"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim),save::x0"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:ndim)::xc"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  dx=0.5D0**ilevel"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"#if NDIM>1"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM>2"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"#endif"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Lower left corner of 3x3x3 grid-cube  do idim=1,ndim"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do i=1,ng"
  write(ilun,format)"        x0(i,idim)=xg(ind_grid(i),idim)-3.0D0*dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do i=1,ng"
  write(ilun,format)"     ind_cell(i)=father(ind_grid(i))"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Gather neighboring father cells (should be present anytime !)"
  write(ilun,format)"  call get3cubefather(ind_cell,nbors_father_cells,nbors_father_grids,ng,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  ! Rescale particle position at level ilevel"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=xpart(j,idim)/scale+skip_loc(idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)-x0(ind_grid_part(j),idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        x(j,idim)=x(j,idim)/dx"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (x(j,idim)<0.5 .or. x(j,idim)>5.5)then"
  write(ilun,format)"           print*,'particle outside allowed boundary for cic_get_cell'"
  write(ilun,format)"           print*,x(j,1:ndim)"
  write(ilun,format)"           if (x(j,idim)<0. .or. x(j,idim)>6.)then"
  write(ilun,format)"              print*,'particle outside allowed 3by3by3 grid cube'"
  write(ilun,format)"           end if"
  write(ilun,format)"           call clean_stop"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! CIC at level ilevel (dd: right cloud boundary; dg: left cloud boundary)"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        dd(j,idim)=x(j,idim)+0.5D0"
  write(ilun,format)"        id(j,idim)=INT( dd(j,idim) )"
  write(ilun,format)"        dd(j,idim)=dd(j,idim)-id(j,idim)"
  write(ilun,format)"        dg(j,idim)=1.0D0-dd(j,idim)"
  write(ilun,format)"        ig(j,idim)=id(j,idim)-1"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Compute cloud volumes"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)"
  write(ilun,format)"     vol(j,2)=dd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)*dg(j,2)"
  write(ilun,format)"     vol(j,2)=dd(j,1)*dg(j,2)"
  write(ilun,format)"     vol(j,3)=dg(j,1)*dd(j,2)"
  write(ilun,format)"     vol(j,4)=dd(j,1)*dd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     vol(j,1)=dg(j,1)*dg(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,2)=dd(j,1)*dg(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,3)=dg(j,1)*dd(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,4)=dd(j,1)*dd(j,2)*dg(j,3)"
  write(ilun,format)"     vol(j,5)=dg(j,1)*dg(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,6)=dd(j,1)*dg(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,7)=dg(j,1)*dd(j,2)*dd(j,3)"
  write(ilun,format)"     vol(j,8)=dd(j,1)*dd(j,2)*dd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent grids"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igg(j,idim)=ig(j,idim)/2"
  write(ilun,format)"        igd(j,idim)=id(j,idim)/2"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)+3*igg(j,2)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)+3*igg(j,2)"
  write(ilun,format)"     kg(j,3)=1+igg(j,1)+3*igd(j,2)"
  write(ilun,format)"     kg(j,4)=1+igd(j,1)+3*igd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     kg(j,1)=1+igg(j,1)+3*igg(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,2)=1+igd(j,1)+3*igg(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,3)=1+igg(j,1)+3*igd(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,4)=1+igd(j,1)+3*igd(j,2)+9*igg(j,3)"
  write(ilun,format)"     kg(j,5)=1+igg(j,1)+3*igg(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,6)=1+igd(j,1)+3*igg(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,7)=1+igg(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"     kg(j,8)=1+igd(j,1)+3*igd(j,2)+9*igd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        igrid(j,ind)=son(nbors_father_cells(ind_grid_part(j),kg(j,ind)))"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Check if particle has escaped to ilevel-1"
  write(ilun,format)"  ok(1:np,1:twotondim)=.true."
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (igrid(j,ind)==0)then"
  write(ilun,format)"           ! print*,'particle has partially escaped to ilevel-1'"
  write(ilun,format)"           ok(j,ind)=.false."
  write(ilun,format)"           indp(j,ind)=nbors_father_cells(ind_grid_part(j),kg(j,ind))"
  write(ilun,format)"!           xx(j,1:ndim,ind)=(xg(ind_grid(ind_grid_part(j)),1:ndim)+ind3(kg(j,ind),1:ndim)*2.*dx-skip_loc(1:ndim))*scale"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  ! Compute parent cell position"
  write(ilun,format)"  do idim=1,ndim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        icg(j,idim)=ig(j,idim)-2*igg(j,idim)"
  write(ilun,format)"        icd(j,idim)=id(j,idim)-2*igd(j,idim)"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"#if NDIM==1"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==2"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)+2*icg(j,2)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)+2*icg(j,2)"
  write(ilun,format)"     icell(j,3)=1+icg(j,1)+2*icd(j,2)"
  write(ilun,format)"     icell(j,4)=1+icd(j,1)+2*icd(j,2)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)"#if NDIM==3"
  write(ilun,format)"  do j=1,np"
  write(ilun,format)"     icell(j,1)=1+icg(j,1)+2*icg(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,2)=1+icd(j,1)+2*icg(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,3)=1+icg(j,1)+2*icd(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,4)=1+icd(j,1)+2*icd(j,2)+4*icg(j,3)"
  write(ilun,format)"     icell(j,5)=1+icg(j,1)+2*icg(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,6)=1+icd(j,1)+2*icg(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,7)=1+icg(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"     icell(j,8)=1+icd(j,1)+2*icd(j,2)+4*icd(j,3)"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (ok(j,ind))then"
  write(ilun,format)"           ! Compute parent cell adress for cells in ilevel or ilevel+1"
  write(ilun,format)"           indp(j,ind)=ncoarse+(icell(j,ind)-1)*ngridmax+igrid(j,ind)"
  write(ilun,format)"           ! Check if particles have leaked into level ilevel+1"
  write(ilun,format)"           ! if so, set ok to false, but read values from split cell"
  write(ilun,format)"           ok(j,ind)=(son(indp(j,ind))==0)"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     do j=1,np"
  write(ilun,format)"        if (ok(j,ind))then"
  write(ilun,format)"           xx(j,1:ndim,ind)=(xg(igrid(j,ind),1:ndim)+xc(icell(j,ind),1:ndim)-skip_loc(1:ndim))*scale"
  write(ilun,format)"        end if"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"end subroutine cic_get_cells"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"subroutine cic_get_vals(fluid_var,ind_grid,xpart,ind_grid_part,ng,np,ilevel,ilevel_only)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  use hydro_commons, ONLY: nvar,uold"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ng,np,ilevel"
  write(ilun,format)"  logical::ilevel_only"
  write(ilun,format)""
  write(ilun,format)"  integer ,dimension(1:nvector)::ind_grid,ind_grid_part"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar+3)::fluid_var"
  write(ilun,format)"#else"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:nvar)::fluid_var"
  write(ilun,format)"#endif"
  write(ilun,format)"  real(dp) ,dimension(1:nvector,1:ndim)::xpart"
  write(ilun,format)""
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  ! This routine returns the CIC cells and volumes for np particles."
  write(ilun,format)"  !------------------------------------------------------------------"
  write(ilun,format)"  integer::j,ind,ivar"
  write(ilun,format)""
  write(ilun,format)"  ! Particle-based arrays"
  write(ilun,format)""
  write(ilun,format)"  real(dp),dimension(1:nvector),save::vol_tot"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:ndim,1:twotondim),save::xx"
  write(ilun,format)"  real(dp),dimension(1:nvector,1:twotondim),save::vol"
  write(ilun,format)"  integer ,dimension(1:nvector,1:twotondim),save::indp"
  write(ilun,format)"  logical ,dimension(1:nvector,twotondim),save::ok"
  write(ilun,format)""
  write(ilun,format)"  call cic_get_cells(indp,xx,vol,ok,ind_grid,xpart,ind_grid_part,ng,np,ilevel)"
  write(ilun,format)""
  write(ilun,format)"  fluid_var(1:np,1:nvar)=0._dp"
  write(ilun,format)""
  write(ilun,format)"  if (ilevel_only)then"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           if(.not. ok(j,ind))vol(j,ind)=0."
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)""
  write(ilun,format)"     vol_tot(1:np)=0._dp"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           vol_tot(j)=vol_tot(j)+vol(j,ind)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)"  do ivar=1,nvar"
  write(ilun,format)"     do ind=1,twotondim"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)""
  write(ilun,format)"           fluid_var(j,ivar)=fluid_var(j,ivar)&"
  write(ilun,format)"                +uold(indp(j,ind),ivar)*vol(j,ind)"
  write(ilun,format)""
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  if (ilevel_only)then"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"        do j=1,np"
  write(ilun,format)"           if (vol_tot(j)>0.)fluid_var(j,ivar)=fluid_var(j,ivar)/vol_tot(j)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end if"
  write(ilun,format)""
  write(ilun,format)""
  write(ilun,format)"end subroutine cic_get_vals"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine set_unew_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine sets array unew to its initial value uold before creating"
  write(ilun,format)"  ! new sinks. unew is set to zero in virtual boundaries."
  write(ilun,format)"  !--------------------------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,ind,icpu,iskip"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew to uold for myid cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           unew(active(ilevel)%igrid(i)+iskip,ivar) = uold(active(ilevel)%igrid(i)+iskip,ivar)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"  ! Set unew to 0 for virtual boundary cells"
  write(ilun,format)"  do icpu=1,ncpu"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        do i=1,reception(icpu,ilevel)%ngrid"
  write(ilun,format)"           unew(reception(icpu,ilevel)%igrid(i)+iskip,ivar)=0.0"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"  end do"
  write(ilun,format)""
  write(ilun,format)"111 format('   Entering set_unew_sink for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine set_unew_sink"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"!###########################################################"
  write(ilun,format)"subroutine set_uold_sink(ilevel)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use poisson_commons"
  write(ilun,format)"  implicit none"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  ! This routine sets array uold to its new value unew"
  write(ilun,format)"  ! after the hydro step."
  write(ilun,format)"  !---------------------------------------------------------"
  write(ilun,format)"  integer::i,ivar,ind,iskip"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Reverse update boundaries"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"  do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"     call make_virtual_reverse_dp(unew(1,ivar),ilevel)"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"  end do"
  write(ilun,format)"#else"
  write(ilun,format)"  end do"
  write(ilun,format)"#endif"
  write(ilun,format)""
  write(ilun,format)"  ! Set uold to unew for myid cells"
  write(ilun,format)"  do ind=1,twotondim"
  write(ilun,format)"     iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"#ifdef SOLVERmhd"
  write(ilun,format)"     do ivar=1,nvar+3"
  write(ilun,format)"#else"
  write(ilun,format)"     do ivar=1,nvar"
  write(ilun,format)"#endif"
  write(ilun,format)"        do i=1,active(ilevel)%ngrid"
  write(ilun,format)"           uold(active(ilevel)%igrid(i)+iskip,ivar) = unew(active(ilevel)%igrid(i)+iskip,ivar)"
  write(ilun,format)"        end do"
  write(ilun,format)"     end do"
  write(ilun,format)"  end do"
  write(ilun,format)"111 format('   Entering set_uold_sink for level ',i2)"
  write(ilun,format)""
  write(ilun,format)"end subroutine set_uold_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"subroutine radiative_feedback_sink(ilevel)"
  write(ilun,format)"  use pm_commons"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use cloud_module,only: rt_protostar_m1"
  write(ilun,format)"  use cooling_module,only: clight"
  write(ilun,format)"  use radiation_parameters,only:stellar_photon,aR,Tstar"
  write(ilun,format)"  use units_commons"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"  use rt_hydro_commons"
  write(ilun,format)"#endif"
  write(ilun,format)"  implicit none"
  write(ilun,format)"#ifndef WITHOUTMPI"
  write(ilun,format)"  include 'mpif.h'"
  write(ilun,format)"#endif"
  write(ilun,format)"  integer::ilevel"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"  ! This routine performs radiative feedback from the sink. It vectorizes "
  write(ilun,format)"  ! the loop over all sink cloud particles and calls accrete_sink as soon "
  write(ilun,format)"  !as nvector particles are collected"
  write(ilun,format)"  !------------------------------------------------------------------------"
  write(ilun,format)"!!   integer::igrid,jgrid,ipart,jpart,next_part,info,ix,iy,iz"
  write(ilun,format)"!!   integer::ig,ip,npart1,npart2,icpu,lev,isink,ind"
  write(ilun,format)"!!   integer,dimension(1:nvector)::ind_grid,ind_part,ind_grid_part"
  write(ilun,format)"  integer::isink,ind,ix,iy,iz,ngrid,iskip"
  write(ilun,format)"  integer::i,nx_loc,igrid,ncache,igrp"
  write(ilun,format)"  integer,dimension(1:nvector)::ind_grid,ind_cell"
  write(ilun,format)"  real(dp)::x,y,z,dx,dxx,dyy,dzz,drr,rr,pi"
  write(ilun,format)"  real(dp)::scale,dx_loc,vol_loc,rmax2,rmax"
  write(ilun,format)"  real(dp)::q,h_loc,kernelvalue,weight,radiation_source,Lum_group!,Tstar"
  write(ilun,format)"  real(dp),dimension(1:3)::skip_loc"
  write(ilun,format)"  real(dp),dimension(1:twotondim,1:3)::xc"
  write(ilun,format)"  logical ,dimension(1:nvector)::ok"
  write(ilun,format)""
  write(ilun,format)"  pi=acos(-1.0d0)"
  write(ilun,format)""
  write(ilun,format)"  if(numbtot(1,ilevel)==0)return"
  write(ilun,format)"  if(verbose)write(*,111)ilevel"
  write(ilun,format)""
  write(ilun,format)"  ! Mesh spacing in that level"
  write(ilun,format)"  nx_loc=(icoarse_max-icoarse_min+1)"
  write(ilun,format)"  skip_loc=(/0.0d0,0.0d0,0.0d0/)"
  write(ilun,format)"  if(ndim>0)skip_loc(1)=dble(icoarse_min)"
  write(ilun,format)"  if(ndim>1)skip_loc(2)=dble(jcoarse_min)"
  write(ilun,format)"  if(ndim>2)skip_loc(3)=dble(kcoarse_min)"
  write(ilun,format)"  scale=boxlen/dble(nx_loc)"
  write(ilun,format)"  "
  write(ilun,format)"  ! Computing local volume (important for averaging hydro quantities) "
  write(ilun,format)"  dx=0.5D0**ilevel "
  write(ilun,format)"  dx_loc=dx*scale"
  write(ilun,format)"  vol_loc=dx_loc**ndim"
  write(ilun,format)"  rmax = ir_cloud*dx_loc"
  write(ilun,format)"  rmax2=rmax**2"
  write(ilun,format)"  h_loc=rmax/2.0d0"
  write(ilun,format)"  ! Cells center position relative to grid center position"
  write(ilun,format)"  do ind=1,twotondim  "
  write(ilun,format)"     iz=(ind-1)/4"
  write(ilun,format)"     iy=(ind-1-4*iz)/2"
  write(ilun,format)"     ix=(ind-1-2*iy-4*iz)"
  write(ilun,format)"     xc(ind,1)=(dble(ix)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,2)=(dble(iy)-0.5D0)*dx"
  write(ilun,format)"     xc(ind,3)=(dble(iz)-0.5D0)*dx"
  write(ilun,format)"  end do"
  write(ilun,format)"  "
  write(ilun,format)"  ! Loop over grids"
  write(ilun,format)"  ncache=active(ilevel)%ngrid"
  write(ilun,format)"  do igrid=1,ncache,nvector"
  write(ilun,format)"     ngrid=MIN(nvector,ncache-igrid+1)"
  write(ilun,format)"     do i=1,ngrid"
  write(ilun,format)"        ind_grid(i)=active(ilevel)%igrid(igrid+i-1)"
  write(ilun,format)"     end do"
  write(ilun,format)"     "
  write(ilun,format)"     ! Loop over cells"
  write(ilun,format)"     do ind=1,twotondim  "
  write(ilun,format)"        iskip=ncoarse+(ind-1)*ngridmax"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ind_cell(i)=iskip+ind_grid(i)"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"           ! Flag leaf cells"
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           ok(i)=son(ind_cell(i))==0"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"        do i=1,ngrid"
  write(ilun,format)"           if(ok(i))then"
  write(ilun,format)"              ! Get gas cell position"
  write(ilun,format)"              x=(xg(ind_grid(i),1)+xc(ind,1)-skip_loc(1))*scale"
  write(ilun,format)"              y=(xg(ind_grid(i),2)+xc(ind,2)-skip_loc(2))*scale"
  write(ilun,format)"              z=(xg(ind_grid(i),3)+xc(ind,3)-skip_loc(3))*scale"
  write(ilun,format)"              do isink=1,nsink"
  write(ilun,format)"                 ! Check if the cell lies within the sink radius"
  write(ilun,format)"                 dxx=x-xsink(isink,1)"
  write(ilun,format)"                 if(dxx> 0.5*scale)then"
  write(ilun,format)"                    dxx=dxx-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dxx<-0.5*scale)then"
  write(ilun,format)"                    dxx=dxx+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 dyy=y-xsink(isink,2)"
  write(ilun,format)"                 if(dyy> 0.5*scale)then"
  write(ilun,format)"                    dyy=dyy-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dyy<-0.5*scale)then"
  write(ilun,format)"                    dyy=dyy+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 dzz=z-xsink(isink,3)"
  write(ilun,format)"                 if(dzz> 0.5*scale)then"
  write(ilun,format)"                    dzz=dzz-scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 if(dzz<-0.5*scale)then"
  write(ilun,format)"                    dzz=dzz+scale"
  write(ilun,format)"                 endif"
  write(ilun,format)"                 drr=dxx*dxx+dyy*dyy+dzz*dzz"
  write(ilun,format)"                 rr=sqrt(drr)"
  write(ilun,format)"                 if(drr.lt.rmax2)then"
  write(ilun,format)"                    q = rr/h_loc"
  write(ilun,format)"                    !              "
  write(ilun,format)"                    ! Spread luminosity using a M4 spline truncated at 2*h_loc"
  write(ilun,format)"                    kernelvalue=0.0d0"
  write(ilun,format)"                    "
  write(ilun,format)"                    if ((q.lt.1.0)) kernelvalue = 1.0d0-1.5d0*q**2+0.75d0*q**3 !=0.25d0*(2.0d0-q)**3-(1.0d0-q)**3"
  write(ilun,format)"                    if ((q.ge.1.0)  .and.(q.lt.2.0)) kernelvalue = 0.25d0*(2.0d0-q)**3"
  write(ilun,format)"                    weight = kernelvalue/(pi*h_loc**3)"
  write(ilun,format)"                    weight =1.0d0 ! bypass wightin. Maybe to be reconsidered..."
  write(ilun,format)"                   ! Tstar = Teff_sink(isink)"
  write(ilun,format)"                    if(Tstar .gt. 0)then"
  write(ilun,format)"                       if(.not. rt_protostar_m1)then                       "
  write(ilun,format)"                          if(stellar_photon)then"
  write(ilun,format)"                             igrp=1    ! Put all stellar radiative flux in the first group "
  write(ilun,format)"                             uold(ind_cell(i),5     )=uold(ind_cell(i),5     ) + Lum_sink(isink)*weight*dtnew(ilevel)/(8.0d0*rmax**3)!((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                             uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + Lum_sink(isink)*weight*dtnew(ilevel)/(8.0d0*rmax**3)!((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                          else"
  write(ilun,format)"                             do igrp=1,ngrp "
  write(ilun,format)"                                !write(*,*) 'lumsink, lumgroup: ', Lum_sink(isink), Lum_group"
  write(ilun,format)"                                Lum_group = radiation_source(Tstar,igrp)/(scale_d*scale_v**2)*(pi*rsink_star(isink)**2*clight/scale_v)"
  write(ilun,format)"                                uold(ind_cell(i),5     )=uold(ind_cell(i),5     ) + Lum_group*weight*dtnew(ilevel)/(8.0d0*rmax**3)!((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                                uold(ind_cell(i),8+igrp)=uold(ind_cell(i),8+igrp) + Lum_group*weight*dtnew(ilevel)/(8.0d0*rmax**3)!((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                             end do"
  write(ilun,format)"                          end if"
  write(ilun,format)"                       endif"
  write(ilun,format)"#ifdef RT"
  write(ilun,format)"                       !write(*,*) rt_protostar_m1, Tstar"
  write(ilun,format)"                       if(rt_protostar_m1)then"
  write(ilun,format)"                          ! We assume that energy is transported with M1 (rather than a number of photons with a mean energy groupe_egy)."
  write(ilun,format)"                          ! To be reconsidered when we will do Hii ionisation for later evolution."
  write(ilun,format)"                          Lum_group = aR*(Tstar**4)/(scale_d*scale_v**2)*(pi*rsink_star(isink)**2*clight/scale_v)"
  write(ilun,format)"                          !write(*,*) 'Lum_group= ', Lum_group"
  write(ilun,format)"                          rtunew(ind_cell(i),1)=rtunew(ind_cell(i),1) + Lum_group*weight*dtnew(ilevel)/((group_egy(1)*ev_to_erg)/scale_d/scale_v**2)/(8.0d0*rmax**3)!((4.0d0*pi*rmax**3)/3.0d0)"
  write(ilun,format)"                       end if"
  write(ilun,format)"#endif"
  write(ilun,format)"                    end if"
  write(ilun,format)""
  write(ilun,format)"                 endif"
  write(ilun,format)"                 "
  write(ilun,format)"              end do"
  write(ilun,format)"           endif"
  write(ilun,format)"        end do"
  write(ilun,format)"        "
  write(ilun,format)"     end do"
  write(ilun,format)"     ! End loop over cells"
  write(ilun,format)"  end do"
  write(ilun,format)"  ! End loop over grids"
  write(ilun,format)"111 format('   Entering radiative_feedback_sink for level ',I2)"
  write(ilun,format)""
  write(ilun,format)"  ! Update hydro quantities for split cells"
  write(ilun,format)"  call upload_fine(ilevel)"
  write(ilun,format)"  do igrp=1,nvar"
  write(ilun,format)"     call make_virtual_fine_dp(uold(1,igrp),ilevel)"
  write(ilun,format)"  enddo"
  write(ilun,format)"  "
  write(ilun,format)""
  write(ilun,format)"end subroutine radiative_feedback_sink"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"!################################################################"
  write(ilun,format)"#else"
  write(ilun,format)"subroutine radiative_feedback_sink"
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  write(*,*) 'You should not enter here with NDIM!=3...'"
  write(ilun,format)""
  write(ilun,format)"  return"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine radiative_feedback_sink"
  write(ilun,format)"#endif"
  write(ilun,format)"../patch/irradiation/test_pascucci/units.f90"
  write(ilun,format)"subroutine units(scale_l,scale_t,scale_d,scale_v,scale_nH,scale_T2)"
  write(ilun,format)"  use amr_commons"
  write(ilun,format)"  use hydro_commons"
  write(ilun,format)"  use constants, only: Mpc2cm, mH, kB, rhoc"
  write(ilun,format)"  use cooling_module, only: X"
  write(ilun,format)"  use units_commons, only : scale_kappa,scale_m"
  write(ilun,format)"  use radiation_parameters, only : mu_gas"
  write(ilun,format)""
  write(ilun,format)"  implicit none"
  write(ilun,format)""
  write(ilun,format)"  real(dp)::scale_nH,scale_T2,scale_t,scale_v,scale_d,scale_l"
  write(ilun,format)"  real(dp)::pc"
  write(ilun,format)"  "
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)"  ! Conversion factors from user units into cgs units"
  write(ilun,format)"  ! For gravity runs, make sure that G=1 in user units."
  write(ilun,format)"  !-----------------------------------------------------------------------"
  write(ilun,format)""
  write(ilun,format)"  !code units are: G=1, rho cm^-3, x pc"
  write(ilun,format)"  pc = 3.08e18_dp"
  write(ilun,format)""
  write(ilun,format)"  ! scale_d converts mass density from user units into g/cc"
  write(ilun,format)"  !scale_d = units_density"
  write(ilun,format)"  !if(cosmo) scale_d = omega_m * rhoc *(h0/100.)**2 / aexp**3"
  write(ilun,format)"  !calculate the initial density"
  write(ilun,format)"  scale_d = 1.d-20"
  write(ilun,format)""
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  !scale_t = units_time"
  write(ilun,format)"  !if(cosmo) scale_t = aexp**2 / (h0*1d5/Mpc2cm)"
  write(ilun,format)"  ! scale_t converts time from user units into seconds"
  write(ilun,format)"  scale_t = 1.0_dp/sqrt(Grav*scale_d)"
  write(ilun,format)""
  write(ilun,format)"  ! scale_l converts distance from user units into cm"
  write(ilun,format)"  !scale_l = units_length"
  write(ilun,format)"  !if(cosmo) scale_l = aexp * boxlen_ini * Mpc2cm / (h0/100)"
  write(ilun,format)"  !calculate the initial cloud radius"
  write(ilun,format)"  scale_l = 1.496d13"
  write(ilun,format)""
  write(ilun,format)"  ! scale_v converts velocity in user units into cm/s"
  write(ilun,format)"  scale_v = scale_l / scale_t"
  write(ilun,format)""
  write(ilun,format)"  ! scale_T2 converts (P/rho) in user unit into (T/mu) in Kelvin"
  write(ilun,format)"  !kT = 10. * kB  / G / pc^2 / mpart^2"
  write(ilun,format)"  scale_T2 = mu_gas**2 * mH**2 * pc**2 * Grav / kb"
  write(ilun,format)""
  write(ilun,format)"  ! scale_nH converts rho in user units into nH in H/cc"
  write(ilun,format)"!  scale_nH = X/(mH*mu) * scale_d"
  write(ilun,format)"  scale_nH =  X/(mH) * scale_d !1.0_dp"
  write(ilun,format)"  "
  write(ilun,format)"  scale_kappa = 1.0_dp/scale_l"
  write(ilun,format)"  "
  write(ilun,format)"  scale_m = scale_d*scale_l**3"
  write(ilun,format)"  "
  write(ilun,format)"#if NIMHD==1"
  write(ilun,format)"  ! modif nimhd"
  write(ilun,format)"  if(ntestDADM.eq.1) then"
  write(ilun,format)"      scale_d = 1.0_dp"
  write(ilun,format)"      scale_l = 1.0_dp"
  write(ilun,format)"      scale_v = 1.d0"
  write(ilun,format)"      scale_t = 1.0_dp"
  write(ilun,format)"  end if"
  write(ilun,format)"  ! fin modif nimhd"
  write(ilun,format)"#endif"
  write(ilun,format)"  "
  write(ilun,format)"end subroutine units"
  write(ilun,format)""
  close(ilun)
end subroutine output_patch
